# 851复习文档

> ### By Liuxiao && Jianjian

## 线性结构

​	*什么是线性结构，链表和线性表的区别，二者的特点*



>  线性结构是一种数据元素之间存在一对一关系的数据结构。在这种结构中，除了第一个和最后一个元素外，每个元素都有一个直接前驱和一个直接后继。线性结构可以是顺序存储的（如数组），也可以是非顺序存储的（如链表）
>
> ***\*线性表（Linear List）\**** 通常指的是逻辑上的概念，它是一个由n个数据元素组成的有限序列。这些数据元素具有相同的类型，并且有先后次序。如数组。
>
> ***\*链表（Linked List）\**** 是一种物理存储单元上非连续、非顺序的线性结构，用一组任意的存储单元来存放线性表中的数据元素。链表中的数据元素被称为节点，每个节点包含数据域和指向下一个节点的指针域。根据指针的连接方式，链表可以分为单链表、双链表和循环链表等。
>
> ***\*二者的特点：\****
>
> 线性表（以数组为例）
>
> o 随机访问：可以直接通过下标在O(1)时间内访问到指定位置的元素。
>
> o 存储密度高：由于元素在内存中是连续存储的，所以没有额外的空间浪费。
>
> o 插入删除效率低：如果需要在中间插入或删除元素，则可能需要移动大量元素，平均时间复杂度为O(n)。
>
> o 固定大小：一般而言，数组创建时需要指定大小，在使用过程中不容易改变。
>
> 链表
>
> o 顺序访问：只能从头节点开始，逐个访问后续节点，无法直接跳转到某个特定位置，访问时间为O(n)。
>
> o 插入删除效率高：只需要修改前后节点的指针即可完成插入或删除操作，不需要移动元素，时间复杂度为O(1)。
>
> o 存储密度较低：因为每个节点除了数据域外还需要额外的指针域来链接下一个节点

## 树、二叉树、 森林

### 树

> 树（Tree） 是一种非线性的数据结构，它由n（n>=0）个有限节点组成一个具有层次关系的集合。这个集合满足以下条件：
>
> 1. 有一个特定的称为根（root）的节点。
> 2. 剩余的节点可以被分为m（m >= 0）个互不相交的子集T1, T2, ..., Tm，每个子集本身又是一棵树，并且这些子集被称为根的子树。
> 3. 在树结构中，除了根节点之外，每个节点有且仅有一个父节点，而根节点没有父节点。同时，一个节点可以有零个或多个子节点。

### 二叉树

> **二叉树（**Binary Tree） 是一种特殊的树结构，它的特点是每个节点最多只能有两个子节点：左子节点和右子节点。即使某节点只有一个子节点，也要区分是左子节点还是右子节点。二叉树的定义如下：
>
> 二叉树可以为空。如果非空，则该树由根节点、左子树和右子树组成，其中左子树和右子树也是二叉树。
>
> 二叉树的一些重要特性包括：
>
>  每个节点至多只有两个子节点。
>
> 左子树和右子树是有顺序的，不能随意交换。
>
> 即使树中某个节点只有一棵子树，也要区分它是左子树还是右子树。

#### 二叉树结构

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;
```

#### 非递归先序(Pre)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void PreOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            printf(" %d--", p->data);
            s.push(p);
            p = p->left;//访问左边先 跟左右
        } else {
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            p = p->right;
        }
    }
}

```

#### 非递归中序(In)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void InOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            s.push(p); //先入栈不访问
            p = p->left;//一路向左找

        } else {//某个父节点的左孩子为空 返回父结点并访问
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            printf("%d--", p->data);//这里和先序不太一样
            p = p->right;
        }
    }
}

```

#### 非递归后序(Post)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;


void postOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *visited = NULL;//记录最近访问过的结点
    BiTNode *p = t;
    while (p or !s.empty()) {
        while (p) {
            //尽可能往左走
            s.push(p);
            p = p->left;
        }
        //左边到头了 查看栈元素
        p = s.top();
        if (p->right == NULL or p->right == visited) {
            cout << "--" << p->data;//没右孩子 或 右边已经访问过了
            s.pop();//已经访问该结点
            visited = p;//更新最新结点
            p = NULL;//设置为NULL  以便下一次迭代可以处理栈中的下一个结点
            //比如最后一个结点是根节点 你访问了肯定要设为空 不然is.empty一直为true
        } else {
            //去遍历右子树先
            p = p->right;
        }
    }
}
```

### 平衡二叉树(BST)

>平衡二叉树是一种特殊的二叉树，它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都必须是平衡二叉树。这种结构确保了树的高度保持在对数级别（以2为底），从而保证了各种操作（如查找、插入和删除）的时间复杂度都是O(log n)，其中n是节点的数量。

### 森林

>  森林（Forest） 是指零个或多个不相交的树的集合。换句话说，如果将一棵树的根节点移除，那么剩下的部分就变成了一个森林。森林中的每棵树都是独立的，没有任何节点共享相同的父节点。森林可以看作是树的一种扩展形式，二叉树是对树的一种限制，而森林则是多棵树的集合。
>
> 

```c++
#include <bits/stdc++.h>

using namespace std;

int main(){
    
   
}
```

## 图

### 邻接矩阵



``` c
const int Maxn = 1e3 + 7;
// 邻接矩阵定义
typedef struct MGraph {
char vexes[Maxn]; // 顶点表，可以不要
int edges[Maxn][Maxn]; // 用邻接矩阵存储边
int vexNum, arcNum; // 顶点数，边数
} MGraph;
```

### 邻接表

``` c
const int Maxn = 1e3 + 7;
//边结点
struct ArcNode {
int adjvex; //顶点编号
ArcNode *next; //指向vi的下一个邻接顶点
};
// 顶点结点
struct VNode {
int data; //顶点信息
ArcNode *firstarc; //指向vi的第一个邻接顶点（边）
};
// 图的邻接表表示
typedef struct AGraph {
VNode adjlist[Maxn]; // 顺序存储所有顶点链表的表头结点
int vexNum, arcNum; // 图的顶点个数，边数
} AGraph;
```

### 深搜(DFS)

> 设初始状态时图中的所有顶点未被访问，则： 
>
> 1. 首先，访问开始结点从起始结点开始任选一个相邻并未被 访问的结点，访问； 
> 2. 接着，把找到的结点作为起始结点继续访问其相邻且未被 访问的一个结点； 
> 3. 重复2的操作直到某一个结点所有相邻结点都被访问，则 退回最近被访问且还有相邻结点未被访问的结点；  
> 4. 把3中结点作为起始结点继续执行2，3操作直到所有结点 都被访问完为止

#### dfs邻接表

``` 	c

int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(AGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    ArcNode *p = g->adjlist[v].firstarc;//v指向的第一个邻接结点
       while (p != NULL) {//从起始结点开始任选一个相邻并为访问的结点
        if (visited[p->adjvex] != 1) {
            dfs(g,p->adjvex);//把找到的边 作为起始顶点继续访问
            //未访问过 深度优先
        }
        p = p->next;
    }
}
void dfsTraverse(AGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
        if (visited == 0)  //不需要 重置0 因为 可能有点 不连通 需要继续dfs
            dfs(g, i);
    }//遍历每个没被访问的结点,从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}

```

#### dfs邻接矩阵

``` 	c
int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(MGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    for (int i = 0; i < g->vexNum; ++i) {
        if (g->edges[v][i] == 1 and !visited[i])//有路径且未访问过
            dfs(g, i);
    }
}

void dfsTraverse(MGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
         if (visited[i] == 0)
            dfs(g, i);
    }//遍历每个没被访问的结点 从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}
```





## 排序

>  ==*堆排序*==（Heap Sort）是一种基于比较的排序算法，它利用了堆这种数据结构所设计的一种选择排序。堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于（最大堆）其所有子节点的值，或者每个父节点的值都小于或等于（最小堆）其所有子节点的值。
>
>  ==堆排序的三个时间复杂度都是O(longn),空间复杂度O(1)==
>
>  在堆排序中，我们通常使用最大堆来对数组进行升序排序。以下是堆排序的基本思想和步骤：
>
>  ### 堆排序的思想
>
>  - 首先将待排序序列构建成一个最大堆。
>  - 然后将堆顶元素（即最大值）与序列末尾的元素交换，使得最大值位于已排序部分的末尾。
>  - 重新调整剩余的序列成为一个新的最大堆。
>  - 重复上述过程，直到整个序列排序完成。
>
>  ### 堆排序的步骤
>
>  1. **构建初始堆**：从最后一个非叶子节点开始，向下调整以确保满足最大堆性质。这个过程称为“堆化”
>    - 对于一个大小为 n 的数组，最后一个非叶子节点的位置是 (n/2) - 1。
>    - 从这个位置开始，向前遍历每一个非叶子节点，并调用堆化函数来维护最大堆属性。
>  2. **交换堆顶元素与末尾元素**：将当前堆顶元素（最大值）与未排序序列的最后一个元素交换，然后缩小未排序序列的范围。
>  3. **调整堆**：对于新调整后的堆，再次执行堆化操作，使剩下的元素重新构成最大堆。
>  4. **重复步骤2和3**：持续上述过程，每次都将当前的最大值移动到已排序部分的末尾，直至整个数组变为有序。
>
>  

### 堆排序

``` c++
//
// Created by nvjiachengba on 20/9/2024.
//
#include <bits/stdc++.h>
using namespace std;
// 调整为大根堆 以k为根节点的子树  数组下标从1开始
void HeapAdjust(int arr[], int k, int n) {
    int i = 2 * k;//左孩子
    while (i <= n) {
        //一层一层向下筛选
        if (i < n and arr[i] < arr[i + 1]) {
            i++;//i指向较大的子节点 沿着值大的子节点往下筛选
        }

        if (arr[k] < arr[i]) {
            //根节点比两个孩子中较大的孩子小 交换
            swap(arr[k], arr[i]);
            k = i;//继续调整受影响的子树
            i = k * 2;
        } else {
            break;//无影响 调整结束
        }
    }
}

// 构建大根堆
void buildMaxHeap(int arr[], int n) {
    // 从最后一个非叶子节点开始调整
    for (int i = n / 2; i >= 0; i--)//从后往前调整 例如7个元素 1-2-3 非叶节点是1，2，3下标
        HeapAdjust(arr, n, i);
}

// 堆排序
void heapSort(int arr[], int n) {
    // 构建大根堆
    buildMaxHeap(arr, n);
    // 逐个移除堆顶元素 与待排序序列中的最后一个元素进行交换
    for (int i = n; i > 1; i--) {
        // 将堆顶元素移到数组末尾
        //为什么移动到末尾 因为如果你 这相当于排序 你要给他移动到 n n-1 n-2····1
        swap(arr[1], arr[i]);
        // 调整剩余元素为大根堆
        HeapAdjust(arr, 1, i - 1);
    }
}

// 打印数组
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = 6;
    printf("Original array: \n");
    printArray(arr, n);
    heapSort(arr, n);
    printf("Sorted array: \n");
    printArray(arr, n);
    return 0;
}
```



# 算法



## 递归

### 定义思想

> 1. 直接或间接地调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。 
> 2. 直接递归：p函数中调用p函数 
> 3. 间接递归：p函数调用q函数，q函数又调用p函数。 
> 4. 递归函数的两个要素：边界条件、递归方程

> ### 递归小结： 
>
> 1.优点：结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序 带来很大方便。 
>
> 2.缺点：递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。 
>
> 3.解决方法：在递归算法中消除递归调用，使其转化为非递归算法。采用一个用户定义的栈来模拟系统的递归调用工作栈。该方法通用性强，但本质上还是递归 优化效果不明显。 （2）、用递推来实现递归函数。 （3）、通过变换能将一些递归转化为尾递归，从而迭代求出结果

### 分治与递归的区别

> **分治法与递归区别**： 
>
> 1. 分治法是解决问题的方法。
>
> 2. 递归是实现各种算法的工具，二叉树、回溯、贪心算法等都可以选择用递归的方式来解决。

## 分治

### 定义思想

> **定义：** 分治法是一种将问题分解成若干个规模较小的相同子问题，然后递归地解决这些子问题，并将各个子问题的解合并得到原问题解的方法。
>
> **思想：**
>
> 1. **分解**：将原问题分解为几个规模较小、相互独立且与原问题形式相同的子问题。
> 2. **解决**：若子问题规模足够小，则直接求解；否则继续分解为更小的子问题，直到可以直接求解。
> 3. **合并**：将子问题的解逐层合并，形成最终的原问题的解

## 动规

### 定义思想

> **定义**：
> 动态规划是通过把原问题分解为相对简单的子问题来求解复杂问题的一种方法。它通常用来解决最优化问题，即从许多可行解中找出一个最优解。
>
> **思想**：
>
> 重叠子问题：动态规划适用于子问题会重复出现的情况，这样可以通过保存已经解决过的子问题的答案来避免重复计算。
> 最优子结构：一个问题的最优解依赖于其子问题的最优解。这意味着可以通过组合子问题的最优解来构造整个问题的最优解。记忆化：利用数组或哈希表存储已解决子问题的结果，以减少计算量。

## 动规和分治联系与区别

> ### 相同点
>
> 1. **分解思想**：
>    - 两者都将原问题分解成较小的子问题。
>    - 都试图通过解决这些子问题来构建整个问题的解决方案。
> 2. **递归结构**：
>    - 分治法通常采用自顶向下的递归来解决问题。
>    - 动态规划也可以使用带有记忆化的递归来实现，这被称为自顶向下的方法。
>
> ### 不同点
>
> 1. **子问题的独立性**：
>    - 分治法中的子问题是独立的，不共享状态信息。
>    - 动态规划处理的是具有重叠子问题的情况，这些子问题之间可能存在依赖关系。
> 2. **求解方式**：
>    - 分治法通常是自顶向下的递归过程。
>    - 动态规划可以是自底向上的迭代过程，也可以采用带备忘录的自顶向下的递归方法。
> 3. **适用场景**：
>    - 分治法适合用于能够被分解为多个完全独立的子问题的问题。
>    - 动态规划适合于那些可以通过分解为更小的子问题并且子问题存在重叠的情况，以及需要寻找最优解的问题。

## 贪心

> **定义**： 贪心算法总是作出在当前看来最好的选择,即贪心选择。也就是说贪心算法并不从整体最优考虑， 
>
> 它所作出的选择只是在某种意义上的局部最优选择。 (当然，希望贪心算法得到的最终结果也是整体最优的。 虽然贪心算法不能对所有问题都得到整体最 优解， 但对许多问题它能产生整体最优解。 在一些情况下， 即使贪心算法不能得到整体最优解， 其最终结果却是最优解的很好近似。
>
> **基本要素**： 贪心选择性质：指所求问题的整体最优解可以通过一系列局部最优的选择， 即贪心选择来达到。（动规的每一步选择往往与其子问题的解有关，而贪心选择不顾前后，仅看当下。） 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质
>
> 贪心算法的特点： 
>
>  a.贪心算法并不保证得到最优解，但是，对于很多问题确实可以求得最优解。 
>
> b.贪心算法可能依赖之前作出的决定，但是，不依赖任何将来的选择或是子问题的解。 
>
> c.贪心算法适用于组合优化问题 
>
> d.贪心算法的求解过程是多步判断过程，最终的判断序列对应于问题的最优解。 
>
> e.依据**某种** “眼前最好，短视的” （这说明在具体的问题中，有多种不同的贪心策略，我们需 要进行可行性的判定）贪心选择性质判断，性质好坏决定算法的成败。 
>
> f. 贪心法必须进行正确性证明 
>
> g.证明贪心法的不正确的技巧： 举反例



### 贪心和动规

> ### 贪心算法
>
> - **局部最优选择**：贪心算法在每一步都做出当前看起来最好的选择，并且期望这些局部最优的选择能够导致全局最优解。
> - **适用范围有限**：贪心算法只适用于那些具有“贪心选择性质”的问题。也就是说，局部最优解可以累积成为全局最优解的问题。对于很多问题，贪心算法可能无法找到最优解。
>
> ### 动态规划
>
> - **全局考虑**：动态规划通过将问题分解为子问题来寻找最优解，并利用子问题的解来构造原问题的解。它会考虑到所有可能的情况，从而确保得到全局最优解。
> - **记忆化/重叠子问题**：动态规划利用了子问题的重叠性质，即同一个子问题不会被重复计算多次。通常通过使用数组或其他数据结构存储已经解决过的子问题的结果。
> - **递归与迭代**：动态规划既可以采用自顶向下的递归方式，也可以采用自底向上的迭代方式。
>
> ### 相同点
>
>    都要求最优子结构
>
> ### 贪心算法的优缺点： 
>
>    优点：算法简单，时间和空间复杂度低。 
>
>   缺点：适用范围有限。



## 回溯

> **定义**： 在问题的解空间树中， 按深度优先策略，从根结点出发搜索解空间树。（问题的解空间一般用树形式来组织，也称为解空间树或状态空间） 
>
> **问题的解空间**: 一个复杂问题的解决方案是由若干个小的决策步骤组成的决策序列，解决一个问题的所有可能的决策序列 构成该问题的解空间。 
>
> 解空间树: 问题的解空间一般用树形式来组织，也称为解空间树或状态空间，树中的每一个结点确定所求解问题的一个问题状态。 
>
> 树的根结点位于第1层，表示搜索的初始状态（不做任何选择），第2层的结点做出第一次选择后到达的状 态，以此类推。 
>
> 可行解与最优解: 解空间中满足约束条件的决策序列称为可行解。 解任何问题都有一个目标，在约束条件下使目标达到最优的可行解称为该问题的最优解。
>
> 其他概念: 活结点： 是指自身已生成但其孩子结点没有全部生成的结点。 
>
> 扩展结点： 是指正在产生孩子结点的结点。 
>
> 死结点： 是指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕。 
>
> 子孙： 结点E的子树上所有结点都是E的子孙。 
>
> 祖宗： 从结点E到树根路径上的所有结点都是E的祖宗。

### 回溯思想 

> 1. **试探**：从根节点（通常是初始状态）开始，按照一定的顺序探索可能的解。
> 2. **前进**：在每一步中，根据问题定义做出一个选择，进入下一个状态。
> 3. **检查**：到达某个状态后，判断这个状态是否满足问题的部分约束条件。如果满足，则继续深入；如果不满足，则需要进行回溯。
> 4. **回溯**：当发现当前的选择不能导致有效的解时，算法会撤销之前的选择（即“回溯”），回到上一个决策点，尝试其他未被探索过的选项。
> 5. **终止条件**：当找到一个完整的解或者所有可能的解都被探索完毕时，算法结束

> **剪枝**：在回溯过程中，通过某些条件提前终止对不可能产生有效解的分支的探索，从而减少不必要的计算。这包括限界函数和约束函数。
>
> - ==**约束函数**==：用来决定哪些节点是可行的，即这些节点对应的解部分满足问题的约束条件。//可行解
> - ==**限界函数**==：用于估计子树中的最优解，以确定是否值得进一步探索该子树  //最优解

## 分支限界

> ### 定义
>
> 分支限界法（Branch and Bound, B&B）是一种用于求解优化问题的算法，结合了广度优先搜索和贪心算法的思想，通过系统地生成可行解，并利用限界函数来避免探索那些不可能产生最优解的分支，从而提高搜索效率。

### 思想

> ### 分支限界法的思想
>
> 1. **分支**：将问题分解为更小的子问题，每个子问题代表了解空间的一部分。
> 2. **限界**：对于每一个子问题，==计算一个下界（最小化问题）或上界（最大化问题）==，这个界限用来估计从当前节点开始能够得到的最好结果。
> 3. **剪枝**：如果某个节点的界限已经超过了目前已知的最佳解，则可以放弃对该节点及其后代节点的进一步探索，因为它们不会导致更好的解。
> 4. **选择**：按照一定的策略（如队列、堆等）选择下一个要扩展的节点，通常选择最有希望改进当前最佳解的节点。
> 5. **更新**：一旦找到一个新的可行解，就更新最佳解，并用新的最佳解去修剪更多的分支。

> ### 相关概念
>
> - **状态空间树**：类似于回溯法中的解空间树，分支限界法也构建了一个表示所有可能解的状态空间树。
> - **活节点**：在搜索过程中尚未被完全处理的节点，即还有可能成为最终解路径上的节点。
> - **死节点**：已经被确定不能产生比现有最优解更好的解的节点。
> - **限界函数**：提供了一个关于解质量的估计，用来决定是否需要继续探索某个分支。对于最小化问题，限界函数给出的是下界；对于最大化问题，限界函数给出的是上界。
> - **最优性剪枝**：当一个节点的限界值大于等于当前已知最优解时，该节点及其子节点就可以被剪掉。
> - **可行性剪枝**：当一个节点不满足问题的约束条件时，也可以进行剪枝。
> - **优先队列/堆**：用来存储待处理的活节点，并根据某种标准（通常是限界值）对这些节点进行排序，以确保总是优先处理最有可能改进当前最优解的节点。

> ### 两种分支限界法：
>
>  1.队列式(FIFO)分支限界法：按照队列先进先出（ FIFO） 原则选取下一个节点为扩展节点。 
>
>  2.优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。

> ### 队列式分枝限界法组织结点表: 
>
> 1.将根结点加入活结点队列。 
>
> 2.从活结点队中取出队头结点，作为当前扩展结点。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，用约束条件检查，把所有满足约束条件的孩子 结点加入活结点队列。 
>
> 4.重复步骤2和3，直到找到一个解或活结点队列为空为止

> ### **优先队列式分枝限界法组织结点表**: 
>
> 1.计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。 
>
> 2.从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分枝推 进，以便尽快地找出一个最优解。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的 孩子结点计算优先级并加入优先队列。 
>
> 4.重复步骤2和3，直到找到一个解或优先队列为空为止

>### **回溯法与分支限界对比**: 
>
>相同：都需要搜索解空间求解 
>
>不同：1.回溯法按照深度优先搜索，分支限界按照广度优先 
>
>2.回溯法存储结点的数据结构是栈，而分支限界是队列、优先队列 
>
>3.回溯法结点多次成为活结点，分支限界每个结点只有一次成为活结点的机会

# 代码篇

## 阶乘

``` c
int fun(int n) {
    if (n == 0)
        return 1;
    return n * fun(n - 1);
}

int fun2(int n) {//非递归
    int sum = 1;

    if (n == 0) {
        return 1;
    } else {
        for (int i = 2; i <= n; ++i) {
            sum *= i;
        }
    }
    return sum;
}

```

## Fibonacci

``` c
    if (n == 1 or n == 2) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
```



## 二分查找

``` c
int BinarySearch(int arr[], int n, int x) {//记住 数组是有序的
     int left=0;
     int right=n-1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (x == arr[mid])
            return mid;
        if (x < arr[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;//**没找到
}
```

## 快排 (QuickSort)

> #### 思想
>
> 快速排序是一种分治算法，其基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分继续进行排序，以达到整个序列有序的目的。
>
> #### 步骤
>
> 1. **选择枢轴（Pivot）**：从数组中选择一个元素作为枢轴。
> 2. 分区（Partition）
>    - 将所有小于枢轴的元素移到枢轴的左边。
>    - 将所有大于枢轴的元素移到枢轴的右边。
> 3. 递归排序
>    - 对枢轴左边的子数组进行快速排序。
>    - 对枢轴右边的子数组进行快速排序。

``` c

int partition(int arr[], int low, int high) {
    //挖空法
    int pivot = arr[low];//选取第一个元素作为枢轴
    while (low < high) {
        while (low < high and arr[high] >= pivot)
            high--;
        arr[low] = arr[high];
        while (low < high and arr[low] <= pivot)
            low++;
        arr[high] = arr[low];
    }
    arr[low]=pivot;//基准元素最后的位置
    return low;//返回中间位置
}

void quickSort(int arr[],int low,int high){
    if (low<high){
        int pivot=partition(arr,low,high);
        quickSort(arr,low,pivot-1);
        quickSort(arr,pivot+1,high);
    }
}
```

## 归排

>#### 思想
>
>归并排序也是一种分治算法，其基本思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成一个有序数组。
>
>#### 步骤
>
>1. **分解**：将数组分成两个子数组。
>2. **递归排序**
>
>​    对左子数组进行归并排序。
>
>  - 对右子数组进行归并排序。
>
>3. **合并**：将两个有序的子数组合并成一个有序数组。

``` c
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k=0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}
void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left,right);
}
```

## 棋盘覆盖

> ### 算法思想
>
> 1. **分治法**：
>    - 将棋盘分成四个 2n−1×2n−12*n*−1×2*n*−1 的子棋盘。
>    - 特殊方格必然位于这四个子棋盘中的一个。
>    - 对于不含特殊方格的子棋盘，选择一个“伪”特殊方格，使得每个子棋盘都有一个特殊方格。//自己添加 tile
> 2. **递归处理**：
>    - 递归地对每个子棋盘进行同样的操作，直到子棋盘大小为 1x1。
>    - 当子棋盘大小为 1x1 时，直接返回，因为 1x1 的棋盘无法再分割。
> 3. **放置 L 形瓦片**：
>    - 在每个子棋盘中，选择一个位置放置 L 形瓦片，以覆盖除了特殊方格之外的其他三个方格。
>    - 通过递归调用，确保每个子棋盘都被正确覆盖。
>
> ### 详细步骤
>
> 1. **初始化**：
>
>    - 定义一个全局变量 `tile` 用于标记不同的 L 形瓦片。
>    - 定义一个二维数组 `board` 用于存储棋盘的状态。
>
> 2. **递归函数 `ChessBoard`**：
>
>    - `tr` 和 `tc`：当前子棋盘的左上角行和列。
>    - `dr` 和 `dc`：特殊方格的行和列。
>    - `size`：当前子棋盘的大小。
>
>    - 递归终止条件：如果 `size` 为 1，则直接返回。
>    - 计算子棋盘的边长的一半 `s = size / 2`。
>    - 根据特殊方格的位置，递归处理四个子棋盘，并在需要的地方放置 L 形瓦片。

```  c
//https://www.bilibili.com/video/BV1QV411m7ff/?spm_id_from=333.337.search-card.all.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int tile = 1;
int board[100][100] = {0};

void ChessBoard(int tr, int tc, int dr, int dc, int size) {
    // 左上角的行 列， 特殊方块的行 列，棋盘的大小
    if (size == 1) {//1*1 的棋盘无法再分割
        return;
    }
    //2*n 2*3 6*6
    int t = tile++;//标号用的
    int s = size / 2;//取边长一般
    //覆盖左上角  1 1
    //          1 0
    if (dr < tr + s and dc < tc + s) {   //若特殊方格在棋盘中 左下角的右下角
        ChessBoard(tr, tc, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s - 1] = t;//填上数 方便看
        ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s);//不能填的位置 左上角的右下角-1
    }

    //覆盖右上角  1 1
    //          0 1
    if (dr < tr + s and dc >= tc + s) {   //若特殊方格在棋盘右上角中
        // < 和 >=都可以 要么加上 -1或+1边界问题而已
        ChessBoard(tr, tc + s, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s] = t;//特殊的-1
        ChessBoard(tr, tc + s, tr + s - 1, tc + s, s);//右上角的左下角
    }

    //再左下角    1 0
    //          1 1
    if (dr >= tr + s and dc < tc + s) {   //若特殊方格在棋盘中
        ChessBoard(tr + s, tc, dr, dc, s);
    } else {
        board[tr + s][tc + s - 1] = t;
        ChessBoard(tr + s, tc, tr + s, tc + s - 1, s);
    }
    //覆盖右下角
    if (dr >= tr + s and dc >= tc + s) {   //若特殊方格在棋盘中
        ChessBoard(tr + s, tc + s, dr, dc, s);
    } else {
        board[tr + s][tc + s] = t;
        ChessBoard(tr + s, tc + s, tr + s, tc + s, s);
    }
}

int main() {
    int size = 8;
    ChessBoard(0, 0, 1, 1, size);
    for (int i = 0; i < size; ++i) {
        for (int j = 0; j < size; ++j) {
            cout << board[i][j] << "  ";
        }
        cout << endl;
    }
}
```

## 循环日程表

> **符合分治策略的思想**，将所有的选手分为两半，n个选手的比赛日程就可以通过分成n/2个选手设计的比赛日程表来决定。采用递归的方式对选手进行割分，直至割分到只剩下1位选手时，比赛日程表就不在需要为其排列。
>
> **边界条件：**n = 1
>
> **分解子问题：**
>
> 1.递归左上角赛程表
>
> 2.递归左下角赛程表
>
> 3.将左上角赛程表copy到右下角
>
> 4.将左下角赛程表copy到右上角

``` c
//循环日程表
void table(int arr[maxNum][maxNum], int y, int len) {
    if (len == 1) {
        arr[0][y] = y + 1;//第0行
        return;
    }
    table(arr, y, len / 2);//左上
    table(arr, y + len / 2, len / 2);//右上
//    上面分治会把 其余的值 赋好 下面等着复制就行
    for (int i = 0; i < len / 2; ++i) {
        for (int j = 0; j < len / 2; ++j) {
            arr[len / 2 + i][y + len / 2 + j] = arr[i][y + j];//左上到右下
            arr[len / 2 + i][y + j] = arr[i][y + len / 2 + j];//右上 复制到左下
        }
    }
}
```

## 逆序对数

> **逆序对**是指在一个数组中，如果存在一对元素 (i, j)，其中 i < j 但 arr[i] > arr[j]，则称这对元素为一个逆序对。在归并排序的过程中，我们可以在合并两个有序子数组时高效地计算出逆序对的数量。
>
> 1. **分割**：将数组分成两个大致相等的部分。
> 2. **递归求解**：递归地在每个部分中计算逆序对的数量。
> 3. **合并**：在合并两个有序子数组的过程中，统计跨过中间点的逆序对数量。
> 4. **累加结果**：将各个部分的逆序对数量累加起来，得到整个数组的逆序对总数

``` c
using namespace std;
int sum = 0;
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            sum += mid - i + 1;// 左边比右边大 出现 逆序对求逆序对-------------------------------
        temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k = 0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}

void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left, right);
}
```

## 矩阵连乘

> 找到一个计算多个矩阵连乘的最优顺序，使得总的乘法次数最少。使用二维数组 `m` 来存储子问题的解，并使用另一个二维数组 `s` 来记录最优分割点，以便最后可以构造出最优解。
>
> ### 动态规划的思想
>
> 1. **定义子问题**：令 `m[i][j]` 表示从第 `i` 个矩阵到第 `j` 个矩阵的最小乘法次数。
> 2. **状态转移方程**：
>    - 如果 `i == j`，那么只有一个矩阵，不需要做任何乘法，所以 `m[i][i] = 0`。
>    - 如果 `i < j`，则考虑所有可能的分割点 `k`（`i <= k < j`），将矩阵链分成两部分 `A[i...k]` 和 `A[k+1...j]`，并计算这两部分的乘法次数加上合并这两部分的乘法次数。选择使总乘法次数最小的 `k` 作为最优分割点。
>    - 具体的状态转移方程为： m[i][j]=min⁡i≤k][k]+m[k+1][j]+pi−1×pk×pj)*m*[*i*][*j*]=min*i*≤*k*<*j*(*m*[*i*][*k*]+*m*[*k*+1][*j*]+*p**i*−1×*p**k*×*p**j*) 其中 `p` 是一个数组，表示每个矩阵的维度。`p_{i-1}` 是第 `i` 个矩阵的行数，`p_k` 是第 `k` 个矩阵的列数，也是第 `k+1` 个矩阵的行数，`p_j` 是第 `j` 个矩阵的列数。
> 3. **边界条件**：当 `i == j` 时，`m[i][j] = 0`，因为单个矩阵不需要进行乘法操作。
> 4. **确定子链长度**：从最短的子链（长度为2）开始，逐渐增加子链的长度，直到覆盖整个矩阵链。
> 5. **确定起点和终点**：对于每个子链长度，枚举所有可能的起点 `i` 和对应的终点 `j`。
> 6. **选择分割点**：在每个子链中，尝试所有可能的分割点 `k`，将子链分成两部分 `A[i...k]` 和 `A[k+1...j]`，并计算这两部分的乘法次数加上合并这两部分的乘法次数。
> 7. **更新最优解**：在所有可能的分割点 `k` 中，选择使得总乘法次数最小的那个 `k`，并将这个最小值记录到 `dp[i][j]` 中。
>
> 1. **matrixMultiply 函数**：
>    - 对于单个矩阵的情况，`dp[i][i] = 0`，因为单个矩阵不需要做任何乘法。
>    - 使用两层循环来处理不同长度的子链：
>      - 外层循环 `len` 表示当前考虑的子链长度。
>      - 内层循环 `i` 表示子链的起始位置。
>    - 计算 `j` 作为子链的结束位置。
>    - 初始化 `dp[i][j]` 为 `INT_MAX`，以便在后续比较中找到最小值。
>    - 使用内层循环 `k` 来尝试不同的分割点，并计算分割后的总乘法次数 `temp`。
>    - 更新 `dp[i][j]` 为 `temp` 的最小值。

``` c
int dp[10][10];
int n = 6;
int p[7] = {30, 35, 15, 5, 10, 20, 25};

void matrixMultiply() {
    for (int i = 1; i <= n; ++i)
        dp[i][i] = 0;//单个矩阵不需要乘法
    for (int len = 2; len <= n; ++len) {//len表示 要求连乘矩阵的长度
        for (int i = 1; i <= n - len + 1; ++i) {//i 为开始位置
            int j = i + len - 1;//j 结束位置
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {//p[i - 1] 是第 i 个矩阵的行数。
                dp[i][j] = min(dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j], dp[i][j]);//维护最小值 注意是加号
            }// p[k] 是第 k 个矩阵的列数（也是第 k+1 个矩阵的行数）。
        }//p[j] 是第 j 个矩阵的列数。
    }
}
```

## 最长公共子序列

> 1. **定义状态**：
>    - `dp[i][j]` 表示 `X` 的前 `i` 个字符和 `Y` 的前 `j` 个字符的最长公共子序列的长度。
> 2. **状态转移方程**：
>    - 如果 `X[i-1] == Y[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
>    - 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
> 3. **边界条件**：
>    - `dp[0][j] = 0`，`dp[i][0] = 0`。

``` c
char x[] = {'0', 'i', 'f', 'g', 'h', 'k', 'u'};
char y[] = {'0', 'e', 'h', 't', 'u'};//下标从1开始算 第一个不算入n
int sum = 0;
int n = 6, m = 4;
int dp[105][105];//dp i j a b
int LCS() {
    for (int i = 1; i <= n; ++i)   //设置边界
        dp[i][0] = 0;
    for (int i = 1; i <= m; ++i)
        dp[0][i] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (x[i] == y[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
}
```

## 最大字段和

> 1. **状态转移方程**：
>
>    - 对于每个 `i`，`dp[i]` 表示以 `arr[i]` 结尾的最大子段和。
>
>    - dp[i]
>
>      可以通过以下两种情况取最大值：
>
>      - 当前元素 `arr[i]` 自己作为一个新的子段。
>      - 当前元素 `arr[i]` 加上前一个子段的和 `dp[i-1]`。
>
> - `dp[i] = max(dp[i-1] + arr[i], arr[i])`。
> - `sum = max(sum, dp[i])`。

``` c
int sum = 0;
int arr[]={0,1,3,-2,4,-3,1};
int n=6;
int dp[25]={0};//dp i j a b
int MaxSub() {
    for (int i = 1; i <= n; ++i)
        dp[i]=arr[i];
    sum=dp[1];
    for (int i = 2; i <= n; ++i){
        dp[i]=max(dp[i-1],dp[i-1]+arr[i]);
        sum=max(dp[i],sum);
    }
}
```

## 01背包

> ### 动态规划思想
>
> 1. **定义状态**：
>    - `dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。
> 2. **状态转移方程**：
>    - 如果不选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j]`。
>    - 如果选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j-weights[i]] + values[i]`，前提是 `j >= weights[i]`。
>    - 综合起来，`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i]] + values[i])`。
> 3. **边界条件**：
>    - `dp[0][j] = 0` 对于所有 `j`，因为没有物品时，价值为 0。
>    - `dp[i][0] = 0` 对于所有 `i`，因为背包容量为 0 时，无法装入任何物品。
> 4. **最终结果**：
>    - `dp[n][capacity]` 即为所求的最大价值。

``` c
int w[] = {0, 2, 3, 4, 5};
int v[] = {0, 3, 4, 5, 6};//下标从1开始
int n = 4;//个数
int c = 5;//容量
int dp[11][11] = {0}; //`dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。

int knapsack() {
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= c; ++j) {
            if (w[i] <= j) {//可以放下
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);//放和不放 取价值最大
            } else {//放不下
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
}
```

## 路径问题

> ### 动态规划思想
>
> 1. **定义状态**：
>    - 用 `dp[i][j]` 表示从起点 (0, 0) 到达位置 (i, j) 的路径数。
> 2. **状态转移方程**：
>    - 如果当前位置 (i, j) 可以从上方 (i-1, j) 和左侧 (i, j-1) 到达，则 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
>    - 特殊情况：如果在第一行（i=0），则只能从左侧到达；如果在第一列（j=0），则只能从上方到达。
> 3. **边界条件**：
>    - 起点 (0, 0) 只有一种方式到达，即 `dp[0][0] = 1`。
>    - 第一行和第一列的每个位置都只有一种方式到达，即 `dp[0][j] = 1` 和 `dp[i][0] = 1`。
> 4. **最终结果**：
>    - `dp[N-1][M-1]` 即为从起点到终点的路径总数。

``` c
int n = 3;
int m = 3;
int dp[20][20];
int countPaths() {
    for (int i = 0; i < n; ++i){
        for (int j = 0; j <m ; ++j) {
            if (i==0 or j==0)//边界条件
                 dp[i][j]=1;
            else
                dp[i][j]= dp[i][j-1]+dp[i-1][j];//上来 + 左来
        }
    }
}
```

## 完全背包

> 1. **定义状态**：
>
>    - `dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。
>
> 2. **状态转移方程**：
>
>    - 如果不选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j]`。
>    - 如果选择第 `i` 个物品，并且 `j >= weights[i]`，则可以选择一次或多次，此时的价值为 `dp[i][j - weights[i]] + values[i]`。
>    - 因此，`dp[i][j] = max(dp[i-1][j], dp[i][j - weights[i]] + values[i])`。
>
> 3. **边界条件**：
>
>    - `dp[0][j] = 0` 对于所有 `j`，因为没有物品时，价值为 0。
>    - `dp[i][0] = 0` 对于所有 `i`，因为背包容量为 0 时，无法装入任何物品。
>
> 4. **最终结果**：
>
>    - `dp[n][capacity]` 即为所求的最大价值。
>
>    ### 为什么使用 `dp[i][j - weights[i-1]]` 而不是 `dp[i-1][j - weights[i-1]]`？
>
>    - 在 0/1 背包问题中，每个物品只能选择一次，因此使用 `dp[i-1][j - weights[i-1]]` 来表示不包含当前物品 `i` 的情况。
>    - 在完全背包问题中，每个物品可以选择多次，因此使用 `dp[i][j - weights[i-1]]` 来表示包含当前物品 `i` 的情况，这样可以继续在剩余容量中选择当前物品。

``` c
int n=3;
int w[] = {0,1, 3, 4};
int v[] = {0,15, 20, 30};
int c=6;
int dp[10][10];
int knapsack() {
    memset(dp,0,sizeof(dp));//初始化为0
    for (int i = 1; i <= n; ++i){
        for (int j = 1; j <=c ; ++j) {
            if (w[i]<=j)//放得下 放i 或者不放i
                 dp[i][j]= max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]);//可重复选 i=i 不能重复选i=i-1
            else
                dp[i][j]=dp[i-1][j];
        }
    }
}//60
```

## 合并石子

> 1. **定义状态**：
>    - `dp[i][j]` 表示将第 `i` 堆到第 `j` 堆石子合并成一堆的最小代价。
> 2. **状态转移方程**：
>    - 对于每一个区间 `[i, j]`，我们可以选择一个位置 `k`（`i <= k < j`），将 `[i, k]` 和 `[k+1, j]` 两部分先分别合并，然后再将这两部分合并。
>    - 因此，`dp[i][j] = min(dp[i][k] + dp[k+1][j] + pre[i][j])`，其中 `pre[i][j]` 表示从第 `i` 堆到第 `j` 堆石子的总数量。//左边 + 右边 加咱俩的代价
> 3. **边界条件**：
>    - `dp[i][i] = 0`，因为单个石子堆不需要合并。
>    - `pre[i][i] = stones[i]`，表示单个石子堆的数量。
> 4. **最终结果**：
>    - 不跨越环的情况可以通过直接计算 `dp[0][n-1]` 得到。
>    - 和矩阵连乘几乎一样
>    - - `i + len - 1 <= n` 确保区间的终点 `j` 不会超过数组的范围。
>      - `j = i + len - 1` 是区间的终点。
>      - 因此，`i + len - 1 <= n` 等价于 `i <= n - len + 1`。
>    - **改写后的写法**：
>      - `i <= n - len + 1` 直接确保了 `i` 的最大值不会超过 `n - len + 1`。
>      - 这样可以保证 `j = i + len - 1` 仍然在有效范围内。

``` c
int arr[] = {0, 3, 4, 3};//下标从1开始
int n = 3;
int pre[10];//前缀和数组
int dp[10][10];
//https://www.bilibili.com/video/BV1PG411H7sj/?spm_id_from=333.880.my_history.page.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int minCostToMergeStones() {
    for (int i = 1; i <= n; ++i)
        pre[i] = pre[i - 1] + arr[i];
    memset(dp, 0, sizeof(dp));//初始化0  单独1堆合并代价为
    for (int len = 2; len <= n; ++len) {//和矩阵连乘很像  最少两堆连乘
        for (int i = 1; i <= n-len+1; ++i) {//i 开始堆下标
            int j = i+len-1;//结束堆 下标
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + pre[j] - pre[i-1]);
            }
        }
    }
}

```

<img src="C:\Users\nvjiachengba\Desktop\851\file\复习文档.assets\image-20240930200525198.png" alt="image-20240930200525198" style="zoom: 50%;" />



## 最长递增子序列

> 1. **定义状态**：
>    - `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
> 2. **状态转移方程**：
>    - 对于每一个 `i`，我们需要检查所有 `j < i` 的位置，如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`。
>    - 如果没有这样的 `j`，则 `dp[i] = 1`，因为单个元素本身也是一个递增子序列。
> 3. **边界条件**：
>    - `dp[0] = 1`，因为单个元素本身就是一个递增子序列。
> 4. **最终结果**：
>    - `max(dp[0], dp[1], ..., dp[n-1])` 即为所求的最长递增子序列的长度。

``` c
int nums[] = {10, 9, 2, 5, 3, 7, 101, 18};
int n = 8;
int dp[20];
int maxLen=INT_MIN;

int lengthOfLIS(int *nums, int n) {
    if (n == 0) return 0;
    for (int i = 0; i < n; ++i)
        dp[i]=1;//初始化 最少包含自己 为1

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
            //满足升序
            dp[i]=max(dp[i],dp[j]+1);
            maxLen= max(maxLen,dp[i]);
            }
        }
    }
}
```

## 活动安排

> ### 问题描述
>
> 假设你有一组活动，每个活动都有一个开始时间和结束时间。这些活动需要使用同一资源（比如同一个会议室），并且在同一时间只能有一个活动使用该资源。你的任务是选出尽可能多的活动来安排，使得被选中的活动之间不会发生时间上的冲突。
>
> ### 解决思路
>
> 采用贪心策略。基本思想如下：
>
> 1. **排序**：首先按照活动的结束时间对所有活动进行升序排序。如果两个活动有相同的结束时间，则可以按开始时间排序。
> 2. **选择活动**：从最早结束的活动开始考虑，选择第一个活动加入集合。然后，对于剩下的活动，总是选择与当前已选活动集合中最后一个活动不冲突的第一个活动加入集合。
> 3. **重复步骤2**：持续执行步骤2直到遍历完所有的活动。
>
> 这种方法确保了在每一步都做出局部最优的选择，从而最终得到全局最优解。

``` c
typedef struct {
    int id;//活动的编号
    int start;//开始时间
    int finish;//结束时间
    int flag;//活动是否被选择
} Activity;
int sum=0;
//下标从1开始
Activity arr[] = {{0, 0, 0},
                         {1, 5, 9},
                         {2, 1, 2},
                         {3, 3, 4},
                         {4, 0, 6},
                         {5, 5, 7},
                         {6, 8, 9}};
int n = 6;
bool cmp(Activity a, Activity b) {
    return a.finish < b.finish; //结束时间早的排在前面
}

void fun() {
    sort(arr+1,arr+n, cmp);// 结束时间从小到大排序 cmp不需要括号
    int pre=1;//以第一个活动结束为开始
    arr[1].flag=1;
    sum++;
    for (int i = 2; i <= n; ++i){
        if (arr[pre].finish<=arr[i].start){//后一个活动开始时间 = 也可以晚于前一个结束时间 不冲突
            sum++;
            pre=i;
            arr[i].flag=1;
        }
    }
}
```

## 部分背包

>   其中每个物品可以被分割成任意小的部分。目标是在不超过背包容量的前提下，使得装入背包的物品总价值最大。这个问题可以通过贪心算法高效解决。
>
> ### 问题描述
>
> - **输入**：一组物品，每个物品有一个重量 `w` 和一个价值 `v`；一个背包，其最大承重为 `W`。
> - **输出**：选择哪些物品以及每种物品的数量，使得装入背包的物品总价值最大，且总重量不超过 `W`。
>
> ### 解决思路
>
> 1. **计算单位重量的价值**：对于每个物品，计算它的单位重量的价值，即 `value/weight`。
> 2. **排序**：根据单位重量的价值对所有物品进行降序排序。
> 3. **选择物品**：从单位重量价值最高的物品开始，尽可能多地选取该物品，直到不能完全放入下一个物品为止。然后继续选择下一个单位重量价值次高的物品，重复此过程，直到背包满或所有物品都已考虑。

``` c
typedef struct {
    int id;//可以不用这题
    int v;
    int w;
} goods;
goods arr[] = {{0, 0,   0,},
               {1, 60,  10},
               {2, 100, 20},
               {3, 120, 30}};
int c = 50;
int n = 3;
int sum = 0;

bool cmp(goods a, goods b) {//根据价值的平均价值 从高到低进行排序
    return a.v / a.w > b.v / b.w;
}

void fractionalKnapsack() {
    for (int i = 1; i <= n; ++i) {
        if (c >= arr[i].w) {//可全部放下
            sum += arr[i].v;
            c -= arr[i].w;
        } else {//部分可放下
            sum += c * (arr[i].v / arr[i].w);
            return;
        }
    }
}
```

## 简单装载

> 最优装载问题（也称为简单装载问题）是背包问题的一种特殊情况，其中每个物品的重量不同，但价值相同。目标是在不超过给定重量限制的情况下，装入尽可能多的物品。这个问题可以通过贪心算法高效解决。
>
> ### 问题描述
>
> - **输入**：一组物品，每个物品有一个重量 `w`；一个船或容器的最大承重为 `W`。
> - **输出**：选择哪些物品，使得装入的物品数量最多，且总重量不超过 `W`。
>
> ### 解决思路
>
> 1. **排序**：按照物品的重量从小到大进行排序。
> 2. **选择物品**：从最轻的物品开始，依次选择物品放入船或容器中，直到不能再装入更多物品为止。

``` c
typedef struct {
    int id;
    int w;//重量
    int flag;//是否选取
} container;
container arr[] = {{0, 0},
                   {1, 5},
                   {2, 3},
                   {3, 4},
                   {4, 2}};
int n = 4;
int c = 10;//容量
int sum = 0;
bool cmp(container a, container b) {//重量从小到大 排序
    return a.w < b.w;
}

void optimalLoading() {
    sort(arr + 1, arr + n, cmp);
    for (int i = 1; i <= n; ++i) {
        if (c >= arr[i].w) {
            arr[i].flag = 1;
            c -= arr[i].w;
            sum++;
        }
    }
}

```

## Dijkstra

> ### Dijkstra算法思想
>
> 1. **初始化**：
>    - 为每个顶点设置一个距离值（`dist`），表示从源顶点到该顶点的最短路径长度。初始时，源顶点的距离设为0，其他所有顶点的距离设为无穷大（表示尚未找到路径）。
>    - 创建一个集合`S`，用于存储已经确定最短路径的顶点。初始时，`S`为空。
> 2. **选择当前距离最小的顶点**：
>    - 从未处理的顶点中选择一个距离最小的顶点`u`，将其加入集合`S`中。这意味着我们已经找到了从源顶点到`u`的最短路径。
> 3. **更新邻接顶点的距离**：
>    - 对于顶点`u`的所有邻接顶点`v`，如果通过`u`到达`v`的路径比当前已知的从源顶点到`v`的路径更短，则更新`v`的距离值。
> 4. **重复步骤2和3**：
>    - 重复上述过程，直到所有顶点都被加入集合`S`中，或者没有更多的顶点可以更新为止。
>
> - **初始化**：设置初始距离和路径。
> - **选择最小距离顶点**：从未处理的顶点中选择距离最小的顶点。
> - **更新距离**：更新通过该顶点到达其他顶点的距离。
> - **重复**：重复上述过程直到所有顶点都被处理

``` c
typedef struct {
    int edges[25][25];
    int vexNum;
    int arcNum;
} MGraph;

int visited[25] = {0};//是否访问
int path[25];   // 原点v到顶点i的前一个顶点
int dist[25];          // 源点到各个顶点的距离

void Dijkstra(MGraph *g, int v) {
    for (int i = 0; i < g->vexNum; ++i) {//初始化判断是否有边
        dist[i] = g->edges[v][i];
        if (g->edges[v][i] < INT_MAX) {
            path[i] = v;//前一个顶点
        } else {
            path[i] = -1;
        }
    }
    visited[v] = 1;//标记源顶点已访问
    dist[v] = 0;
    path[v] = -1;

    for (int i = 1; i < g->vexNum; ++i) {//选择未处理顶点中距离最小的顶点
        int minn = INT_MAX;//最小值
        int minVex;//最小值下标
        for (int j = 0; j < g->vexNum; ++j) {
            if (dist[j] < minn and visited[j] == 0) {
                minn = dist[j];
                minVex = j;//找到最小值
            }
        }
        visited[minVex] = 1;

        for (int j = 0; j < g->vexNum; ++j) {//更新邻接顶点的距离：
            if (visited[j] == 0 and dist[j] > dist[minVex] + g->edges[minVex][j]) {   //以为 minVex 为中介 更近
                dist[j] = dist[minVex] + g->edges[minVex][j];
                path[j] = minVex;
            }
        }
    }
}
```

## prime

> Prim 算法是一种用于找到加权无向图的最小生成树（Minimum Spanning Tree, MST）的贪心算法。其主要思想是从一个起始顶点开始，逐步扩展生成树，直到包含图中的所有顶点。每一步都选择当前未加入生成树的顶点中与生成树相连的边权重最小的那个顶点，并将其加入生成树。
>
> ### 代码的思想
>
> 1. **初始化**：
>    - `sum` 用于存储最小生成树的总权重。
>    - `visited` 数组用于标记顶点是否已经被加入到MST中。
>    - `lowcost` 数组用于存储从已加入MST的顶点到未加入MST的顶点的最小边权重。
> 2. **选择起点**：
>    - 将起始顶点 `v` 标记为已访问。
>    - 初始化 `lowcost` 数组，将起始顶点到其他顶点的距离赋值给 `lowcost` 数组，如果不存在直接连接的边，则设置为无穷大（`INT_MAX`）。
> 3. **迭代过程**：
>    - 执行 `g->vexNum - 1` 次循环，每次选择一个顶点加入MST。
>    - 在每次循环中，找到 `lowcost` 数组中最小的值 `minn` 及其对应的顶点 `k`。
>    - 将 `minn` 加入 `sum`，并将顶点 `k` 标记为已访问。
>    - 更新 `lowcost` 数组，检查新加入的顶点 `k` 到其他未访问顶点的边权重，如果这些边的权重小于 `lowcost` 中的值，则更新 `lowcost`。
> 4. **输出结果**：
>    - 最后输出最小生成树的总权重 `sum`。

``` c
typedef struct {
    int edges[25][25];
    int vexNum;
    int arcNum;
} MGraph;

void prime(MGraph *g, int v) {
    int sum = 0;
    int visited[25];
    int lowcost[25];
    for (int i = 1; i < g->vexNum; ++i) {
        lowcost[i] = g->edges[v][i];//候选边初始化
        visited[i] = 0;
    }

    visited[v] = 1;//起点
    int j, k;
    for (int i = 1; i < g->vexNum; ++i) {//执行n-1次
        int minn = INT_MAX;
        for (j = 1; j < g->vexNum; j++) {//寻找最小值
            if (lowcost[j] < minn and visited[j] == 0) {
                minn = lowcost[i];// 更新最小边权重
                k = j;//最小权值顶点
            }
        }
        sum += minn;
        visited[k] = 1;

        for (int j = 1; j <= g->vexNum; ++j) {//维护候选中的最小值
            if (visited[j] == 0 and g->edges[k][j] < lowcost[j])//未被访问，且最新的顶点到j的距离比原来近
                lowcost[j] = g->edges[k][j]; //更新
        }
    }
    printf("minn:%d", sum);
}
```

## Kruskal

> 1. **定义结构体**：
>    - `Edge` 结构体用于表示图中的边，包含两个顶点 `vex1` 和 `vex2` 以及边的权重 `weight`。
>    - `MGraph` 结构体用于表示图，包含顶点数 `vexNum`、边数 `EdgeNum` 和边表 `edges`。
> 2. **比较函数**：
>    - `cmp` 函数用于对边进行排序，按边的权重从小到大排序。
> 3. **并查集操作**：
>    - `Initial` 函数初始化并查集，使每个顶点的父节点指向自己。
>    - `getRoot` 函数查找顶点的根节点。
>    - `isSameRoot` 函数检查两个顶点是否属于同一个集合。
>    - `merge` 函数合并两个集合。
> 4. **Kruskal 算法**：
>    - `Kruskal` 函数实现了克鲁斯卡尔算法，计算最小生成树的总权重。
>    - 初始化并查集。
>    - 对边进行排序。
>    - 依次选择每条边，如果边的两个顶点不在同一个集合中，则加入 MST 并合并这两个顶点所在的集合。
>    - 当生成树中的边数达到 `vexNum - 1` 时，算法结束。
>    - 如果图不连通，返回 -1 并打印提示信息。

``` c
#define ElemType char
#define MAX_COST 0x7fffffff
const int MAX_SIZE = 23; // 最大容量

// 定义边的结构体
typedef struct Edge {
    int vex1, vex2; // 边所依附的两个顶点
    int weight;     // 权值
} Edge;

// 定义图的结构体
typedef struct {
    int vexNum;     // 顶点数
    int EdgeNum;    // 边数
    Edge edges[MAX_SIZE]; // 边表
} MGraph;

// 比较函数，用于 qsort 排序
bool cmp(const Edge &a, const Edge &b) {
    return a.weight < b.weight;
}

// 初始化并查集
void Initial(int roots[], int n) {
    for (int i = 0; i < n; ++i) {
        roots[i] = i; // 默认自己是自己的父节点
    }
}

// 查找父节点，即根节点
int getRoot(int roots[], int x) {
    while (roots[x] != x) 
        x = roots[x];
    return x;
}

// 检查两个顶点是否属于同一个集合
bool isSameRoot(int roots[], int x1, int x2) {
    return getRoot(roots, x1) == getRoot(roots, x2);
}

// 合并两个集合
void merge(int roots[], int x1, int x2) {
    int s1 = getRoot(roots, x1);
    int s2 = getRoot(roots, x2);
    if (s1 != s2) 
        roots[s1] = s2;
   
}

// Kruskal 算法
int Kruskal(MGraph *g) {
    int sum = 0; // 初始化总权重
    int edgeNum = g->EdgeNum;
    int vexNum = g->vexNum;
    int count = 0;
    int roots[g->vexNum]; // 并查集
    Initial(roots, vexNum); // 初始化并查集

    // 对边进行排序
    sort(g->edges, g->edges + edgeNum, cmp);

    for (int i = 0; i < edgeNum; ++i) {
        if (!isSameRoot(roots, g->edges[i].vex1, g->edges[i].vex2)) {// 如果两个顶点不在同一个集合中
            sum += g->edges[i].weight;
            printf("Edge %d-%d with weight %d is included in MST\n", g->edges[i].vex1, g->edges[i].vex2, g->edges[i].weight);
            merge(roots, g->edges[i].vex1, g->edges[i].vex2);
            count++; // 生成树的边数+1
            if (count == vexNum - 1)
                break; // 达到生成树完成构造
        }
    }

    if (count == vexNum - 1) {
        printf("Total weight of the Minimum Spanning Tree: %d\n", sum);
        return sum;
    } else {
        printf("The graph is not connected, cannot form a Minimum Spanning Tree.\n");
        return -1; // 图不连通
    }
}

```

## HuffmanTree

> 1. **定义结构体**：
>    - `HTNode` 结构体表示哈夫曼树的节点，包含四个字段：`weight`（权重）、`parent`（父节点索引）、`left`（左子节点索引）和 `right`（右子节点索引）。
>    - `HuffmanTree` 是一个类型别名，用于表示哈夫曼树的数组。
>    - `HuffManCode` 是一个类型别名，用于存储哈夫曼编码串的头指针数组。
> 2. **函数定义**：
>    - `Select`：选择两个最小的结点，这两个结点的 `parent` 为 0（即它们还没有被合并）。
>    - `CreateHuffmanTree`：初始化哈夫曼树的节点，并通过不断选择两个最小的结点来构建哈夫曼树。
> 3. 初始化哈夫曼树的节点，设置初始权重、父节点、左子节点和右子节点。
> 4. 计算非叶子节点的数量 `m`。
> 5. 初始化非叶子节点。
> 6. 通过不断选择两个最小的结点并合并它们来构建哈夫曼树。
> 7. 每次合并时，创建一个新的内部节点，其权重为两个最小结点的权重之和，并更新相关节点的 `parent`、`left` 和 `right` 字段。

``` c
const int N = 20;//叶子结点的最大值
#define M 2*N-1 //所有结点数量的最大值
using namespace std;
typedef struct {
    int weight;
    int parent;
    int left;
    int right;
} HTNode, HuffmanTree[M + 1];//0号不用

void Select(HuffmanTree ht, int n, int &s1, int &s2) {
    //选择最小的结点 parent=0 赋值给s1 s2
    int i, min1 = INT_MAX, min2 = INT_MAX;
    s1 = 0;
    s2 = 0;
    for (int i = 1; i <= n; ++i) {
        if (ht[i].parent == 0) {
            //是根结点 就是下面包含叶子
            if (ht[i].weight < min1) {
           
                min2 = min1; //比min1小
                s2 = s1;
                min1 = ht[i].weight;
                s1 = i;//min1 最小  min2 次小
            } else if (ht[i].weight < min2) {
                min2 = ht[i].weight;
                s2 = i;//比min2 小
            }
        }
    }
}

void CreateHuffmanTree(HuffmanTree ht, int w[], int n) {
    //w  要构造的那些结点 比如 13  57 23 4
    int i;
    for (int i = 1; i <= n; ++i) {
        ht[i].weight = w[i - 1];//丢到1-n
        ht[i].parent = 0;
        ht[i].left = 0;
        ht[i].right = 0;
    }
    int m = 2 * n - 1;// 实际 所有结点
    for (i = n + 1; i <= m; ++i) {//n+1 -m 存放非叶子结点 初始化
        ht[i].weight = 0;//丢到1-n
        ht[i].parent = 0;
        ht[i].left = 0;
        ht[i].right = 0;
    }
    //初始完毕 创建非叶节点
    int s1, s2;
    for (i = n + 1; i <= m; ++i) {
        Select(ht, i - 1, s1, s2);//每次选出2个最小的结点 切parent为0 也就是根结点不是叶结点
        ht[i].weight = ht[s1].weight + ht[s2].weight;
        ht[s1].parent = i;
        ht[s2].parent = i;
        ht[i].left = s1;//左边更小
        ht[i].right = s2;
    }
}

```

## 回溯

### 排列树&&子集树

> ### 1. 排列树（Permutation Tree）
>
> 排列树通过固定一个位置，然后递归地对剩余的位置进行全排列。每次递归调用时，交换当前元素与后续元素的位置，以生成不同的排列。
>
> ### 2. 子集树（Subset Tree）
>
> 子集树通过选择或不选择某个元素来生成所有可能的排列。这种方法通常使用一个布尔数组 `used` 来标记哪些元素已经被使用过。
>
> #### 排列树
>
> 1. **函数 `permute`**：
>    - 输入参数是数组 `arr`、起始位置 `start` 和结束位置 `end`。
>    - 如果 `start` 等于 `end`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
>    - 否则，通过一个循环遍历从 `start` 到 `end` 的每个位置，将 `start` 位置的元素与当前位置的元素交换，然后递归调用 `permute` 生成下一个位置的排列。
>    - 在递归调用返回后，再次交换回来以恢复原始数组状态，以便进行下一次交换。
>
> #### 子集树
>
> 1. **函数 `permuteSubsetTree`**：
>    - 输入参数是数组 `arr`、数组长度 `n`、当前结果数组 `result`、当前处理的位置 `pos` 和标记数组 `used`。
>    - 如果 `pos` 等于 `n`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
>    - 否则，通过一个循环遍历数组中的每个元素，如果该元素没有被使用过，则将其标记为已使用，加入到 `result` 中，然后递归调用 `permuteSubsetTree` 生成下一个位置的排列。
>    - 在递归调用返回后，将该元素从 `result` 中移除，并将其标记为未使用，以便进行下一次选择。
>
> ### 总结
>
> - **排列树**：通过交换数组中的元素来生成所有可能的排列。每次递归调用时，固定一个位置，然后递归地对剩余的位置进行全排列。
> - **子集树**：通过选择或不选择某个元素来生成所有可能的排列。这种方法通常使用一个布尔数组 `used` 来标记哪些元素已经被使用过。
>
> 这两种方法都能有效地生成数组的所有排列，选择哪种方法取决于具体的需求和偏好。排列树的方法在实现上较为直观，而子集树的方法则更符合回溯法的思路。

## 全排列

> **函数 `permute`**：
>
> - 输入参数是数组 `arr`、起始位置 `start` 和结束位置 `end`。
> - 如果 `start` 等于 `end`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
> - 否则，通过一个循环遍历从 `start` 到 `end` 的每个位置，将 `start` 位置的元素与当前位置的元素交换，然后递归调用 `permute` 生成下一个位置的排列。
> - 在递归调用返回后，再次交换回来以恢复原始数组状态，以便进行下一次交换。

``` c
//排序树
void dfs(int arr[], int n, int step) {//排列树
    if (step >= n)//一次排序结束
        print(arr, n);
    else {
        for (int i = step; i < n; ++i) {//从step 开始 0开始
            swap(arr[step], arr[i]);
            dfs(arr, n, step+1);
            swap(arr[step], arr[i]);
        }
    }
}
```

> **函数 `permuteSubsetTree`**：
>
> - 输入参数是数组 `arr`、数组长度 `n`、当前结果数组 `result`、当前处理的位置 `pos` 和标记数组 `used`。
> - 如果 `pos` 等于 `n`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
> - 否则，通过一个循环遍历数组中的每个元素，如果该元素没有被使用过，则将其标记为已使用，加入到 `result` 中，然后递归调用 `permuteSubsetTree` 生成下一个位置的排列。
> - 在递归调用返回后，将该元素从 `result` 中移除，并将其标记为未使用，以便进行下一次选择。

``` c
//子集树
void permuteSubsetTree(int arr[], int result[], int n, int vis[], int step) {//子集树
    if (step >=n) { // 递归终止条件
        print(result, n);
    } else {
        for (int i = 0; i < n; ++i) {
            if (vis[i] == 0) { // 如果当前元素未被使用
                result[step] = arr[i]; // 将当前元素放入结果数组
                vis[i] = 1; // 标记当前元素已被使用
                permuteSubsetTree(arr, result, n, vis, step + 1); // 递归调用
                vis[i] = 0; // 回溯，取消标记
            }
        }
    }
}
```



## 简单装载(回溯)

> 1. **全局变量**：
>    - `w` 数组存储了每个物品的重量，注意数组下标从1开始。
>    - `n` 表示物品的数量。
>    - `c` 表示背包的容量。
>    - `maxw` 用于记录当前找到的最大重量。
>    - `x` 数组用于记录最优解，即哪些物品被选中。
> 2. **函数 `dfs`**：
>    - 输入参数包括当前步骤 `step`、当前重量 `cw`、剩余重量 `rw` 和当前选择方案 `op`。
>    - 如果 `step > n`，表示已经处理完所有物品，到达了一个叶节点。
>      - 如果当前重量 `cw` 大于 `maxw`，则更新 `maxw` 并将当前选择方案 `op` 复制到 `x` 中。
>    - 否则，继续处理当前物品：
>      - 如果当前重量加上当前物品的重量不超过背包容量 `c`，则选择当前物品，并递归调用 `dfs` 处理下一个物品。
>      - 不选择当前物品，并递归调用 `dfs` 继续处理当前物品（回溯）。

``` c
//子集树
int w[] = {0, 5, 2, 6, 4, 3}; // 物品重量 下标从1开始
int n = 5; // 物品数量
int c = 10; // 背包容量
int maxw = 0; // 最大重量
int x[6]; // 记录最优解

void dfs(int step, int cw, int rw, int op[]) {
    if (step > n) {//找到一个叶节点
        if (cw > maxw) {
            maxw=cw;
            for (int i = 1; i <= n; ++i)
                x[i] = op[i];//复制更优解
        }
    } else {//继续找
        if (cw + w[step] <= c) {
            op[step] = 1;//选取第i个
            dfs(step + 1, cw + w[step], rw - w[step], op);
        }
        if (cw + rw - w[step] > maxw) {//当前重量+剩余重量还有可能超过 最大值
            op[step] = 0;//不选回溯 -w[step]  否则剪枝
            dfs(step+1, cw, rw - w[step], op);
        }
    }
}
```

## 复杂装载

> 目标是将集装箱分配到两个轮船上，使得第一个轮船的总重量最大化，并且第二个轮船能够装下剩余的所有集装箱。你使用了深度优先搜索（DFS）来找到第一个轮船的最优解，并通过 `solve` 函数检查第二个轮船是否能够装下剩余的集装箱。
>
> 1. **初始化**：
>    - 定义集装箱的重量数组 `w`。
>    - 定义两艘船的最大载重量 `c1` 和 `c2`。
>    - 初始化全局变量 `maxw` 用于记录第一艘船的最大载重量。
>    - 初始化数组 `x` 用于记录第一艘船的最优解向量。
> 2. **深度优先搜索（DFS）**：
>    - 递归函数 `dfs` 尝试所有可能的集装箱组合。
>    - 如果当前步骤 `step` 超过集装箱数量 `n`，则到达叶节点，更新最大载重量 `maxw` 并记录当前解。
>    - 否则，继续处理当前集装箱：
>      - 如果当前重量加上当前集装箱的重量不超过 `c1`，则选择当前集装箱，并递归调用 `dfs` 处理下一个集装箱。
>      - 如果当前重量加上剩余重量减去当前集装箱的重量仍然有可能超过 `maxw`，则不选择当前集装箱，并递归调用 `dfs` 继续处理当前集装箱（回溯）。
> 3. **检查剩余集装箱**：
>    - 函数 `solve` 计算第一艘船装完后剩余的集装箱总重量 `sum`。
>    - 检查 `sum` 是否小于等于 `c2`，即第二艘船能否装下剩余的集装箱。
>
> 1. **第一艘船尽可能多装**：
>    - 使用深度优先搜索（DFS）来尝试所有可能的集装箱组合，找到一种使得第一艘船装载重量最大的方案。
>    - 在递归过程中，通过选择或不选择当前集装箱来生成所有可能的解，并使用剪枝技术来减少不必要的递归调用。
> 2. **检查剩余集装箱是否能被第二艘船装下**：
>    - 一旦找到了第一艘船的最大载重量方案，计算剩余未被选中的集装箱总重量。
>    - 检查这些剩余集装箱的总重量是否不超过第二艘船的最大载重量 `c2`。
>    - 如果第二艘船能够装下所有剩余的集装箱，则找到了一个可行的解决方案；否则，没有可行的解决方案。

``` c
//子集树
#define MAXN 20 // 最多集装箱个数
int w[] = {0, 10, 40, 40}; // 各集装箱重量, 不用下标 0 的元素
int n = 3; // 集装箱数量
int c1 = 50, c2 = 50; // 两艘轮船的最大载重量
int maxw = 0; // 存放第一艘轮船最优解的总重量
int x[MAXN]; // 存放第一艘轮船最优解向量

//将所有集装箱都装上船 由于集装箱必需整体装入 所以不能贪心
void dfs(int step, int cw, int rw, int op[]) //求第一艘轮船的最优解
{
    if (step > n) {
        if (cw > maxw) {
            for (int i = 1; i <= n; ++i) {
                x[i] = op[i];
                maxw = cw;
            }
        }
    } else {//继续找更小重量
        if (cw + w[step] <=c1) {//没超重
            cw + w[step];
            op[step] = 1;
            dfs(step + 1, cw + w[step], rw - w[step], op);
        }
        if (cw + rw - w[step] > maxw) {//还有机会装更多 剪枝
            op[step] = 0;
            dfs(step + 1, cw, rw - w[step], op);
        }
    }
}

bool solve()//求解复杂装载问题
{   int sum = 0; //累计第一艘轮船装完后剩余的集装箱重量
    for (int j = 1; j <= n; j++)
        if (x[j] == 0)
            sum += w[j];
    if (sum <= c2)//第二艘轮船可以装完
        return true;
    else//第二艘轮船不能装完
        return false;
}
```

## 01背包(回溯)

> ### 算法思想
>
> 回溯的思想，尝试每一种可能的物品组合，然后根据约束条件（不超过背包容量）和目标（最大化价值）来筛选出最优解。
>
> - 函数逻辑：
>   - 如果 `step > n`，意味着所有物品都已经考虑过了。此时检查当前背包的总价值 `cv` 是否大于已知的最大价值 `maxv`。如果是，则更新 `maxv` 并将当前选择状态 `op[]` 复制到 `x[]` 中。
>   - 如果可以放入当前物品（`cw + w[step] <= c`），则选择该物品并递归调用 `dfs` 来处理下一个物品。
>   - 即使当前物品不被选中，如果后续物品的价值加上当前价值还有可能超过已知的最大价值（`cv + rv - v[step] > maxv`），那么也递归调用 `dfs` 来处理下一个物品而不选当前物品。
>
> - **优化剪枝**:
>   - 通过条件 `if (cv + rv - v[step] > maxv)` 来进行剪枝，避免不必要的递归调用。这个条件确保只有当后续有可能找到更好的解时才继续探索。
>
> 

``` c
int n = 4;  // 物品数量
int c = 10;  // 背包最大容量
int w[] = {0, 2, 3, 4, 5};//下标从1开始
int v[] = {0, 3, 4, 5, 6};
int maxv = 0; // 存放第一艘轮船最优解的总重量
int x[21]; // 存放第一艘轮船最优解向量

void dfs(int step, int cw, int cv, int rv, int op[]) {
    if (step > n) {
        if (cv > maxv) {
            for (int i = 1; i <= n; ++i) {
                x[i] = op[i];
                maxv = cv;
            }
        }
    } else {
        if (cw + w[step] <= c) {//放得下
            op[step] = 1;
            dfs(step+1, cw + w[step], cv + v[step], rv - v[step], op);
        }
        if (cv + rv - v[step] > maxv) {//还有机会更大
            op[step] = 0;
            dfs(step+1, cw, cv, rv - v[step], op);
        }
    }
}
```

## N皇后

### 

> #### 全局变量
>
> - `const int N = 8;`：定义了棋盘的大小，这里假设是8皇后问题。
> - `int q[N + 1];`：数组`q`用于存储每一行皇后的列位置。`q[i]`表示第`i`行的皇后位于第`q[i]`列。
>
> #### 函数 `place(int i, int j)`
>
> - **功能**：测试在位置 `(i, j)` 上是否可以放置皇后。
> - 参数：
>   - `i`：当前考虑的行号。
>   - `j`：当前考虑的列号。
> - 逻辑：
>   - 如果是第一行（`i == 1`），则总是可以放置皇后，因为此时没有其他皇后。
>   - 对于其他行，检查之前已经放置的所有皇后（从第1行到第i-1行）。
>     - 检查是否有任何已放置的皇后与当前位置 `(i, j)` 在同一列，即 `q[k] == j`。
>     - 检查是否有任何已放置的皇后与当前位置 `(i, j)` 在同一条对角线上，即 `abs(q[k] - j) == abs(i - k)`。
>   - 如果发现冲突，则返回 `false` 表示不能在此位置放置皇后。
>   - 如果没有发现冲突，循环结束后返回 `true` 表示可以在该位置放置皇后。
>
> #### 函数 `queen(int i, int n)`
>
> - **功能**：递归地尝试在第`i`行到第`n`行放置皇后。
> - 参数：
>   - `i`：当前考虑的行号。
>   - `n`：棋盘的大小（也是需要放置的皇后数量）。
> - 逻辑：
>   - 如果 `i > n`，说明已经成功放置了所有的皇后，调用 `dispasolution(n)` 来输出当前解决方案。
>   - 否则，对于第i行的每一个列j（从1到n），尝试放置皇后。
>     - 调用 `place(i, j)` 来检查是否可以在 `(i, j)` 位置放置皇后。
>     - 如果可以放置，则将 `q[i]` 设置为 `j`，表示在第`i`行的第`j`列放置皇后。
>     - 递归调用 `queen(i + 1, n)` 来尝试放置下一行的皇后。
>   - 如果在当前行的所有列都尝试过且无法放置皇后，则回溯到上一行重新选择。
>
> ### 算法思想
>
> 1. **递归与回溯**：
>    - 使用递归来尝试每一种可能的皇后放置方式。
>    - 当发现当前路径不可行时（即不能在某一行找到合适的位置放置皇后），通过回溯回到上一步，尝试另一种可能性。
> 2. **约束传播**：
>    - 在每次尝试放置皇后时，通过 `place` 函数检查当前放置是否会违反规则（同行、同列、对角线）。
>    - 只有当不违反规则时，才会继续递归下去。
> 3. **剪枝**：
>    - 通过提前检测冲突来减少不必要的递归调用。如果发现某个位置不能放置皇后，就不再继续尝试该位置。
> 4. **解决方案收集**：
>    - 当所有皇后都被成功放置后，调用 `dispasolution(n)` 来输出当前的解决方案。

``` c
const int N = 8; // 假设我们要解决的是8皇后问题
int q[N + 1]; // 用于存储每行皇后的列位置

// 测试(i, j)位置能否摆放皇后
bool place(int i, int j) {
    if (i == 1) return true; // 第一个皇后总是可以放置
    for (int k = 1; k < i; ++k) { // k=1～i-1 是已放置了皇后的行
        if ((q[k] == j) || (abs(q[k] - j) == abs(i - k))) {
            return false;
        }
    }
    return true;
}

// 放置 1～i 的皇后
void queen(int i, int n) {
    if (i > n) {
        dispasolution(n); // 所有皇后放置结束
    } else {
        for (int j = 1; j <= n; ++j) { // 在第 i 行上试探每一个列 j
            if (place(i, j)) { // 在第 i 行上找到一个合适位置(i, j)
                q[i] = j;
                queen(i + 1, n);
            }
        }
    }
}

```







## 

> 查找结点：e循环遍历链表，直到找到值为 x 的结点或到达链表末尾。
> 更新访问频度：如果找到了结点，则增加其 freq 域的值。
> 检查是否需要移动：如果结点已经是头结点（即 p->pred == L）或者它的频度小于等于前驱结点的频度，则不需要移动。
> 从当前链表中移除结点：更新前驱和后继结点的指针，以从链表中移除该结点。
> 找到插入位置：遍历链表，找到合适的位置，使得插入后的链表仍然按访问频度非增排序。
> 插入结点：将结点插入到找到的位置，并更新相关指针。

``` c


DNode *Locate(DLinkList L, int x) {// Locate 函数：查找值为 x 的结点并更新访问频度
    DNode *p = L->next;
    DNode *pre = L;

    // 查找结点
    while (p != NULL && p->data != x)
        p = p->next;

    if (p == NULL)
        return NULL; // 没有找到值为 x 的结点

    // 更新访问频度
    p->freq++;
    // 如果 p 是头结点或者已经是最高频度，不需要移动
    if (p->pre == L || (p->freq <= p->pre->freq))
        return p;

    // 从当前链表中移除结点
    p->pre->next = p->next;
    if (p->next != NULL)
        p->next->pre = p->pre;

    // 找到插入位置
    pre = L;
    while (pre->next != NULL && (pre->next->freq > p->freq || (pre->next->freq == p->freq && pre->next->next != NULL)))
        pre = pre->next;

    p->next = pre->next; // 插入结点
    p->pre = pre;
    if (pre->next != NULL)
        pre->next->pre = p;
    pre->next = p;
    return p;
}
```

## 线性表

## 插入结点 将元素插入到表的第i个位置上

> 

``` c
int insertElem(LinkList &list, int i, int e) {//将元素e 插入到第i个位置上
    if (i < 1)
        return 0;
    int cnt = 0;
    LNode *p = list;
    while (p != NULL and cnt < i - 1) {
        p = p->next;
        cnt++;//找到相应位置插入
    }

    if (p == NULL) //循环结束 判断插入位置是否合法
        return 0;
    //成功找到 进行插入操作
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return 1;
}
```

## 删除第一个值为key的元素

> 算法思想:1.若链表非空，遍历链表找寻结点
>
> ​        2.若找到结点不为空则进行删除，反之则退出

``` c
void deleteFirstByValue(LinkList &list, int x) {//将元素e 插入到第i个位置上
    if (list == NULL) {
        cout << "list is NULL" << endl;
        return;
    }
    LNode *p = list->next;
    LNode *pre = list;
    while (p != NULL and p->data != x) {//查找第一个值为x的结点
        pre = p;
        p = p->next;
    }
    if (p == NULL) {
        cout << "this is no element that you want to find" << endl;
        return;
    }
    //找到元素
    pre->next = p->next;
    free(p);//释放结点
}
```

## 单链表

### 建表(头插)

> - **创建头结点**：初始化一个头结点 `list`，并将 `next` 指针设置为 `NULL`。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的头部。
> - **更新指针**：确保新结点的 `next` 指针指向当前头结点的 `next`，然后更新头结点的 `next` 指针指向新结点。

``` c
// 使用头插法创建链表
void createByHead(LinkList &list, int arr[], int n) {
    list = new LNode; // 创建头结点
    list->next = NULL; // 头结点的 next 指向 NULL
    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        LNode *s = new LNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        s->next = list->next; // 新结点的 next 指向当前头结点的 next
        list->next = s; // 头结点的 next 指向新结点
    }
}
```

### 建表(尾插)

> - **创建头结点**：初始化一个头结点 `list`，并将 `next` 指针设置为 `NULL`。
>- **初始化尾指针**：初始时 `rear` 指向头结点。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的尾部。
> - **更新尾指针**：每次插入新结点后，更新 `rear` 指针，使其指向新结点。
> - **设置最后一个结点的 `next` 指针**：在循环结束后，确保最后一个结点的 `next` 指针指向 `NULL`。

``` c
void createByTail(LinkList &list, int arr[], int n) {
    list = new LNode; // 创建头结点
    list->next = NULL; // 头结点的 next 指向 NULL
    LNode *rear = list; // 初始时 rear 指向头结点

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        LNode *s = new LNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        rear->next = s; // 将新结点连接到当前尾结点的后面
        rear = s; // 更新尾结点为新结点
    }
    rear->next = NULL; // 最后一个结点的 next 指向 NULL
}
```

## 双链表

### 建表(头插)

> - **创建头结点**：初始化一个头结点 `head`，并将 `next` 和 `prior` 指针设置为 `NULL`。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的头部。
> - 更新指针：
>   - 新结点的 `next` 指针指向当前头结点的 `next`。
>   - 如果头结点的 `next` 不为空，则更新 `head->next` 的 `prior` 指针，使其指向新结点 `s`。
>   - 新结点的 `prior` 指针指向头结点 `head`。
>   - 更新头结点 `head` 的 `next` 指针，使其指向新结点 `s`。

``` c
// 使用头插法创建双向链表
void createDListByHead(DLinkList &head, int arr[], int n) {
    head = new DNode; // 创建头结点
    head->next = NULL; // 头结点的 next 指向 NULL
    head->prior = NULL; // 头结点的 prior 指向 NULL

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        DNode *s = new DNode;
        s->data = arr[i]; // 设置新结点的数据
        s->next = head->next; // 新结点的 next 指向当前头结点的 next
        if (head->next != NULL) { // 如果头结点后面有数据
            head->next->prior = s; // 修改后继结点的前驱指针
        }
        s->prior = head; // 新结点的前驱指针指向头结点
        head->next = s; // 头结点的 next 指向新结点
    }
}
```

### 建表(尾插)

> - **创建头结点**：初始化一个头结点 `head`，并将 `next` 和 `prior` 指针设置为 `NULL`。
> - **初始化尾指针**：初始时 `rear` 指向头结点。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的尾部。
> - 更新指针：
>   - 新结点的 `next` 指针设置为 `NULL`（因为它是新的尾结点）。
>   - 新结点的 `prior` 指针指向当前尾结点 `rear`。
>   - 当前尾结点 `rear` 的 `next` 指针指向新结点 `s`。
>   - 更新 `rear` 指针，使其指向新结点 `s`。

``` c
// 使用尾插法创建双向链表
void createDListByTail(DLinkList &head, int arr[], int n) {
    head = new DNode; // 创建头结点
    head->next = NULL; // 头结点的 next 指向 NULL
    head->prior = NULL; // 头结点的 prior 指向 NULL
    DNode *rear = head; // 初始时 rear 指向头结点

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        DNode *s = new DNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        s->next = NULL; // 新结点的 next 指向 NULL
        s->prior = rear; // 新结点的前驱指针指向当前尾结点
        rear->next = s; // 当前尾结点的 next 指向新结点
        rear = s; // 更新尾结点为新结点
    }
}
```



### 插入结点

> 按位置插入 ，
>
>  找寻对应插入位置 若结点为空或者下标越界则代表插入位置错误
>
> 否则进行插入操作 并修改相应指针

``` c
bool InsertByPos(DLinkList &head, int n, int e) {
    if (head == NULL)
        return false;
    DNode *p = head->next;
    int i = 0;
    while (p != NULL and i < n - 1) {
        p = p->next;
        i++;//找寻插入位置
    }
    if (p == NULL)
        return false;

    DNode *s = new DNode;//插入 新建j结点
    s->data = e;
    s->next = p->next;
    if (p->next != NULL)//存在后继结点 则修改前驱指针
        p->next->prior = s;
    s->next = p;
    p->next = s;
    return true;
}
```

### 删除

> - **初始化检查**：确保链表不为空且有实际数据结点。
> - **查找删除位置**：使用 `while` 循环遍历链表，直到找到第 `n` 个位置。
> - **处理边界情况**：如果下标越界，返回 `false`。
> - 删除结点：
>   - 更新 `p` 的前驱结点的 `next` 指针。
>   - 更新 `p` 的 `next` 的 `prior` 指针（如果 `p` 的 `next` 不为空）。
>   - 释放 `p` 结点的内存。

``` c
bool deleteByPos(DLinkList &head, int n) {
    if (head == NULL)
        return false;
    DNode *p = head->next;
    int i = 1;
    // 循环找寻删除结点，如果下标越界或结点为空 返回
    while (p != NULL && i < n) {
        p = p->next;
        i++;
    }
    if (p == NULL) {
        return false; // 下标越界
    }
    // 进行删除操作
    p->prior->next = p->next;
    if (p->next != NULL) {
        p->next->prior = p->prior;
    }
    // 释放结点
    free(p);

    return true;
}
```

## 循环单链表

### 统计值为x的个数

> ⑴判断是否是空链表：head->next==head ;
>
> （2）判断是否是表尾结点： p->next==head ;

``` c
//循环单链表 统计表内值为x的个数
int countByValue(LinkList head, int x) {
    while (head->next == head or head==NULL)
        return -1;
    LNode *p = head->next;
    int count = 0;
    while (p != head) {
        if (p->data == x)
            count++;
        p = p->next;
    }
    return count;
}
```

## 循环双链表

> 1.链表中没有空指针域 
>
> 2.p所指结点为尾结点的条件：p->next==L 
>
> 3.一步操作即L->prior可以找到尾结点

### 删除第一个值为x



``` c
//删除循环双链表中 第一个值为x的结点
bool deleted(DLinkList head, int x) {
    if (head == NULL || head->next == head) {
        return -1; // 链表为空或只有一个头结点
    }
    DLNode *p = head->next;
    while (p != NULL and p->next != head and p->data!=x)
        p = p->next;
    if (p->data == x)//找到
    {
        p->next->prior = p->prior;
        p->prior->next = p->next;
        free(p);
        return true;
    }
    return false;
}
```

### 是否对称

> 初始化检查链表不为空
>
> 使用while遍历从两边向中间进行比较，若遇见左右值不相等直接返回
>
> 分别处理长度为奇数和偶数的情况

``` c 

//判断循环双链表 内部元素值 是否对称
bool check(DLinkList head) {
    if (head == NULL or head->next == head)
        return false;
    DLNode *left = head, *right = head->prior;//left之前头节点 right指向 尾结点
    while (left != right and left->next != right) { // 循环条件：left 和 right 不相遇且 left 的下一个结点不是 right
        if (left->data != right->data) {
            return false; // 如果左右结点的数据不相等，则返回 false
        }
        left = left->next; // 移动 left 指针到下一个结点
        right = right->prior; // 移动 right 指针到前一个结点
    }

    if (left == right) // 如果链表长度为偶数，最后 left 和 right 会相邻
        return true; // 单个中间结点，直接返回 true
    else
        return left->data == right->data; // 检查相邻的两个结点是否相等

}
```



## 线性表





### 合并有序数组

> 两个指针分别从两个数组 表头开始遍历，
>
> 每次从两个数组中各取一个元素比较，将较小的元素放置排序数组中
>
> 当其中一个遍历完成后，将剩余的元素加入排序数

``` c
void merge(int nums1[], int nums2[], int n, int m) {
    int p1 = 0, p2 = 0;
    int temp[25];

    int cur=0;//临时赋值数组的指针
    while (p1 < n and p2 < m) {
        if (nums1[p1] < nums2[p2])
            temp[cur++] = nums1[p1++];
        else
            temp[cur++] = nums2[p2++];
    }
    while (p1 < n)
        temp[cur++] = nums1[p1++];
    while (p2 < m)
        temp[cur++] = nums2[p2++];
    for (int i = 0; i < n + m; ++i) {
        nums1[i] = temp[i];
    }
}
```





### 删除值为k的值(数组)

> 思想：
>
>  从头开始遍历，并进行比较
>
>  若当前元素值等于x，则进行删除并将剩余元素进行移动
>
>  以此类推直至遍历结束 (注意边界条件)

``` c
// 删除数组中的重复元素
void removeDuplicates(int arr[], int n, int x) {
    int count = 0; // 用于记录需要移除的元素数量

    for (int i = 0; i < n - count; ++i) {
        if (arr[i] == x) {
            // 将当前元素之后的所有元素向前移动一位
            for (int j = i; j < n - count - 1; ++j) {
                arr[j] = arr[j + 1];
            }
            count++; // 增加计数器
            i--; // 由于删除了一个元素，需要重新检查当前位置
        }
    }
}
```



### 数组轮转

> 思路:
>
>   1.首先若k>n则对k取余
>
>   2.对右边 k个元素 进行反转，即(n-k ,n-1)
>
>   3.对左边 剩余元素 进行翻转，即（0 ，n-k-1)
>
> 4. 最后对整个数组进行翻转，即得到题目所要求的翻转数组

``` c

```



### 删除链表重复元素

> 算法思想:
>
>  1.使用库文件自带set<> 集合来记录是个否遇到重复元素
>
>  2.若数组非空对其进行遍历，遇到结点值进行判断
>
> ​    若set中包含此元素，则进行删除操作
>
> ​    反之则将其加入set中
>
>  3.以此类推，直至循环结束

``` c
// 删除单链表中重复出现的结点
void deletedLinkNodeByRepeat(LinkList head) {
    if (head == NULL || head->next == NULL) 
        return; // 链表为空或只有一个结点

    set<int> s; // 使用集合来记录已经遇到过的值
    LNode *pre = head;
    LNode *p = head->next;

    while (p != NULL) {
        if (s.find(p->data) == s.end()) { // 首次出现，非重复
            s.insert(p->data); // 将当前结点的数据加入集合
            pre = p;
            p = p->next;
        } else { // 重复出现的元素，进行删除
            pre->next = p->next; // 更新前驱结点的 next 指针
            free(p); // 释放当前结点的内存
            p = pre->next; // 更新 p 指针
        }
    }
}
```

### 是否有环

> 1. **初始化**：
>    - 初始化两个指针 `slow` 和 `fast`，都指向链表的头节点。
>    - `slow` 指针每次移动一步，`fast` 指针每次移动两步。
> 2. **环检测**：
>    - 在链表上移动这两个指针。
>    - 如果链表中存在环，那么快指针最终会追上慢指针，即 `slow == fast`。
>    - 如果 `fast` 或 `fast->next` 变成 `NULL`，则说明链表没有环。
> 3. **找到环的入口**：
>    - 一旦发现环，将 `fast` 指针重新指向链表头部，而 `slow` 保持在相遇点。
>    - 然后同时移动 `slow` 和 `fast`，每次各移动一步。
>    - 当 `slow` 和 `fast` 再次相遇时，它们所在的节点就是环的入口。

``` c
x// 检测单链表是否存在环，并找到环入口
LNode *check(LinkList head) {
    if (head == NULL || head->next == NULL)
        return NULL; // 如果链表为空或只有一个节点，则不可能有环

    LNode *slow = head; // 慢指针
    LNode *fast = head; // 快指针

    // 使用快慢指针遍历链表
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;          // 慢指针每次走一步
        fast = fast->next->next;    // 快指针每次走两步
        if (slow == fast) {         // 如果相遇，则存在环
            cout << "There is a circle." << endl;
            break;
        }
    }

    if (fast == NULL || fast->next == NULL)   // 如果没有环
        return NULL;
    // 找到环的入口
    fast = head; // 将快指针移回到链表头
    while (slow != fast) { // 当两个指针相等时，即为环的入口
        slow = slow->next;
        fast = fast->next;
    }

    return slow; // 返回环的入口
}
```

#### 法二

> 思想:
>
>   1.在链表结构体中加入变量vis，判断是否该节点被访问
>
>   2.每次进行判当前结点vis是否为1，
>
> ​      Ⅰ.若不为1则代表未访问,将其置1
>
> ​      Ⅱ.若为1则代表有环 ，且该节点为环的入口

``` c 
//检测单链表是否存在环，若有并找到环入口
LNode *check(LinkList head) {
    if (head == NULL or head->next == NULL)
        return NULL;
    LNode *p = head->next;
    while (p != NULL) {
        if (p->vis == 1)//有环且找到 环的入口
            return p;
        else //无环 将其vis置1
            p->vis = 1;
        p = p->next;
    }
    return NULL;
}
```



## 查找结点|freq++|调整位置
