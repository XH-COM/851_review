# 851复习文档

> ### By Liuxiao && Jianjian

## 线性结构

​	*什么是线性结构，链表和线性表的区别，二者的特点*



>  线性结构是一种数据元素之间存在一对一关系的数据结构。在这种结构中，除了第一个和最后一个元素外，每个元素都有一个直接前驱和一个直接后继。线性结构可以是顺序存储的（如数组），也可以是非顺序存储的（如链表）
>
> ***\*线性表（Linear List）\**** 通常指的是逻辑上的概念，它是一个由n个数据元素组成的有限序列。这些数据元素具有相同的类型，并且有先后次序。如数组。
>
> ***\*链表（Linked List）\**** 是一种物理存储单元上非连续、非顺序的线性结构，用一组任意的存储单元来存放线性表中的数据元素。链表中的数据元素被称为节点，每个节点包含数据域和指向下一个节点的指针域。根据指针的连接方式，链表可以分为单链表、双链表和循环链表等。
>
> ***\*二者的特点：\****
>
> 线性表（以数组为例）
>
> o 随机访问：可以直接通过下标在O(1)时间内访问到指定位置的元素。
>
> o 存储密度高：由于元素在内存中是连续存储的，所以没有额外的空间浪费。
>
> o 插入删除效率低：如果需要在中间插入或删除元素，则可能需要移动大量元素，平均时间复杂度为O(n)。
>
> o 固定大小：一般而言，数组创建时需要指定大小，在使用过程中不容易改变。
>
> 链表
>
> o 顺序访问：只能从头节点开始，逐个访问后续节点，无法直接跳转到某个特定位置，访问时间为O(n)。
>
> o 插入删除效率高：只需要修改前后节点的指针即可完成插入或删除操作，不需要移动元素，时间复杂度为O(1)。
>
> o 存储密度较低：因为每个节点除了数据域外还需要额外的指针域来链接下一个节点

## 树、二叉树、 森林

### 树

> 树（Tree） 是一种非线性的数据结构，它由n（n>=0）个有限节点组成一个具有层次关系的集合。这个集合满足以下条件：
>
> 1. 有一个特定的称为根（root）的节点。
> 2. 剩余的节点可以被分为m（m >= 0）个互不相交的子集T1, T2, ..., Tm，每个子集本身又是一棵树，并且这些子集被称为根的子树。
> 3. 在树结构中，除了根节点之外，每个节点有且仅有一个父节点，而根节点没有父节点。同时，一个节点可以有零个或多个子节点。

### 二叉树

> **二叉树（**Binary Tree） 是一种特殊的树结构，它的特点是每个节点最多只能有两个子节点：左子节点和右子节点。即使某节点只有一个子节点，也要区分是左子节点还是右子节点。二叉树的定义如下：
>
> 二叉树可以为空。如果非空，则该树由根节点、左子树和右子树组成，其中左子树和右子树也是二叉树。
>
> 二叉树的一些重要特性包括：
>
>  每个节点至多只有两个子节点。
>
> 左子树和右子树是有顺序的，不能随意交换。
>
> 即使树中某个节点只有一棵子树，也要区分它是左子树还是右子树。

#### 二叉树结构

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;
```

#### 非递归先序(Pre)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void PreOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            printf(" %d--", p->data);
            s.push(p);
            p = p->left;//访问左边先 跟左右
        } else {
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            p = p->right;
        }
    }
}

```

#### 非递归中序(In)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void InOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            s.push(p); //先入栈不访问
            p = p->left;//一路向左找

        } else {//某个父节点的左孩子为空 返回父结点并访问
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            printf("%d--", p->data);//这里和先序不太一样
            p = p->right;
        }
    }
}

```

#### 非递归后序(Post)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void postOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *visited = NULL;//记录最近访问过的结点
    BiTNode *p = t;
    while (p or !s.empty()) {
        while (p) {
            //尽可能往左走
            s.push(p);
            p = p->left;
        }
        //左边到头了 查看栈元素
        p = s.top();
        if (p->right == NULL or p->right == visited) {
            cout << "--" << p->data;//没右孩子 或 右边已经访问过了
            s.pop();//已经访问该结点
            visited = p;//更新最新结点
            p = NULL;//设置为NULL  以便下一次迭代可以处理栈中的下一个结点
            //比如最后一个结点是根节点 你访问了肯定要设为空 不然is.empty一直为true
        } else {
            //去遍历右子树先
            p = p->right;
        }
    }
}
```

### 平衡二叉树(BST)

>平衡二叉树是一种特殊的二叉树，它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都必须是平衡二叉树。这种结构确保了树的高度保持在对数级别（以2为底），从而保证了各种操作（如查找、插入和删除）的时间复杂度都是O(log n)，其中n是节点的数量。

### 森林

>  森林（Forest） 是指零个或多个不相交的树的集合。换句话说，如果将一棵树的根节点移除，那么剩下的部分就变成了一个森林。森林中的每棵树都是独立的，没有任何节点共享相同的父节点。森林可以看作是树的一种扩展形式，二叉树是对树的一种限制，而森林则是多棵树的集合。
>
> 

```c++
#include <bits/stdc++.h>

using namespace std;

int main(){
    
   
}
```

## 图

### 邻接矩阵



``` c
const int Maxn = 1e3 + 7;
// 邻接矩阵定义
typedef struct MGraph {
char vexes[Maxn]; // 顶点表，可以不要
int edges[Maxn][Maxn]; // 用邻接矩阵存储边
int vexNum, arcNum; // 顶点数，边数
} MGraph;
```

### 邻接表

``` c
const int Maxn = 1e3 + 7;
//边结点
struct ArcNode {
int adjvex; //顶点编号
ArcNode *next; //指向vi的下一个邻接顶点
};
// 顶点结点
struct VNode {
int data; //顶点信息 
ArcNode *firstarc; //指向vi的第一个邻接顶点（边）
};
// 图的邻接表表示
typedef struct AGraph {
VNode adjlist[Maxn]; // 顺序存储所有顶点链表的表头结点
int vexNum, arcNum; // 图的顶点个数，边数
} AGraph;
```

### 深搜(DFS)

> 设初始状态时图中的所有顶点未被访问，则： 
>
> 1. 首先，访问开始结点从起始结点开始任选一个相邻并未被 访问的结点，访问； 
> 2. 接着，把找到的结点作为起始结点继续访问其相邻且未被 访问的一个结点； 
> 3. 重复2的操作直到某一个结点所有相邻结点都被访问，则 退回最近被访问且还有相邻结点未被访问的结点；  
> 4. 把3中结点作为起始结点继续执行2，3操作直到所有结点 都被访问完为止

#### dfs邻接表

``` 	c

int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(AGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    ArcNode *p = g->adjlist[v].firstarc;//v指向的第一个邻接结点
       while (p != NULL) {//从起始结点开始任选一个相邻并为访问的结点
        if (visited[p->adjvex] != 1) {
            dfs(g,p->adjvex);//把找到的边 作为起始顶点继续访问
            //未访问过 深度优先
        }
        p = p->next;
    }
}
void dfsTraverse(AGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
        if (visited == 0)  //不需要 重置0 因为 可能有点 不连通 需要继续dfs
            dfs(g, i);
    }//遍历每个没被访问的结点,从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}

```

#### dfs邻接矩阵

``` 	c
int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(MGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    for (int i = 0; i < g->vexNum; ++i) {
        if (g->edges[v][i] == 1 and !visited[i])//有路径且未访问过
            dfs(g, i);
    }
}

void dfsTraverse(MGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
         if (visited[i] == 0)
            dfs(g, i);
    }//遍历每个没被访问的结点 从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}
```





## 排序

>  ==*堆排序*==（Heap Sort）是一种基于比较的排序算法，它利用了堆这种数据结构所设计的一种选择排序。堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于（最大堆）其所有子节点的值，或者每个父节点的值都小于或等于（最小堆）其所有子节点的值。
>
>  ==堆排序的三个时间复杂度都是O(longn),空间复杂度O(1)==
>
>  在堆排序中，我们通常使用最大堆来对数组进行升序排序。以下是堆排序的基本思想和步骤：
>
>  ### 堆排序的思想
>
>  - 首先将待排序序列构建成一个最大堆。
>  - 然后将堆顶元素（即最大值）与序列末尾的元素交换，使得最大值位于已排序部分的末尾。
>  - 重新调整剩余的序列成为一个新的最大堆。
>  - 重复上述过程，直到整个序列排序完成。
>
>  ### 堆排序的步骤
>
>  1. **构建初始堆**：从最后一个非叶子节点开始，向下调整以确保满足最大堆性质。这个过程称为“堆化”
>    - 对于一个大小为 n 的数组，最后一个非叶子节点的位置是 (n/2) - 1。
>    - 从这个位置开始，向前遍历每一个非叶子节点，并调用堆化函数来维护最大堆属性。
>  2. **交换堆顶元素与末尾元素**：将当前堆顶元素（最大值）与未排序序列的最后一个元素交换，然后缩小未排序序列的范围。
>  3. **调整堆**：对于新调整后的堆，再次执行堆化操作，使剩下的元素重新构成最大堆。
>  4. **重复步骤2和3**：持续上述过程，每次都将当前的最大值移动到已排序部分的末尾，直至整个数组变为有序。
>
>  

### 堆排序

``` c++
#include <bits/stdc++.h>
using namespace std;
// 调整为大根堆 以k为根节点的子树  数组下标从1开始
void HeapAdjust(int arr[], int k, int n) {
    int i = 2 * k;//左孩子
    while (i <= n) {
        //一层一层向下筛选
        if (i < n and arr[i] < arr[i + 1]) {
            i++;//i指向较大的子节点 沿着值大的子节点往下筛选
        }

        if (arr[k] < arr[i]) {
            //根节点比两个孩子中较大的孩子小 交换
            swap(arr[k], arr[i]);
            k = i;//继续调整受影响的子树
            i = k * 2;
        } else {
            break;//无影响 调整结束
        }
    }
}

// 构建大根堆
void buildMaxHeap(int arr[], int n) {
    // 从最后一个非叶子节点开始调整
    for (int i = n / 2; i >= 0; i--)//从后往前调整 例如7个元素 1-2-3 非叶节点是1，2，3下标
        HeapAdjust(arr, n, i);
}

// 堆排序
void heapSort(int arr[], int n) {
    // 构建大根堆
    buildMaxHeap(arr, n);
    // 逐个移除堆顶元素 与待排序序列中的最后一个元素进行交换
    for (int i = n; i > 1; i--) {
        // 将堆顶元素移到数组末尾
        //为什么移动到末尾 因为如果你 这相当于排序 你要给他移动到 n n-1 n-2····1
        swap(arr[1], arr[i]);
        // 调整剩余元素为大根堆
        HeapAdjust(arr, 1, i - 1);
    }
}

// 打印数组
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = 6;
    printf("Original array: \n");
    printArray(arr, n);
    heapSort(arr, n);
    printf("Sorted array: \n");
    printArray(arr, n);
    return 0;
}
```



# 算法



## 递归

### 定义思想

> 1. 直接或间接地调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。 
> 2. 直接递归：p函数中调用p函数 
> 3. 间接递归：p函数调用q函数，q函数又调用p函数。 
> 4. 递归函数的两个要素：边界条件、递归方程

> ### 递归小结： 
>
> 1.优点：结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序 带来很大方便。 
>
> 2.缺点：递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。 
>
> 3.解决方法：在递归算法中消除递归调用，使其转化为非递归算法。采用一个用户定义的栈来模拟系统的递归调用工作栈。该方法通用性强，但本质上还是递归 优化效果不明显。 （2）、用递推来实现递归函数。 （3）、通过变换能将一些递归转化为尾递归，从而迭代求出结果

### 分治与递归的区别

> **分治法与递归区别**： 
>
> 1. 分治法是解决问题的方法。
>
> 2. 递归是实现各种算法的工具，二叉树、回溯、贪心算法等都可以选择用递归的方式来解决。

## 分治

### 定义思想

> **定义：** 分治法是一种将问题分解成若干个规模较小的相同子问题，然后递归地解决这些子问题，并将各个子问题的解合并得到原问题解的方法。
>
> **思想：**
>
> 1. **分解**：将原问题分解为几个规模较小、相互独立且与原问题形式相同的子问题。
> 2. **解决**：若子问题规模足够小，则直接求解；否则继续分解为更小的子问题，直到可以直接求解。
> 3. **合并**：将子问题的解逐层合并，形成最终的原问题的解

## 动规

### 定义思想

> **定义**：
> 动态规划是通过把原问题分解为相对简单的子问题来求解复杂问题的一种方法。它通常用来解决最优化问题，即从许多可行解中找出一个最优解。
>
> **思想**：
>
> 重叠子问题：动态规划适用于子问题会重复出现的情况，这样可以通过保存已经解决过的子问题的答案来避免重复计算。
> 最优子结构：一个问题的最优解依赖于其子问题的最优解。这意味着可以通过组合子问题的最优解来构造整个问题的最优解。记忆化：利用数组或哈希表存储已解决子问题的结果，以减少计算量。

## 动规和分治联系与区别

> ### 相同点
>
> 1. **分解思想**：
>    - 两者都将原问题分解成较小的子问题。
>    - 都试图通过解决这些子问题来构建整个问题的解决方案。
> 2. **递归结构**：
>    - 分治法通常采用自顶向下的递归来解决问题。
>    - 动态规划也可以使用带有记忆化的递归来实现，这被称为自顶向下的方法。
>
> ### 不同点
>
> 1. **子问题的独立性**：
>    - 分治法中的子问题是独立的，不共享状态信息。
>    - 动态规划处理的是具有重叠子问题的情况，这些子问题之间可能存在依赖关系。
> 2. **求解方式**：
>    - 分治法通常是自顶向下的递归过程。
>    - 动态规划可以是自底向上的迭代过程，也可以采用带备忘录的自顶向下的递归方法。
> 3. **适用场景**：
>    - 分治法适合用于能够被分解为多个完全独立的子问题的问题。
>    - 动态规划适合于那些可以通过分解为更小的子问题并且子问题存在重叠的情况，以及需要寻找最优解的问题。

## 贪心

> **定义**： 贪心算法总是作出在当前看来最好的选择,即贪心选择。也就是说贪心算法并不从整体最优考虑， 
>
> 它所作出的选择只是在某种意义上的局部最优选择。 (当然，希望贪心算法得到的最终结果也是整体最优的。 虽然贪心算法不能对所有问题都得到整体最 优解， 但对许多问题它能产生整体最优解。 在一些情况下， 即使贪心算法不能得到整体最优解， 其最终结果却是最优解的很好近似。
>
> **基本要素**： 贪心选择性质：指所求问题的整体最优解可以通过一系列局部最优的选择， 即贪心选择来达到。（动规的每一步选择往往与其子问题的解有关，而贪心选择不顾前后，仅看当下。） 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质
>
> 贪心算法的特点： 
>
>  a.贪心算法并不保证得到最优解，但是，对于很多问题确实可以求得最优解。 
>
> b.贪心算法可能依赖之前作出的决定，但是，不依赖任何将来的选择或是子问题的解。 
>
> c.贪心算法适用于组合优化问题 
>
> d.贪心算法的求解过程是多步判断过程，最终的判断序列对应于问题的最优解。 
>
> e.依据**某种** “眼前最好，短视的” （这说明在具体的问题中，有多种不同的贪心策略，我们需 要进行可行性的判定）贪心选择性质判断，性质好坏决定算法的成败。 
>
> f. 贪心法必须进行正确性证明 
>
> g.证明贪心法的不正确的技巧： 举反例



### 贪心和动规

> ### 贪心算法
>
> - **局部最优选择**：贪心算法在每一步都做出当前看起来最好的选择，并且期望这些局部最优的选择能够导致全局最优解。
> - **适用范围有限**：贪心算法只适用于那些具有“贪心选择性质”的问题。也就是说，局部最优解可以累积成为全局最优解的问题。对于很多问题，贪心算法可能无法找到最优解。
>
> ### 动态规划
>
> - **全局考虑**：动态规划通过将问题分解为子问题来寻找最优解，并利用子问题的解来构造原问题的解。它会考虑到所有可能的情况，从而确保得到全局最优解。
> - **记忆化/重叠子问题**：动态规划利用了子问题的重叠性质，即同一个子问题不会被重复计算多次。通常通过使用数组或其他数据结构存储已经解决过的子问题的结果。
> - **递归与迭代**：动态规划既可以采用自顶向下的递归方式，也可以采用自底向上的迭代方式。
>
> ### 相同点
>
>    都要求最优子结构
>
> ### 贪心算法的优缺点： 
>
>    优点：算法简单，时间和空间复杂度低。 
>
>   缺点：适用范围有限。



## 回溯

> **定义**： 在问题的解空间树中， 按深度优先策略，从根结点出发搜索解空间树。（问题的解空间一般用树形式来组织，也称为解空间树或状态空间） 
>
> **问题的解空间**: 一个复杂问题的解决方案是由若干个小的决策步骤组成的决策序列，解决一个问题的所有可能的决策序列 构成该问题的解空间。 
>
> 解空间树: 问题的解空间一般用树形式来组织，也称为解空间树或状态空间，树中的每一个结点确定所求解问题的一个问题状态。 
>
> 树的根结点位于第1层，表示搜索的初始状态（不做任何选择），第2层的结点做出第一次选择后到达的状 态，以此类推。 
>
> 可行解与最优解: 解空间中满足约束条件的决策序列称为可行解。 解任何问题都有一个目标，在约束条件下使目标达到最优的可行解称为该问题的最优解。
>
> 其他概念: 活结点： 是指自身已生成但其孩子结点没有全部生成的结点。 
>
> 扩展结点： 是指正在产生孩子结点的结点。 
>
> 死结点： 是指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕。 
>
> 子孙： 结点E的子树上所有结点都是E的子孙。 
>
> 祖宗： 从结点E到树根路径上的所有结点都是E的祖宗。

### 回溯思想 

> 1. **试探**：从根节点（通常是初始状态）开始，按照一定的顺序探索可能的解。
> 2. **前进**：在每一步中，根据问题定义做出一个选择，进入下一个状态。
> 3. **检查**：到达某个状态后，判断这个状态是否满足问题的部分约束条件。如果满足，则继续深入；如果不满足，则需要进行回溯。
> 4. **回溯**：当发现当前的选择不能导致有效的解时，算法会撤销之前的选择（即“回溯”），回到上一个决策点，尝试其他未被探索过的选项。
> 5. **终止条件**：当找到一个完整的解或者所有可能的解都被探索完毕时，算法结束

> **剪枝**：在回溯过程中，通过某些条件提前终止对不可能产生有效解的分支的探索，从而减少不必要的计算。这包括限界函数和约束函数。
>
> - ==**约束函数**==：用来决定哪些节点是可行的，即这些节点对应的解部分满足问题的约束条件。//可行解
> - ==**限界函数**==：用于估计子树中的最优解，以确定是否值得进一步探索该子树  //最优解

## 分支限界

> ### 定义
>
> 分支限界法（Branch and Bound, B&B）是一种用于求解优化问题的算法，结合了广度优先搜索和贪心算法的思想，通过系统地生成可行解，并利用限界函数来避免探索那些不可能产生最优解的分支，从而提高搜索效率。

### 思想

> ### 分支限界法的思想
>
> 1. **分支**：将问题分解为更小的子问题，每个子问题代表了解空间的一部分。
> 2. **限界**：对于每一个子问题，==计算一个下界（最小化问题）或上界（最大化问题）==，这个界限用来估计从当前节点开始能够得到的最好结果。
> 3. **剪枝**：如果某个节点的界限已经超过了目前已知的最佳解，则可以放弃对该节点及其后代节点的进一步探索，因为它们不会导致更好的解。
> 4. **选择**：按照一定的策略（如队列、堆等）选择下一个要扩展的节点，通常选择最有希望改进当前最佳解的节点。
> 5. **更新**：一旦找到一个新的可行解，就更新最佳解，并用新的最佳解去修剪更多的分支。

> ### 相关概念
>
> - **状态空间树**：类似于回溯法中的解空间树，分支限界法也构建了一个表示所有可能解的状态空间树。
> - **活节点**：在搜索过程中尚未被完全处理的节点，即还有可能成为最终解路径上的节点。
> - **死节点**：已经被确定不能产生比现有最优解更好的解的节点。
> - **限界函数**：提供了一个关于解质量的估计，用来决定是否需要继续探索某个分支。对于最小化问题，限界函数给出的是下界；对于最大化问题，限界函数给出的是上界。
> - **最优性剪枝**：当一个节点的限界值大于等于当前已知最优解时，该节点及其子节点就可以被剪掉。
> - **可行性剪枝**：当一个节点不满足问题的约束条件时，也可以进行剪枝。
> - **优先队列/堆**：用来存储待处理的活节点，并根据某种标准（通常是限界值）对这些节点进行排序，以确保总是优先处理最有可能改进当前最优解的节点。

> ### 两种分支限界法：
>
>  1.队列式(FIFO)分支限界法：按照队列先进先出（ FIFO） 原则选取下一个节点为扩展节点。 
>
>  2.优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。

> ### 队列式分枝限界法组织结点表: 
>
> 1.将根结点加入活结点队列。 
>
> 2.从活结点队中取出队头结点，作为当前扩展结点。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，用约束条件检查，把所有满足约束条件的孩子 结点加入活结点队列。 
>
> 4.重复步骤2和3，直到找到一个解或活结点队列为空为止

> ### **优先队列式分枝限界法组织结点表**: 
>
> 1.计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。 
>
> 2.从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分枝推 进，以便尽快地找出一个最优解。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的 孩子结点计算优先级并加入优先队列。 
>
> 4.重复步骤2和3，直到找到一个解或优先队列为空为止

>### **回溯法与分支限界对比**: 
>
>相同：都需要搜索解空间求解 
>
>不同：1.回溯法按照深度优先搜索，分支限界按照广度优先 
>
>2.回溯法存储结点的数据结构是栈，而分支限界是队列、优先队列 
>
>3.回溯法结点多次成为活结点，分支限界每个结点只有一次成为活结点的机会

# 代码篇

## 阶乘

``` c
int fun(int n) {
    if (n == 0)
        return 1;
    return n * fun(n - 1);
}

int fun2(int n) {//非递归
    int sum = 1;

    if (n == 0) {
        return 1;
    } else {
        for (int i = 2; i <= n; ++i) {
            sum *= i;
        }
    }
    return sum;
}

```

## Fibonacci

``` c
    if (n == 1 or n == 2) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
```



## 二分查找

``` c
int BinarySearch(int arr[], int n, int x) {//记住 数组是有序的
     int left=0;
     int right=n-1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (x == arr[mid])
            return mid;
        if (x < arr[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;//**没找到
}
```

## 快排 (QuickSort)

> #### 思想
>
> 快速排序是一种分治算法，其基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分继续进行排序，以达到整个序列有序的目的。
>
> #### 步骤
>
> 1. **选择枢轴（Pivot）**：从数组中选择一个元素作为枢轴。
> 2. 分区（Partition）
>    - 将所有小于枢轴的元素移到枢轴的左边。
>    - 将所有大于枢轴的元素移到枢轴的右边。
> 3. 递归排序
>    - 对枢轴左边的子数组进行快速排序。
>    - 对枢轴右边的子数组进行快速排序。

``` c

int partition(int arr[], int low, int high) {
    //挖空法
    int pivot = arr[low];//选取第一个元素作为枢轴
    while (low < high) {
        while (low < high and arr[high] >= pivot)
            high--;
        arr[low] = arr[high];
        while (low < high and arr[low] <= pivot)
            low++;
        arr[high] = arr[low];
    }
    arr[low]=pivot;//基准元素最后的位置
    return low;//返回中间位置
}

void quickSort(int arr[],int low,int high){
    if (low<high){
        int pivot=partition(arr,low,high);
        quickSort(arr,low,pivot-1);
        quickSort(arr,pivot+1,high);
    }
}
```

## 归排

>#### 思想
>
>归并排序也是一种分治算法，其基本思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成一个有序数组。
>
>#### 步骤
>
>1. **分解**：将数组分成两个子数组。
>2. **递归排序**
>
>​    对左子数组进行归并排序。
>
>  - 对右子数组进行归并排序。
>
>3. **合并**：将两个有序的子数组合并成一个有序数组。

``` c
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k=0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}
void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left,right);
}
```

## 棋盘覆盖

> ### 算法思想
>
> 1. **分治法**：
>    - 将棋盘分成四个 2n−1×2n−12*n*−1×2*n*−1 的子棋盘。
>    - 特殊方格必然位于这四个子棋盘中的一个。
>    - 对于不含特殊方格的子棋盘，选择一个“伪”特殊方格，使得每个子棋盘都有一个特殊方格。//自己添加 tile
> 2. **递归处理**：
>    - 递归地对每个子棋盘进行同样的操作，直到子棋盘大小为 1x1。
>    - 当子棋盘大小为 1x1 时，直接返回，因为 1x1 的棋盘无法再分割。
> 3. **放置 L 形瓦片**：
>    - 在每个子棋盘中，选择一个位置放置 L 形瓦片，以覆盖除了特殊方格之外的其他三个方格。
>    - 通过递归调用，确保每个子棋盘都被正确覆盖。
>
> ### 详细步骤
>
> 1. **初始化**：
>
>    - 定义一个全局变量 `tile` 用于标记不同的 L 形瓦片。
>    - 定义一个二维数组 `board` 用于存储棋盘的状态。
>
> 2. **递归函数 `ChessBoard`**：
>
>    - `tr` 和 `tc`：当前子棋盘的左上角行和列。
>    - `dr` 和 `dc`：特殊方格的行和列。
>    - `size`：当前子棋盘的大小。
>
>    - 递归终止条件：如果 `size` 为 1，则直接返回。
>    - 计算子棋盘的边长的一半 `s = size / 2`。
>    - 根据特殊方格的位置，递归处理四个子棋盘，并在需要的地方放置 L 形瓦片。

```  c
//https://www.bilibili.com/video/BV1QV411m7ff/?spm_id_from=333.337.search-card.all.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int tile = 1;
int board[100][100] = {0};

void ChessBoard(int tr, int tc, int dr, int dc, int size) {
    // 左上角的行 列， 特殊方块的行 列，棋盘的大小
    if (size == 1) {//1*1 的棋盘无法再分割
        return;
    }
    //2*n 2*3 6*6
    int t = tile++;//标号用的
    int s = size / 2;//取边长一般
    //覆盖左上角  1 1
    //          1 0
    if (dr < tr + s and dc < tc + s) {   //若特殊方格在棋盘中 左下角的右下角
        ChessBoard(tr, tc, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s - 1] = t;//填上数 方便看
        ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s);//不能填的位置 左上角的右下角-1
    }

    //覆盖右上角  1 1
    //          0 1
    if (dr < tr + s and dc >= tc + s) {   //若特殊方格在棋盘右上角中
        // < 和 >=都可以 要么加上 -1或+1边界问题而已
        ChessBoard(tr, tc + s, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s] = t;//特殊的-1
        ChessBoard(tr, tc + s, tr + s - 1, tc + s, s);//右上角的左下角
    }

    //再左下角    1 0
    //          1 1
    if (dr >= tr + s and dc < tc + s) {   //若特殊方格在棋盘中
        ChessBoard(tr + s, tc, dr, dc, s);
    } else {
        board[tr + s][tc + s - 1] = t;
        ChessBoard(tr + s, tc, tr + s, tc + s - 1, s);
    }
    //覆盖右下角
    if (dr >= tr + s and dc >= tc + s) {   //若特殊方格在棋盘中
        ChessBoard(tr + s, tc + s, dr, dc, s);
    } else {
        board[tr + s][tc + s] = t;
        ChessBoard(tr + s, tc + s, tr + s, tc + s, s);
    }
}

int main() {
    int size = 8;
    ChessBoard(0, 0, 1, 1, size);
    for (int i = 0; i < size; ++i) {
        for (int j = 0; j < size; ++j) {
            cout << board[i][j] << "  ";
        }
        cout << endl;
    }
}
```

## 循环日程表

> **符合分治策略的思想**，将所有的选手分为两半，n个选手的比赛日程就可以通过分成n/2个选手设计的比赛日程表来决定。采用递归的方式对选手进行割分，直至割分到只剩下1位选手时，比赛日程表就不在需要为其排列。
>
> **边界条件：**n = 1
>
> **分解子问题：**
>
> 1.递归左上角赛程表
>
> 2.递归左下角赛程表
>
> 3.将左上角赛程表copy到右下角
>
> 4.将左下角赛程表copy到右上角

``` c
//循环日程表
void table(int arr[maxNum][maxNum], int y, int len) {
    if (len == 1) {
        arr[0][y] = y + 1;//第0行
        return;
    }
    table(arr, y, len / 2);//左上
    table(arr, y + len / 2, len / 2);//右上
//    上面分治会把 其余的值 赋好 下面等着复制就行
    for (int i = 0; i < len / 2; ++i) {
        for (int j = 0; j < len / 2; ++j) {
            arr[len / 2 + i][y + len / 2 + j] = arr[i][y + j];//左上到右下
            arr[len / 2 + i][y + j] = arr[i][y + len / 2 + j];//右上 复制到左下
        }
    }
}
```

## 逆序对数

> **逆序对**是指在一个数组中，如果存在一对元素 (i, j)，其中 i < j 但 arr[i] > arr[j]，则称这对元素为一个逆序对。在归并排序的过程中，我们可以在合并两个有序子数组时高效地计算出逆序对的数量。
>
> 1. **分割**：将数组分成两个大致相等的部分。
> 2. **递归求解**：递归地在每个部分中计算逆序对的数量。
> 3. **合并**：在合并两个有序子数组的过程中，统计跨过中间点的逆序对数量。
> 4. **累加结果**：将各个部分的逆序对数量累加起来，得到整个数组的逆序对总数

``` c
using namespace std;
int sum = 0;
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            sum += mid - i + 1;// 左边比右边大 出现 逆序对求逆序对-------------------------------
        temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k = 0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}

void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left, right);
}
```

## 矩阵连乘

> 找到一个计算多个矩阵连乘的最优顺序，使得总的乘法次数最少。使用二维数组 `m` 来存储子问题的解，并使用另一个二维数组 `s` 来记录最优分割点，以便最后可以构造出最优解。
>
> ### 动态规划的思想
>
> 1. **定义子问题**：令 `m[i][j]` 表示从第 `i` 个矩阵到第 `j` 个矩阵的最小乘法次数。
> 2. **状态转移方程**：
>    - 如果 `i == j`，那么只有一个矩阵，不需要做任何乘法，所以 `m[i][i] = 0`。
>    - 如果 `i < j`，则考虑所有可能的分割点 `k`（`i <= k < j`），将矩阵链分成两部分 `A[i...k]` 和 `A[k+1...j]`，并计算这两部分的乘法次数加上合并这两部分的乘法次数。选择使总乘法次数最小的 `k` 作为最优分割点。
>    - 具体的状态转移方程为： m[i][j]=min⁡i≤k][k]+m[k+1][j]+pi−1×pk×pj)*m*[*i*][*j*]=min*i*≤*k*<*j*(*m*[*i*][*k*]+*m*[*k*+1][*j*]+*p**i*−1×*p**k*×*p**j*) 其中 `p` 是一个数组，表示每个矩阵的维度。`p_{i-1}` 是第 `i` 个矩阵的行数，`p_k` 是第 `k` 个矩阵的列数，也是第 `k+1` 个矩阵的行数，`p_j` 是第 `j` 个矩阵的列数。
> 3. **边界条件**：当 `i == j` 时，`m[i][j] = 0`，因为单个矩阵不需要进行乘法操作。
> 4. **确定子链长度**：从最短的子链（长度为2）开始，逐渐增加子链的长度，直到覆盖整个矩阵链。
> 5. **确定起点和终点**：对于每个子链长度，枚举所有可能的起点 `i` 和对应的终点 `j`。
> 6. **选择分割点**：在每个子链中，尝试所有可能的分割点 `k`，将子链分成两部分 `A[i...k]` 和 `A[k+1...j]`，并计算这两部分的乘法次数加上合并这两部分的乘法次数。
> 7. **更新最优解**：在所有可能的分割点 `k` 中，选择使得总乘法次数最小的那个 `k`，并将这个最小值记录到 `dp[i][j]` 中。
>
> 1. **matrixMultiply 函数**：
>    - 对于单个矩阵的情况，`dp[i][i] = 0`，因为单个矩阵不需要做任何乘法。
>    - 使用两层循环来处理不同长度的子链：
>      - 外层循环 `len` 表示当前考虑的子链长度。
>      - 内层循环 `i` 表示子链的起始位置。
>    - 计算 `j` 作为子链的结束位置。
>    - 初始化 `dp[i][j]` 为 `INT_MAX`，以便在后续比较中找到最小值。
>    - 使用内层循环 `k` 来尝试不同的分割点，并计算分割后的总乘法次数 `temp`。
>    - 更新 `dp[i][j]` 为 `temp` 的最小值。

``` c
int dp[10][10];
int n = 6;
int p[7] = {30, 35, 15, 5, 10, 20, 25};

void matrixMultiply() {
    for (int i = 1; i <= n; ++i)
        dp[i][i] = 0;//单个矩阵不需要乘法
    for (int len = 2; len <= n; ++len) {//len表示 要求连乘矩阵的长度
        for (int i = 1; i <= n - len + 1; ++i) {//i 为开始位置
            int j = i + len - 1;//j 结束位置
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {//p[i - 1] 是第 i 个矩阵的行数。
                dp[i][j] = min(dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j], dp[i][j]);//维护最小值 注意是加号
            }// p[k] 是第 k 个矩阵的列数（也是第 k+1 个矩阵的行数）。
        }//p[j] 是第 j 个矩阵的列数。
    }
}
```

## 最长公共子序列

> 1. **定义状态**：
>    - `dp[i][j]` 表示 `X` 的前 `i` 个字符和 `Y` 的前 `j` 个字符的最长公共子序列的长度。
> 2. **状态转移方程**：
>    - 如果 `X[i-1] == Y[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
>    - 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
> 3. **边界条件**：
>    - `dp[0][j] = 0`，`dp[i][0] = 0`。

``` c
char x[] = {'0', 'i', 'f', 'g', 'h', 'k', 'u'};
char y[] = {'0', 'e', 'h', 't', 'u'};//下标从1开始算 第一个不算入n
int sum = 0;
int n = 6, m = 4;
int dp[105][105];//dp i j a b
int LCS() {
    for (int i = 1; i <= n; ++i)   //设置边界
        dp[i][0] = 0;
    for (int i = 1; i <= m; ++i)
        dp[0][i] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (x[i] == y[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
}
```

## 最大连续字段和

> 1. **状态转移方程**：
>
>    - 对于每个 `i`，`dp[i]` 表示以 `arr[i]` 结尾的最大子段和。
>
>    - dp[i]
>
>      可以通过以下两种情况取最大值：
>
>      - 当前元素 `arr[i]` 自己作为一个新的子段。
>      - 当前元素 `arr[i]` 加上前一个子段的和 `dp[i-1]`。
>
> - `dp[i] = max(dp[i-1] + arr[i], arr[i])`。
> - `sum = max(sum, dp[i])`。

``` c
int sum = 0;
int arr[]={0,1,3,-2,4,-3,1};
int n=6;
int dp[25]={0};//dp i j a b
int MaxSub() {
    for (int i = 1; i <= n; ++i)
        dp[i]=arr[i];
    sum=dp[1];
    for (int i = 2; i <= n; ++i){
        dp[i]=max(arr[i],dp[i-1]+arr[i]);
        sum=max(dp[i],sum);
    }
}
```

## 01背包

> ### 动态规划思想
>
> 1. **定义状态**：
>    - `dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。
> 2. **状态转移方程**：
>    - 如果不选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j]`。
>    - 如果选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j-weights[i]] + values[i]`，前提是 `j >= weights[i]`。
>    - 综合起来，`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i]] + values[i])`。
> 3. **边界条件**：
>    - `dp[0][j] = 0` 对于所有 `j`，因为没有物品时，价值为 0。
>    - `dp[i][0] = 0` 对于所有 `i`，因为背包容量为 0 时，无法装入任何物品。
> 4. **最终结果**：
>    - `dp[n][capacity]` 即为所求的最大价值。

``` c
int w[] = {0, 2, 3, 4, 5};
int v[] = {0, 3, 4, 5, 6};//下标从1开始
int n = 4;//个数
int c = 5;//容量
int dp[11][11] = {0}; //`dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。

int knapsack() {
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= c; ++j) {
            if (w[i] <= j) {//可以放下
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);//放和不放 取价值最大
            } else {//放不下
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
}
```

## 路径问题

> ### 动态规划思想
>
> 1. **定义状态**：
>    - 用 `dp[i][j]` 表示从起点 (0, 0) 到达位置 (i, j) 的路径数。
> 2. **状态转移方程**：
>    - 如果当前位置 (i, j) 可以从上方 (i-1, j) 和左侧 (i, j-1) 到达，则 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
>    - 特殊情况：如果在第一行（i=0），则只能从左侧到达；如果在第一列（j=0），则只能从上方到达。
> 3. **边界条件**：
>    - 起点 (0, 0) 只有一种方式到达，即 `dp[0][0] = 1`。
>    - 第一行和第一列的每个位置都只有一种方式到达，即 `dp[0][j] = 1` 和 `dp[i][0] = 1`。
> 4. **最终结果**：
>    - `dp[N-1][M-1]` 即为从起点到终点的路径总数。

``` c
int n = 3;
int m = 3;
int dp[20][20];
int countPaths() {
    for (int i = 0; i < n; ++i){
        for (int j = 0; j <m ; ++j) {
            if (i==0 or j==0)//边界条件
                 dp[i][j]=1;
            else
                dp[i][j]= dp[i][j-1]+dp[i-1][j];//上来 + 左来
        }
    }
}
```

## 完全背包

> 1. **定义状态**：
>
>    - `dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。
>
> 2. **状态转移方程**：
>
>    - 如果不选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j]`。
>    - 如果选择第 `i` 个物品，并且 `j >= weights[i]`，则可以选择一次或多次，此时的价值为 `dp[i][j - weights[i]] + values[i]`。
>    - 因此，`dp[i][j] = max(dp[i-1][j], dp[i][j - weights[i]] + values[i])`。
>
> 3. **边界条件**：
>
>    - `dp[0][j] = 0` 对于所有 `j`，因为没有物品时，价值为 0。
>    - `dp[i][0] = 0` 对于所有 `i`，因为背包容量为 0 时，无法装入任何物品。
>
> 4. **最终结果**：
>
>    - `dp[n][capacity]` 即为所求的最大价值。
>
>    ### 为什么使用 `dp[i][j - weights[i-1]]` 而不是 `dp[i-1][j - weights[i-1]]`？
>
>    - 在 0/1 背包问题中，每个物品只能选择一次，因此使用 `dp[i-1][j - weights[i-1]]` 来表示不包含当前物品 `i` 的情况。
>    - 在完全背包问题中，每个物品可以选择多次，因此使用 `dp[i][j - weights[i-1]]` 来表示包含当前物品 `i` 的情况，这样可以继续在剩余容量中选择当前物品。

``` c
int n=3;
int w[] = {0,1, 3, 4};
int v[] = {0,15, 20, 30};
int c=6;
int dp[10][10];
int knapsack() {
    memset(dp,0,sizeof(dp));//初始化为0
    for (int i = 1; i <= n; ++i){
        for (int j = 1; j <=c ; ++j) {
            if (w[i]<=j)//放得下 放i 或者不放i
                 dp[i][j]= max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]);//可重复选 i=i 不能重复选i=i-1
            else
                dp[i][j]=dp[i-1][j];
        }
    }
}//60
```

## 合并石子

> 1. **定义状态**：
>    - `dp[i][j]` 表示将第 `i` 堆到第 `j` 堆石子合并成一堆的最小代价。
> 2. **状态转移方程**：
>    - 对于每一个区间 `[i, j]`，我们可以选择一个位置 `k`（`i <= k < j`），将 `[i, k]` 和 `[k+1, j]` 两部分先分别合并，然后再将这两部分合并。
>    - 因此，`dp[i][j] = min(dp[i][k] + dp[k+1][j] + pre[i][j])`，其中 `pre[i][j]` 表示从第 `i` 堆到第 `j` 堆石子的总数量。//左边 + 右边 加咱俩的代价
> 3. **边界条件**：
>    - `dp[i][i] = 0`，因为单个石子堆不需要合并。
>    - `pre[i][i] = stones[i]`，表示单个石子堆的数量。
> 4. **最终结果**：
>    - 不跨越环的情况可以通过直接计算 `dp[0][n-1]` 得到。
>    - 和矩阵连乘几乎一样
>    - - `i + len - 1 <= n` 确保区间的终点 `j` 不会超过数组的范围。
>      - `j = i + len - 1` 是区间的终点。
>      - 因此，`i + len - 1 <= n` 等价于 `i <= n - len + 1`。
>    - **改写后的写法**：
>      - `i <= n - len + 1` 直接确保了 `i` 的最大值不会超过 `n - len + 1`。
>      - 这样可以保证 `j = i + len - 1` 仍然在有效范围内。

``` c
int arr[] = {0, 3, 4, 3};//下标从1开始
int n = 3;
int pre[10];//前缀和数组
int dp[10][10];
//https://www.bilibili.com/video/BV1PG411H7sj/?spm_id_from=333.880.my_history.page.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int minCostToMergeStones() {
    for (int i = 1; i <= n; ++i)
        pre[i] = pre[i - 1] + arr[i];
    memset(dp, 0, sizeof(dp));//初始化0  单独1堆合并代价为
    for (int len = 2; len <= n; ++len) {//和矩阵连乘很像  最少两堆连乘
        for (int i = 1; i <= n-len+1; ++i) {//i 开始堆下标
            int j = i+len-1;//结束堆 下标
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + pre[j] - pre[i-1]);
            }
        }
    }
}

```

<img src="C:\Users\nvjiachengba\Desktop\851\file\复习文档.assets\image-20240930200525198.png" alt="image-20240930200525198" style="zoom: 50%;" />



## 最长递增子序列

> 1. **定义状态**：
>    - `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
> 2. **状态转移方程**：
>    - 对于每一个 `i`，我们需要检查所有 `j < i` 的位置，如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`。
>    - 如果没有这样的 `j`，则 `dp[i] = 1`，因为单个元素本身也是一个递增子序列。
> 3. **边界条件**：
>    - `dp[0] = 1`，因为单个元素本身就是一个递增子序列。
> 4. **最终结果**：
>    - `max(dp[0], dp[1], ..., dp[n-1])` 即为所求的最长递增子序列的长度。

``` c
int nums[] = {10, 9, 2, 5, 3, 7, 101, 18};
int n = 8;
int dp[20];
int maxLen=INT_MIN;

int lengthOfLIS(int *nums, int n) {
    if (n == 0) return 0;
    for (int i = 0; i < n; ++i)
        dp[i]=1;//初始化 最少包含自己 为1

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
            //满足升序
            dp[i]=max(dp[i],dp[j]+1);
            maxLen= max(maxLen,dp[i]);
            }
        }
    }
}
```

## 活动安排

> ### 问题描述
>
> 假设你有一组活动，每个活动都有一个开始时间和结束时间。这些活动需要使用同一资源（比如同一个会议室），并且在同一时间只能有一个活动使用该资源。你的任务是选出尽可能多的活动来安排，使得被选中的活动之间不会发生时间上的冲突。
>
> ### 解决思路
>
> 采用贪心策略。基本思想如下：
>
> 1. **排序**：首先按照活动的结束时间对所有活动进行升序排序。如果两个活动有相同的结束时间，则可以按开始时间排序。
> 2. **选择活动**：从最早结束的活动开始考虑，选择第一个活动加入集合。然后，对于剩下的活动，总是选择与当前已选活动集合中最后一个活动不冲突的第一个活动加入集合。
> 3. **重复步骤2**：持续执行步骤2直到遍历完所有的活动。
>
> 这种方法确保了在每一步都做出局部最优的选择，从而最终得到全局最优解。

``` c
typedef struct {
    int id;//活动的编号
    int start;//开始时间
    int finish;//结束时间
    int flag;//活动是否被选择
} Activity;
int sum=0;
//下标从1开始
Activity arr[] = {{0, 0, 0},
                         {1, 5, 9},
                         {2, 1, 2},
                         {3, 3, 4},
                         {4, 0, 6},
                         {5, 5, 7},
                         {6, 8, 9}};
int n = 6;
bool cmp(Activity a, Activity b) {
    return a.finish < b.finish; //结束时间早的排在前面
}

void fun() {
    sort(arr+1,arr+n, cmp);// 结束时间从小到大排序 cmp不需要括号
    int pre=1;//以第一个活动结束为开始
    arr[1].flag=1;
    sum++;
    for (int i = 2; i <= n; ++i){
        if (arr[pre].finish<=arr[i].start){//后一个活动开始时间 = 也可以晚于前一个结束时间 不冲突
            sum++;
            pre=i;
            arr[i].flag=1;
        }
    }
}
```

## 部分背包

>   其中每个物品可以被分割成任意小的部分。目标是在不超过背包容量的前提下，使得装入背包的物品总价值最大。这个问题可以通过贪心算法高效解决。
>
> ### 问题描述
>
> - **输入**：一组物品，每个物品有一个重量 `w` 和一个价值 `v`；一个背包，其最大承重为 `W`。
> - **输出**：选择哪些物品以及每种物品的数量，使得装入背包的物品总价值最大，且总重量不超过 `W`。
>
> ### 解决思路
>
> 1. **计算单位重量的价值**：对于每个物品，计算它的单位重量的价值，即 `value/weight`。
> 2. **排序**：根据单位重量的价值对所有物品进行降序排序。
> 3. **选择物品**：从单位重量价值最高的物品开始，尽可能多地选取该物品，直到不能完全放入下一个物品为止。然后继续选择下一个单位重量价值次高的物品，重复此过程，直到背包满或所有物品都已考虑。

``` c
typedef struct {
    int id;//可以不用这题
    int v;
    int w;
} goods;
goods arr[] = {{0, 0,   0,},
               {1, 60,  10},
               {2, 100, 20},
               {3, 120, 30}};
int c = 50;
int n = 3;
int sum = 0;

bool cmp(goods a, goods b) {//根据价值的平均价值 从高到低进行排序
    return a.v / a.w > b.v / b.w;
}

void fractionalKnapsack() {
    for (int i = 1; i <= n; ++i) {
        if (c >= arr[i].w) {//可全部放下
            sum += arr[i].v;
            c -= arr[i].w;
        } else {//部分可放下
            sum += c * (arr[i].v / arr[i].w);
            return;
        }
    }
}
```

## 简单装载

> 最优装载问题（也称为简单装载问题）是背包问题的一种特殊情况，其中每个物品的重量不同，但价值相同。目标是在不超过给定重量限制的情况下，装入尽可能多的物品。这个问题可以通过贪心算法高效解决。
>
> ### 问题描述
>
> - **输入**：一组物品，每个物品有一个重量 `w`；一个船或容器的最大承重为 `W`。
> - **输出**：选择哪些物品，使得装入的物品数量最多，且总重量不超过 `W`。
>
> ### 解决思路
>
> 1. **排序**：按照物品的重量从小到大进行排序。
> 2. **选择物品**：从最轻的物品开始，依次选择物品放入船或容器中，直到不能再装入更多物品为止。

``` c
typedef struct {
    int id;
    int w;//重量
    int flag;//是否选取
} container;
container arr[] = {{0, 0},
                   {1, 5},
                   {2, 3},
                   {3, 4},
                   {4, 2}};
int n = 4;
int c = 10;//容量
int sum = 0;
bool cmp(container a, container b) {//重量从小到大 排序
    return a.w < b.w;
}

void optimalLoading() {
    sort(arr + 1, arr + n, cmp);
    for (int i = 1; i <= n; ++i) {
        if (c >= arr[i].w) {
            arr[i].flag = 1;
            c -= arr[i].w;
            sum++;
        }
    }
}

```

## Dijkstra

> ### Dijkstra算法思想
>
> 1. **初始化**：
>    - 为每个顶点设置一个距离值（`dist`），表示从源顶点到该顶点的最短路径长度。初始时，源顶点的距离设为0，其他所有顶点的距离设为无穷大（表示尚未找到路径）。
>    - 创建一个集合`S`，用于存储已经确定最短路径的顶点。初始时，`S`为空。
> 2. **选择当前距离最小的顶点**：
>    - 从未处理的顶点中选择一个距离最小的顶点`u`，将其加入集合`S`中。这意味着我们已经找到了从源顶点到`u`的最短路径。
> 3. **更新邻接顶点的距离**：
>    - 对于顶点`u`的所有邻接顶点`v`，如果通过`u`到达`v`的路径比当前已知的从源顶点到`v`的路径更短，则更新`v`的距离值。
> 4. **重复步骤2和3**：
>    - 重复上述过程，直到所有顶点都被加入集合`S`中，或者没有更多的顶点可以更新为止。
>
> - **初始化**：设置初始距离和路径。
> - **选择最小距离顶点**：从未处理的顶点中选择距离最小的顶点。
> - **更新距离**：更新通过该顶点到达其他顶点的距离。
> - **重复**：重复上述过程直到所有顶点都被处理

``` c
typedef struct {
    int edges[25][25];
    int vexNum;
    int arcNum;
} MGraph;

int visited[25] = {0};//是否访问
int path[25];   // 原点v到顶点i的前一个顶点
int dist[25];          // 源点到各个顶点的距离

void Dijkstra(MGraph *g, int v) {
    for (int i = 0; i < g->vexNum; ++i) {//初始化判断是否有边
        dist[i] = g->edges[v][i];
        if (g->edges[v][i] < INT_MAX) {
            path[i] = v;//前一个顶点
        } else {
            path[i] = -1;
        }
    }
    visited[v] = 1;//标记源顶点已访问
    dist[v] = 0;
    path[v] = -1;

    for (int i = 1; i < g->vexNum; ++i) {//选择未处理顶点中距离最小的顶点
        int minn = INT_MAX;//最小值
        int minVex;//最小值下标
        for (int j = 0; j < g->vexNum; ++j) {
            if (dist[j] < minn and visited[j] == 0) {
                minn = dist[j];
                minVex = j;//找到最小值
            }
        }
        visited[minVex] = 1;

        for (int j = 0; j < g->vexNum; ++j) {//更新邻接顶点的距离：
            if (visited[j] == 0 and dist[j] > dist[minVex] + g->edges[minVex][j]) {   //以为 minVex 为中介 更近
                dist[j] = dist[minVex] + g->edges[minVex][j];
                path[j] = minVex;
            }
        }
    }
}
```

### prime

> Prim 算法是一种用于找到加权无向图的最小生成树（Minimum Spanning Tree, MST）的贪心算法。其主要思想是从一个起始顶点开始，逐步扩展生成树，直到包含图中的所有顶点。每一步都选择当前未加入生成树的顶点中与生成树相连的边权重最小的那个顶点，并将其加入生成树。
>
> ### 代码的思想
>
> 1. **初始化**：
>    - `sum` 用于存储最小生成树的总权重。
>    - `visited` 数组用于标记顶点是否已经被加入到MST中。
>    - `lowcost` 数组用于存储从已加入MST的顶点到未加入MST的顶点的最小边权重。
> 2. **选择起点**：
>    - 将起始顶点 `v` 标记为已访问。
>    - 初始化 `lowcost` 数组，将起始顶点到其他顶点的距离赋值给 `lowcost` 数组，如果不存在直接连接的边，则设置为无穷大（`INT_MAX`）。
> 3. **迭代过程**：
>    - 执行 `g->vexNum - 1` 次循环，每次选择一个顶点加入MST。
>    - 在每次循环中，找到 `lowcost` 数组中最小的值 `minn` 及其对应的顶点 `k`。
>    - 将 `minn` 加入 `sum`，并将顶点 `k` 标记为已访问。
>    - 更新 `lowcost` 数组，检查新加入的顶点 `k` 到其他未访问顶点的边权重，如果这些边的权重小于 `lowcost` 中的值，则更新 `lowcost`。
> 4. **输出结果**：
>    - 最后输出最小生成树的总权重 `sum`。

``` c
typedef struct {
    int edges[25][25];
    int vexNum;
    int arcNum;
} MGraph;

void prime(MGraph *g, int v) {
    int sum = 0;
    int visited[25];
    int lowcost[25];
    for (int i = 1; i < g->vexNum; ++i) {
        lowcost[i] = g->edges[v][i];//候选边初始化
        visited[i] = 0;
    }

    visited[v] = 1;//起点
    int j, k;
    for (int i = 1; i < g->vexNum; ++i) {//执行n-1次
        int minn = INT_MAX;
        for (j = 1; j < g->vexNum; j++) {//寻找最小值
            if (lowcost[j] < minn and visited[j] == 0) {
                minn = lowcost[i];// 更新最小边权重
                k = j;//最小权值顶点
            }
        }
        sum += minn;
        visited[k] = 1;

        for (int j = 1; j <= g->vexNum; ++j) {//维护候选中的最小值
            if (visited[j] == 0 and g->edges[k][j] < lowcost[j])//未被访问，且最新的顶点到j的距离比原来近
                lowcost[j] = g->edges[k][j]; //更新
        }
    }
    printf("minn:%d", sum);
}
```

### Kruskal

> 1. ### **定义结构体**：
>    
>    - `Edge` 结构体用于表示图中的边，包含两个顶点 `vex1` 和 `vex2` 以及边的权重 `weight`。
>    - `MGraph` 结构体用于表示图，包含顶点数 `vexNum`、边数 `EdgeNum` 和边表 `edges`。
> 2. **比较函数**：
>    - `cmp` 函数用于对边进行排序，按边的权重从小到大排序。
> 3. **并查集操作**：
>    - `Initial` 函数初始化并查集，使每个顶点的父节点指向自己。
>    - `getRoot` 函数查找顶点的根节点。
>    - `isSameRoot` 函数检查两个顶点是否属于同一个集合。
>    - `merge` 函数合并两个集合。
> 4. **Kruskal 算法**：
>    - `Kruskal` 函数实现了克鲁斯卡尔算法，计算最小生成树的总权重。
>    - 初始化并查集。
>    - 对边进行排序。
>    - 依次选择每条边，如果边的两个顶点不在同一个集合中，则加入 MST 并合并这两个顶点所在的集合。
>    - 当生成树中的边数达到 `vexNum - 1` 时，算法结束。
>    - 如果图不连通，返回 -1 并打印提示信息。

``` c
#define ElemType char
#define MAX_COST 0x7fffffff
const int MAX_SIZE = 23; // 最大容量

// 定义边的结构体
typedef struct Edge {
    int vex1, vex2; // 边所依附的两个顶点
    int weight;     // 权值
} Edge;

// 定义图的结构体
typedef struct {
    int vexNum;     // 顶点数
    int EdgeNum;    // 边数
    Edge edges[MAX_SIZE]; // 边表
} MGraph;

// 比较函数，用于 qsort 排序
bool cmp(const Edge &a, const Edge &b) {
    return a.weight < b.weight;
}

// 初始化并查集
void Initial(int roots[], int n) {
    for (int i = 0; i < n; ++i) {
        roots[i] = i; // 默认自己是自己的父节点
    }
}

// 查找父节点，即根节点
int getRoot(int roots[], int x) {
    while (roots[x] != x) 
        x = roots[x];
    return x;
}

// 检查两个顶点是否属于同一个集合
bool isSameRoot(int roots[], int x1, int x2) {
    return getRoot(roots, x1) == getRoot(roots, x2);
}

// 合并两个集合
void merge(int roots[], int x1, int x2) {
    int s1 = getRoot(roots, x1);
    int s2 = getRoot(roots, x2);
    if (s1 != s2) 
        roots[s1] = s2;
   
}

// Kruskal 算法
int Kruskal(MGraph *g) {
    int sum = 0; // 初始化总权重
    int edgeNum = g->EdgeNum;
    int vexNum = g->vexNum;
    int count = 0;
    int roots[g->vexNum]; // 并查集
    Initial(roots, vexNum); // 初始化并查集

    // 对边进行排序
    sort(g->edges, g->edges + edgeNum, cmp);

    for (int i = 0; i < edgeNum; ++i) {
        if (!isSameRoot(roots, g->edges[i].vex1, g->edges[i].vex2)) {// 如果两个顶点不在同一个集合中
            sum += g->edges[i].weight;
            printf("Edge %d-%d with weight %d is included in MST\n", g->edges[i].vex1, g->edges[i].vex2, g->edges[i].weight);
            merge(roots, g->edges[i].vex1, g->edges[i].vex2);
            count++; // 生成树的边数+1
            if (count == vexNum - 1)
                break; // 达到生成树完成构造
        }
    }

    if (count == vexNum - 1) {
        printf("Total weight of the Minimum Spanning Tree: %d\n", sum);
        return sum;
    } else {
        printf("The graph is not connected, cannot form a Minimum Spanning Tree.\n");
        return -1; // 图不连通
    }
}

```

### HuffmanTree

> 1. **定义结构体**：
>    - `HTNode` 结构体表示哈夫曼树的节点，包含四个字段：`weight`（权重）、`parent`（父节点索引）、`left`（左子节点索引）和 `right`（右子节点索引）。
>    - `HuffmanTree` 是一个类型别名，用于表示哈夫曼树的数组。
>    - `HuffManCode` 是一个类型别名，用于存储哈夫曼编码串的头指针数组。
> 2. **函数定义**：
>    - `Select`：选择两个最小的结点，这两个结点的 `parent` 为 0（即它们还没有被合并）。
>    - `CreateHuffmanTree`：初始化哈夫曼树的节点，并通过不断选择两个最小的结点来构建哈夫曼树。
> 3. 初始化哈夫曼树的节点，设置初始权重、父节点、左子节点和右子节点。
> 4. 计算非叶子节点的数量 `m`。
> 5. 初始化非叶子节点。
> 6. 通过不断选择两个最小的结点并合并它们来构建哈夫曼树。
> 7. 每次合并时，创建一个新的内部节点，其权重为两个最小结点的权重之和，并更新相关节点的 `parent`、`left` 和 `right` 字段。

``` c
const int N = 20;//叶子结点的最大值
#define M 2*N-1 //所有结点数量的最大值
using namespace std;
typedef struct {
    int weight;
    int parent;
    int left;
    int right;
} HTNode, HuffmanTree[M + 1];//0号不用

void Select(HuffmanTree ht, int n, int &s1, int &s2) {
    //选择最小的结点 parent=0 赋值给s1 s2
    int i, min1 = INT_MAX, min2 = INT_MAX;
    s1 = 0;
    s2 = 0;
    for (int i = 1; i <= n; ++i) {
        if (ht[i].parent == 0) {
            //是根结点 就是下面包含叶子
            if (ht[i].weight < min1) {
           
                min2 = min1; //比min1小
                s2 = s1;
                min1 = ht[i].weight;
                s1 = i;//min1 最小  min2 次小
            } else if (ht[i].weight < min2) {
                min2 = ht[i].weight;
                s2 = i;//比min2 小
            }
        }
    }
}

void CreateHuffmanTree(HuffmanTree ht, int w[], int n) {
    //w  要构造的那些结点 比如 13  57 23 4
    int i;
    for (int i = 1; i <= n; ++i) {
        ht[i].weight = w[i - 1];//丢到1-n
        ht[i].parent = 0;
        ht[i].left = 0;
        ht[i].right = 0;
    }
    int m = 2 * n - 1;// 实际 所有结点
    for (i = n + 1; i <= m; ++i) {//n+1 -m 存放非叶子结点 初始化
        ht[i].weight = 0;//丢到1-n
        ht[i].parent = 0;
        ht[i].left = 0;
        ht[i].right = 0;
    }
    //初始完毕 创建非叶节点
    int s1, s2;
    for (i = n + 1; i <= m; ++i) {
        Select(ht, i - 1, s1, s2);//每次选出2个最小的结点 切parent为0 也就是根结点不是叶结点
        ht[i].weight = ht[s1].weight + ht[s2].weight;
        ht[s1].parent = i;
        ht[s2].parent = i;
        ht[i].left = s1;//左边更小
        ht[i].right = s2;
    }
}

```

## 回溯

### 排列树&&子集树

> ### 1. 排列树（Permutation Tree）
>
> 排列树通过固定一个位置，然后递归地对剩余的位置进行全排列。每次递归调用时，交换当前元素与后续元素的位置，以生成不同的排列。
>
> ### 2. 子集树（Subset Tree）
>
> 子集树通过选择或不选择某个元素来生成所有可能的排列。这种方法通常使用一个布尔数组 `used` 来标记哪些元素已经被使用过。
>
> #### 排列树
>
> 1. **函数 `permute`**：
>    - 输入参数是数组 `arr`、起始位置 `start` 和结束位置 `end`。
>    - 如果 `start` 等于 `end`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
>    - 否则，通过一个循环遍历从 `start` 到 `end` 的每个位置，将 `start` 位置的元素与当前位置的元素交换，然后递归调用 `permute` 生成下一个位置的排列。
>    - 在递归调用返回后，再次交换回来以恢复原始数组状态，以便进行下一次交换。
>
> #### 子集树
>
> 1. **函数 `permuteSubsetTree`**：
>    - 输入参数是数组 `arr`、数组长度 `n`、当前结果数组 `result`、当前处理的位置 `pos` 和标记数组 `used`。
>    - 如果 `pos` 等于 `n`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
>    - 否则，通过一个循环遍历数组中的每个元素，如果该元素没有被使用过，则将其标记为已使用，加入到 `result` 中，然后递归调用 `permuteSubsetTree` 生成下一个位置的排列。
>    - 在递归调用返回后，将该元素从 `result` 中移除，并将其标记为未使用，以便进行下一次选择。
>
> ### 总结
>
> - **排列树**：通过交换数组中的元素来生成所有可能的排列。每次递归调用时，固定一个位置，然后递归地对剩余的位置进行全排列。
> - **子集树**：通过选择或不选择某个元素来生成所有可能的排列。这种方法通常使用一个布尔数组 `used` 来标记哪些元素已经被使用过。
>
> 这两种方法都能有效地生成数组的所有排列，选择哪种方法取决于具体的需求和偏好。排列树的方法在实现上较为直观，而子集树的方法则更符合回溯法的思路。

### 全排列

> **函数 `permute`**：
>
> - 输入参数是数组 `arr`、起始位置 `start` 和结束位置 `end`。
> - 如果 `start` 等于 `end`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
> - 否则，通过一个循环遍历从 `start` 到 `end` 的每个位置，将 `start` 位置的元素与当前位置的元素交换，然后递归调用 `permute` 生成下一个位置的排列。
> - 在递归调用返回后，再次交换回来以恢复原始数组状态，以便进行下一次交换。

``` c
//排序树
void dfs(int arr[], int n, int step) {//排列树
    if (step >= n)//一次排序结束
        print(arr, n);
    else {
        for (int i = step; i < n; ++i) {//从step 开始 0开始
            swap(arr[step], arr[i]);
            dfs(arr, n, step+1);
            swap(arr[step], arr[i]);
        }
    }
}
```

> **函数 `permuteSubsetTree`**：
>
> - 输入参数是数组 `arr`、数组长度 `n`、当前结果数组 `result`、当前处理的位置 `pos` 和标记数组 `used`。
> - 如果 `pos` 等于 `n`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
> - 否则，通过一个循环遍历数组中的每个元素，如果该元素没有被使用过，则将其标记为已使用，加入到 `result` 中，然后递归调用 `permuteSubsetTree` 生成下一个位置的排列。
> - 在递归调用返回后，将该元素从 `result` 中移除，并将其标记为未使用，以便进行下一次选择。

``` c
//子集树
void permuteSubsetTree(int arr[], int result[], int n, int vis[], int step) {//子集树
    if (step >=n) { // 递归终止条件
        print(result, n);
    } else {
        for (int i = 0; i < n; ++i) {
            if (vis[i] == 0) { // 如果当前元素未被使用
                result[step] = arr[i]; // 将当前元素放入结果数组
                vis[i] = 1; // 标记当前元素已被使用
                permuteSubsetTree(arr, result, n, vis, step + 1); // 递归调用
                vis[i] = 0; // 回溯，取消标记
            }
        }
    }
}
```



### 简单装载(回溯)

> 1. **全局变量**：
>    - `w` 数组存储了每个物品的重量，注意数组下标从1开始。
>    - `n` 表示物品的数量。
>    - `c` 表示背包的容量。
>    - `maxw` 用于记录当前找到的最大重量。
>    - `x` 数组用于记录最优解，即哪些物品被选中。
> 2. **函数 `dfs`**：
>    - 输入参数包括当前步骤 `step`、当前重量 `cw`、剩余重量 `rw` 和当前选择方案 `op`。
>    - 如果 `step > n`，表示已经处理完所有物品，到达了一个叶节点。
>      - 如果当前重量 `cw` 大于 `maxw`，则更新 `maxw` 并将当前选择方案 `op` 复制到 `x` 中。
>    - 否则，继续处理当前物品：
>      - 如果当前重量加上当前物品的重量不超过背包容量 `c`，则选择当前物品，并递归调用 `dfs` 处理下一个物品。
>      - 不选择当前物品，并递归调用 `dfs` 继续处理当前物品（回溯）。

``` c
//子集树
int w[] = {0, 5, 2, 6, 4, 3}; // 物品重量 下标从1开始
int n = 5; // 物品数量
int c = 10; // 背包容量
int maxw = 0; // 最大重量
int x[6]; // 记录最优解

void dfs(int step, int cw, int rw, int op[]) {
    if (step > n) {//找到一个叶节点
        if (cw > maxw) {
            maxw=cw;
            for (int i = 1; i <= n; ++i)
                x[i] = op[i];//复制更优解
        }
    } else {//继续找
        if (cw + w[step] <= c) {
            op[step] = 1;//选取第i个
            dfs(step + 1, cw + w[step], rw - w[step], op);
        }
        if (cw + rw - w[step] > maxw) {//当前重量+剩余重量还有可能超过 最大值
            op[step] = 0;//不选回溯 -w[step]  否则剪枝
            dfs(step+1, cw, rw - w[step], op);
        }
    }
}
```

### 复杂装载

> 目标是将集装箱分配到两个轮船上，使得第一个轮船的总重量最大化，并且第二个轮船能够装下剩余的所有集装箱。你使用了深度优先搜索（DFS）来找到第一个轮船的最优解，并通过 `solve` 函数检查第二个轮船是否能够装下剩余的集装箱。
>
> 1. **初始化**：
>    - 定义集装箱的重量数组 `w`。
>    - 定义两艘船的最大载重量 `c1` 和 `c2`。
>    - 初始化全局变量 `maxw` 用于记录第一艘船的最大载重量。
>    - 初始化数组 `x` 用于记录第一艘船的最优解向量。
> 2. **深度优先搜索（DFS）**：
>    - 递归函数 `dfs` 尝试所有可能的集装箱组合。
>    - 如果当前步骤 `step` 超过集装箱数量 `n`，则到达叶节点，更新最大载重量 `maxw` 并记录当前解。
>    - 否则，继续处理当前集装箱：
>      - 如果当前重量加上当前集装箱的重量不超过 `c1`，则选择当前集装箱，并递归调用 `dfs` 处理下一个集装箱。
>      - 如果当前重量加上剩余重量减去当前集装箱的重量仍然有可能超过 `maxw`，则不选择当前集装箱，并递归调用 `dfs` 继续处理当前集装箱（回溯）。
> 3. **检查剩余集装箱**：
>    - 函数 `solve` 计算第一艘船装完后剩余的集装箱总重量 `sum`。
>    - 检查 `sum` 是否小于等于 `c2`，即第二艘船能否装下剩余的集装箱。
>
> 1. **第一艘船尽可能多装**：
>    - 使用深度优先搜索（DFS）来尝试所有可能的集装箱组合，找到一种使得第一艘船装载重量最大的方案。
>    - 在递归过程中，通过选择或不选择当前集装箱来生成所有可能的解，并使用剪枝技术来减少不必要的递归调用。
> 2. **检查剩余集装箱是否能被第二艘船装下**：
>    - 一旦找到了第一艘船的最大载重量方案，计算剩余未被选中的集装箱总重量。
>    - 检查这些剩余集装箱的总重量是否不超过第二艘船的最大载重量 `c2`。
>    - 如果第二艘船能够装下所有剩余的集装箱，则找到了一个可行的解决方案；否则，没有可行的解决方案。

``` c
//子集树
#define MAXN 20 // 最多集装箱个数
int w[] = {0, 10, 40, 40}; // 各集装箱重量, 不用下标 0 的元素
int n = 3; // 集装箱数量
int c1 = 50, c2 = 50; // 两艘轮船的最大载重量
int maxw = 0; // 存放第一艘轮船最优解的总重量
int x[MAXN]; // 存放第一艘轮船最优解向量

//将所有集装箱都装上船 由于集装箱必需整体装入 所以不能贪心
void dfs(int step, int cw, int rw, int op[]) //求第一艘轮船的最优解
{
    if (step > n) {
        if (cw > maxw) {
            for (int i = 1; i <= n; ++i) {
                x[i] = op[i];
                maxw = cw;
            }
        }
    } else {//继续找更小重量
        if (cw + w[step] <=c1) {//没超重
            cw + w[step];
            op[step] = 1;
            dfs(step + 1, cw + w[step], rw - w[step], op);
        }
        if (cw + rw - w[step] > maxw) {//还有机会装更多 剪枝
            op[step] = 0;
            dfs(step + 1, cw, rw - w[step], op);
        }
    }
}

bool solve()//求解复杂装载问题
{   int sum = 0; //累计第一艘轮船装完后剩余的集装箱重量
    for (int j = 1; j <= n; j++)
        if (x[j] == 0)
            sum += w[j];
    if (sum <= c2)//第二艘轮船可以装完
        return true;
    else//第二艘轮船不能装完
        return false;
}
```

### 01背包(回溯)

> ### 算法思想
>
> 回溯的思想，尝试每一种可能的物品组合，然后根据约束条件（不超过背包容量）和目标（最大化价值）来筛选出最优解。
>
> - 函数逻辑：
>   - 如果 `step > n`，意味着所有物品都已经考虑过了。此时检查当前背包的总价值 `cv` 是否大于已知的最大价值 `maxv`。如果是，则更新 `maxv` 并将当前选择状态 `op[]` 复制到 `x[]` 中。
>   - 如果可以放入当前物品（`cw + w[step] <= c`），则选择该物品并递归调用 `dfs` 来处理下一个物品。
>   - 即使当前物品不被选中，如果后续物品的价值加上当前价值还有可能超过已知的最大价值（`cv + rv - v[step] > maxv`），那么也递归调用 `dfs` 来处理下一个物品而不选当前物品。
>
> - **优化剪枝**:
>   - 通过条件 `if (cv + rv - v[step] > maxv)` 来进行剪枝，避免不必要的递归调用。这个条件确保只有当后续有可能找到更好的解时才继续探索。
>
> 

``` c
int n = 4;  // 物品数量
int c = 10;  // 背包最大容量
int w[] = {0, 2, 3, 4, 5};//下标从1开始
int v[] = {0, 3, 4, 5, 6};
int maxv = 0; // 存放第一艘轮船最优解的总重量
int x[21]; // 存放第一艘轮船最优解向量

void dfs(int step, int cw, int cv, int rv, int op[]) {
    if (step > n) {
        if (cv > maxv) {
            for (int i = 1; i <= n; ++i) {
                x[i] = op[i];
                maxv = cv;
            }
        }
    } else {
        if (cw + w[step] <= c) {//放得下
            op[step] = 1;
            dfs(step+1, cw + w[step], cv + v[step], rv - v[step], op);
        }
        if (cv + rv - v[step] > maxv) {//还有机会更大
            op[step] = 0;
            dfs(step+1, cw, cv, rv - v[step], op);
        }
    }
}
```

### N皇后

###

> #### 全局变量
>
> - `const int N = 8;`：定义了棋盘的大小，这里假设是8皇后问题。
> - `int q[N + 1];`：数组`q`用于存储每一行皇后的列位置。`q[i]`表示第`i`行的皇后位于第`q[i]`列。
>
> #### 函数 `place(int i, int j)`
>
> - **功能**：测试在位置 `(i, j)` 上是否可以放置皇后。
> - 参数：
>   - `i`：当前考虑的行号。
>   - `j`：当前考虑的列号。
> - 逻辑：
>   - 如果是第一行（`i == 1`），则总是可以放置皇后，因为此时没有其他皇后。
>   - 对于其他行，检查之前已经放置的所有皇后（从第1行到第i-1行）。
>     - 检查是否有任何已放置的皇后与当前位置 `(i, j)` 在同一列，即 `q[k] == j`。
>     - 检查是否有任何已放置的皇后与当前位置 `(i, j)` 在同一条对角线上，即 `abs(q[k] - j) == abs(i - k)`。
>   - 如果发现冲突，则返回 `false` 表示不能在此位置放置皇后。
>   - 如果没有发现冲突，循环结束后返回 `true` 表示可以在该位置放置皇后。
>
> #### 函数 `queen(int i, int n)`
>
> - **功能**：递归地尝试在第`i`行到第`n`行放置皇后。
> - 参数：
>   - `i`：当前考虑的行号。
>   - `n`：棋盘的大小（也是需要放置的皇后数量）。
> - 逻辑：
>   - 如果 `i > n`，说明已经成功放置了所有的皇后，调用 `dispasolution(n)` 来输出当前解决方案。
>   - 否则，对于第i行的每一个列j（从1到n），尝试放置皇后。
>     - 调用 `place(i, j)` 来检查是否可以在 `(i, j)` 位置放置皇后。
>     - 如果可以放置，则将 `q[i]` 设置为 `j`，表示在第`i`行的第`j`列放置皇后。
>     - 递归调用 `queen(i + 1, n)` 来尝试放置下一行的皇后。
>   - 如果在当前行的所有列都尝试过且无法放置皇后，则回溯到上一行重新选择。
>
> ### 算法思想
>
> 1. **递归与回溯**：
>    - 使用递归来尝试每一种可能的皇后放置方式。
>    - 当发现当前路径不可行时（即不能在某一行找到合适的位置放置皇后），通过回溯回到上一步，尝试另一种可能性。
> 2. **约束传播**：
>    - 在每次尝试放置皇后时，通过 `place` 函数检查当前放置是否会违反规则（同行、同列、对角线）。
>    - 只有当不违反规则时，才会继续递归下去。
> 3. **剪枝**：
>    - 通过提前检测冲突来减少不必要的递归调用。如果发现某个位置不能放置皇后，就不再继续尝试该位置。
> 4. **解决方案收集**：
>    - 当所有皇后都被成功放置后，调用 `dispasolution(n)` 来输出当前的解决方案。

``` c
const int N = 8; // 假设我们要解决的是8皇后问题
int q[N + 1]; // 用于存储每行皇后的列位置

// 测试(i, j)位置能否摆放皇后
bool place(int i, int j) {
    if (i == 1) return true; // 第一个皇后总是可以放置
    for (int k = 1; k < i; ++k) { // k=1～i-1 是已放置了皇后的行
        if ((q[k] == j) || (abs(q[k] - j) == abs(i - k))) {//qk=j列冲突
            return false;
        }
    }
    return true;
}
// 放置 1～i 的皇后
void queen(int i, int n) {
    if (i > n) {
        dispasolution(n); // 所有皇后放置结束
    } else {
        for (int j = 1; j <= n; ++j) { // 在第 i 行上试探每一个列 j
            if (place(i, j)) { // 在第 i 行上找到一个合适位置(i, j) 
                q[i] = j;
                queen(i + 1, n);
            }
        }
    }
}

```

### 流水作业调度(批处理)

>
>
><img src="C:\Users\nvjiachengba\Desktop\851\file\复习文档.assets\image-20241008203441595-1728390885753-1.png" alt="image-20241008203441595" style="zoom:50%;" />

> 1. **初始化**：
>
>    - 初始化 `bestx` 和 `x` 数组，用于存储最优解和当前解的作业顺序。
>    - 初始化 `f1` 和 `f2` 数组，用于记录当前的完成时间和每个节点的完成时间。
>    - 初始化 `bestf` 为 `INT_MAX`，表示当前最优解的完成时间。
>
> 2. **深度优先搜索 (DFS) 函数 `dfs(int i)`**：
>
>    - **边界条件**：如果到达叶节点（即 `i > n`），则检查当前完成时间 `f2[n]` 是否优于最优解 `bestf`。如果是，则更新 `bestf` 并将当前解 `x` 复制到 `bestx` 中。
>
>    - **继续搜索**：对于当前层 `i`，尝试将 `i` 位置的作业与后续位置的作业交换，然后递归地进行下一层搜索。
>
>    - 更新完成时间
>
>      ：在每次交换后，更新f1 和f2
>
>      - `f1 += m1[x[i]]`：更新当前在第一台机器上的完成时间。
>      - `f2[i] = max(f1, f2[i - 1] + m2[x[i]])`：计算当前节点的完成时间。`f2[i]` 是 `f1` 和 `f2[i - 1] + m2[x[i]]` 中的较大值，确保了作业在第二台机器上的完成时间不会早于第一台机器。
>
>    - **剪枝**：如果当前节点的完成时间 `f2[i]` 已经大于或等于最优解的完成时间 `bestf`，则不需要继续搜索。
>
>    - 回溯：恢复原来的作业顺序和完成时间，以便尝试其他可能的作业顺序。
>
>      - `f1 -= m1[x[i]]`：回溯 `f1`。
>      - `swap(x[i], x[j])`：恢复原来的作业顺序。

``` c

int n = 4;
int m1[] = {0, 5, 12, 4, 8};  // 下标从1开始
int m2[] = {0, 6, 2, 14, 7};  // 下标从1开始
int bestx[11];  // 最优解组
int x[11];  // 临时解组
int f1 = 0;  // 当前在m1上的完成时间
int f2[11];  // 每个节点的完成时间
int bestf = INT_MAX;  // 最优解的完成时间

void dfs(int i) {
    if (i > n) {  // 到达叶节点
        if (f2[n] < bestf) {
            bestf = f2[n];
            for (int j = 1; j <= n; ++j) {
                bestx[j] = x[j];//x[1]=3 第一个任务是3
            }
        }
    } else {  // 继续找
        for (int j = i; j <= n; ++j) {
            swap(x[i], x[j]);  // 交换作业顺序
            f1 += m1[x[i]];  // 更新当前在m1上的完成时间
            f2[i] = max(f1, f2[i - 1] + m2[x[i]]);  // 计算当前节点的完成时间
            // 限界函数：如果当前节点的完成时间已经大于或等于最优解，直接剪枝
            //f2[i] 表示前 i 个作业的总完成时间。我们可以在每次递归调用 dfs(i + 1) 之前，
            // 检查当前的 f2[i] 是否已经大于或等于已知的最优解 bestf。如果是，则不需要继续搜索这个分支。
            if (f2[i] < bestf) {  // 剪枝
                dfs(i + 1);
            }
            f1 -= m1[x[i]];  // 回溯
            swap(x[i], x[j]);  // 恢复原来的顺序
        }
    }
}
```





## 

> 查找结点：e循环遍历链表，直到找到值为 x 的结点或到达链表末尾。
> 更新访问频度：如果找到了结点，则增加其 freq 域的值。
> 检查是否需要移动：如果结点已经是头结点（即 p->pred == L）或者它的频度小于等于前驱结点的频度，则不需要移动。
> 从当前链表中移除结点：更新前驱和后继结点的指针，以从链表中移除该结点。
> 找到插入位置：遍历链表，找到合适的位置，使得插入后的链表仍然按访问频度非增排序。
> 插入结点：将结点插入到找到的位置，并更新相关指针。

``` c


DNode *Locate(DLinkList L, int x) {// Locate 函数：查找值为 x 的结点并更新访问频度
    DNode *p = L->next;
    DNode *pre = L;

    // 查找结点
    while (p != NULL && p->data != x)
        p = p->next;

    if (p == NULL)
        return NULL; // 没有找到值为 x 的结点

    // 更新访问频度
    p->freq++;
    // 如果 p 是头结点或者已经是最高频度，不需要移动
    if (p->pre == L || (p->freq <= p->pre->freq))
        return p;

    // 从当前链表中移除结点
    p->pre->next = p->next;
    if (p->next != NULL)
        p->next->pre = p->pre;

    // 找到插入位置
    pre = L;
    while (pre->next != NULL && (pre->next->freq > p->freq || (pre->next->freq == p->freq && pre->next->next != NULL)))
        pre = pre->next;

    p->next = pre->next; // 插入结点
    p->pre = pre;
    if (pre->next != NULL)
        pre->next->pre = p;
    pre->next = p;
    return p;
}
```

## 线性表

### 插入结点 将元素插入到表的第i个位置上

> 

``` c
int insertElem(LinkList &list, int i, int e) {//将元素e 插入到第i个位置上
    if (i < 1)
        return 0;
    int cnt = 0;
    LNode *p = list;
    while (p != NULL and cnt < i - 1) {
        p = p->next;
        cnt++;//找到相应位置插入
    }

    if (p == NULL) //循环结束 判断插入位置是否合法
        return 0;
    //成功找到 进行插入操作
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return 1;
}
```

### 删除第一个值为key的元素

> 算法思想:1.若链表非空，遍历链表找寻结点
>
> ​        2.若找到结点不为空则进行删除，反之则退出

``` c
void deleteFirstByValue(LinkList &list, int x) {//将元素e 插入到第i个位置上
    if (list == NULL) {
        cout << "list is NULL" << endl;
        return;
    }
    LNode *p = list->next;
    LNode *pre = list;
    while (p != NULL and p->data != x) {//查找第一个值为x的结点
        pre = p;
        p = p->next;
    }
    if (p == NULL) {
        cout << "this is no element that you want to find" << endl;
        return;
    }
    //找到元素
    pre->next = p->next;
    free(p);//释放结点
}
```

### Frequent

> *设有头指针的双向链表，其每个结点中除有**pre(**前驱指针**)**、**data(**数据**)**和**next(**后继指针**)**域外，
> **还有一个访问频度域在链表被启用前，其值均初始化为零。
> **每当在链表中进行一次**Locate(L.x)**运算时，令元素值为**x**的结点中**frea**域的值增**1**，并**freg**。
> **使此链表中结点保持按访问频度非增**(**递减**)**的顺序排列，同时最近访问的结点排在频度相同的结点前面，
> **以便使频繁访问的结点总是靠近表头。
> **试编写符合上述要求的**Locate(L,x)**运算的算法，该运算为函数过程，返回找到结点的地址，类型为指*型



> 思想
>
> - **查找结点**：从头结点的下一个节点开始查找值为 `x` 的结点。
>
> - **更新访问频度**：如果找到该结点，将其访问频度加1。
>
> - **判断是否需要移动**：如果该结点已经是最高频度或其前驱节点的频度大于等于当前结点的频度，则不需要移动。
>
> - **从链表中移除结点**：将找到的结点从当前链表中移除。
>
> - 找到插入位置
>
>   ：遍历链表，找到合适的插入位置。新的插入位置应该满足以下条件：
>
>   - 新位置的频度大于当前结点的频度。
>   - 如果频度相同，新位置应该是第一个频度相同的结点之后的位置。
>
> - **插入结点**：将找到的结点插入到合适的位置。

``` c
typedef struct DNode {
    int data;
    struct DNode *pre, *next;
    int freq;
} DNode, *DLinkList;
DNode *Locate(DLinkList L, int x) {// Locate 函数：查找值为 x 的结点并更新访问频度
    DNode *p = L->next;
    DNode *pre = L;

    // 查找结点
    while (p != NULL && p->data != x)
        p = p->next;

    if (p == NULL)
        return NULL; // 没有找到值为 x 的结点

    // 更新访问频度
    p->freq++;
    // 如果 p 是头结点或者已经是最高频度，不需要移动
    if (p->pre == L || (p->freq <= p->pre->freq))
        return p;

    // 从当前链表中移除结点
    p->pre->next = p->next;
    if (p->next != NULL)
        p->next->pre = p->pre;

    // 找到插入位置
    pre = L;
    while (pre->next != NULL && (pre->next->freq >p->freq ))
        pre = pre->next;

    p->next = pre->next; // 插入结点
    p->pre = pre;
    if (pre->next != NULL)
        pre->next->pre = p;
    pre->next = p;
    return p;
}

```



## 单链表

### 建表(头插)

> - **创建头结点**：初始化一个头结点 `list`，并将 `next` 指针设置为 `NULL`。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的头部。
> - **更新指针**：确保新结点的 `next` 指针指向当前头结点的 `next`，然后更新头结点的 `next` 指针指向新结点。

``` c
// 使用头插法创建链表
void createByHead(LinkList &list, int arr[], int n) {
    list = new LNode; // 创建头结点
    list->next = NULL; // 头结点的 next 指向 NULL
    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        LNode *s = new LNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        s->next = list->next; // 新结点的 next 指向当前头结点的 next
        list->next = s; // 头结点的 next 指向新结点
    }
}
```

### 建表(尾插)

> - **创建头结点**：初始化一个头结点 `list`，并将 `next` 指针设置为 `NULL`。
>- **初始化尾指针**：初始时 `rear` 指向头结点。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的尾部。
> - **更新尾指针**：每次插入新结点后，更新 `rear` 指针，使其指向新结点。
> - **设置最后一个结点的 `next` 指针**：在循环结束后，确保最后一个结点的 `next` 指针指向 `NULL`。

``` c
void createByTail(LinkList &list, int arr[], int n) {
    list = new LNode; // 创建头结点
    list->next = NULL; // 头结点的 next 指向 NULL
    LNode *rear = list; // 初始时 rear 指向头结点

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        LNode *s = new LNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        rear->next = s; // 将新结点连接到当前尾结点的后面
        rear = s; // 更新尾结点为新结点
    }
    rear->next = NULL; // 最后一个结点的 next 指向 NULL
}
```

## 双链表

### 建表(头插)

> - **创建头结点**：初始化一个头结点 `head`，并将 `next` 和 `prior` 指针设置为 `NULL`。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的头部。
> - 更新指针：
>   - 新结点的 `next` 指针指向当前头结点的 `next`。
>   - 如果头结点的 `next` 不为空，则更新 `head->next` 的 `prior` 指针，使其指向新结点 `s`。
>   - 新结点的 `prior` 指针指向头结点 `head`。
>   - 更新头结点 `head` 的 `next` 指针，使其指向新结点 `s`。

``` c
// 使用头插法创建双向链表
void createDListByHead(DLinkList &head, int arr[], int n) {
    head = new DNode; // 创建头结点
    head->next = NULL; // 头结点的 next 指向 NULL
    head->prior = NULL; // 头结点的 prior 指向 NULL

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        DNode *s = new DNode;
        s->data = arr[i]; // 设置新结点的数据
        s->next = head->next; // 新结点的 next 指向当前头结点的 next
        if (head->next != NULL) { // 如果头结点后面有数据
            head->next->prior = s; // 修改后继结点的前驱指针
        }
        s->prior = head; // 新结点的前驱指针指向头结点
        head->next = s; // 头结点的 next 指向新结点
    }
}
```

### 建表(尾插)

> - **创建头结点**：初始化一个头结点 `head`，并将 `next` 和 `prior` 指针设置为 `NULL`。
> - **初始化尾指针**：初始时 `rear` 指向头结点。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的尾部。
> - 更新指针：
>   - 新结点的 `next` 指针设置为 `NULL`（因为它是新的尾结点）。
>   - 新结点的 `prior` 指针指向当前尾结点 `rear`。
>   - 当前尾结点 `rear` 的 `next` 指针指向新结点 `s`。
>   - 更新 `rear` 指针，使其指向新结点 `s`。

``` c
// 使用尾插法创建双向链表
void createDListByTail(DLinkList &head, int arr[], int n) {
    head = new DNode; // 创建头结点
    head->next = NULL; // 头结点的 next 指向 NULL
    head->prior = NULL; // 头结点的 prior 指向 NULL
    DNode *rear = head; // 初始时 rear 指向头结点

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        DNode *s = new DNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        s->next = NULL; // 新结点的 next 指向 NULL
        s->prior = rear; // 新结点的前驱指针指向当前尾结点
        rear->next = s; // 当前尾结点的 next 指向新结点
        rear = s; // 更新尾结点为新结点
    }
}
```



### 插入结点

> 按位置插入 ，
>
>  找寻对应插入位置 若结点为空或者下标越界则代表插入位置错误
>
> 否则进行插入操作 并修改相应指针

``` c
bool InsertByPos(DLinkList &head, int n, int e) {
    if (head == NULL)
        return false;
    DNode *p = head->next;
    int i = 0;
    while (p != NULL and i < n - 1) {
        p = p->next;
        i++;//找寻插入位置
    }
    if (p == NULL)
        return false;

    DNode *s = new DNode;//插入 新建j结点
    s->data = e;
    s->next = p->next;
    if (p->next != NULL)//存在后继结点 则修改前驱指针
        p->next->prior = s;
    s->next = p;
    p->next = s;
    return true;
}
```

### 删除

> - **初始化检查**：确保链表不为空且有实际数据结点。
> - **查找删除位置**：使用 `while` 循环遍历链表，直到找到第 `n` 个位置。
> - **处理边界情况**：如果下标越界，返回 `false`。
> - 删除结点：
>   - 更新 `p` 的前驱结点的 `next` 指针。
>   - 更新 `p` 的 `next` 的 `prior` 指针（如果 `p` 的 `next` 不为空）。
>   - 释放 `p` 结点的内存。

``` c
bool deleteByPos(DLinkList &head, int n) {
    if (head == NULL)
        return false;
    DNode *p = head->next;
    int i = 1;
    // 循环找寻删除结点，如果下标越界或结点为空 返回
    while (p != NULL && i < n) {
        p = p->next;
        i++;
    }
    if (p == NULL) {
        return false; // 下标越界
    }
    // 进行删除操作
    p->prior->next = p->next;
    if (p->next != NULL) {
        p->next->prior = p->prior;
    }
    // 释放结点
    free(p);

    return true;
}
```

#### 双链表排序

> ### 代码思想
>
> 1. **初始化**：
>    - 定义指针 `p`、`pre` 和 `q`，其中 `p` 用于遍历链表，`pre` 用于找到插入位置，`q` 用于保存下一个待处理的节点。
> 2. **断开链表**：
>    - 将头结点的 `next` 指针设置为 `NULL`，这样可以将原来的链表断开，方便逐个处理每个节点。
> 3. **遍历并重新插入节点**：
>    - 使用 `p` 遍历链表中的每个节点。
>    - 对于每个节点 `p`，使用 `pre` 从头结点开始比较，找到第一个大于或等于 `p->data` 的节点的位置。
>    - 将 `p` 插入到 `pre` 和 `pre->next` 之间。
>    - 更新 `p` 的前驱和后继指针。
>    - 继续处理下一个节点 `q`。

``` c
typedef struct DNode {
    int data;
    struct DNode *prior, *next;
} *DLinkList;

void DLinkListSort(DLinkList &head) {//单链表递增排序
    if (head == nullptr || head->next == nullptr)
        return;
    DNode *p, *pre, *q;
    p=head->next->next;
    head->next->next=NULL;//重新插入  断开链表，只保留头结点
    while (p != NULL) {
        q = p->next;
        pre = head;//从开头开始比较  
        while (pre->next != NULL and pre->next->data < p->data)//找寻插入位置 即p pre,  pre.next.data>=p, p插入到 pre的后面
            pre = pre->next;
         // 插入到找到的位置
        p->next = pre->next;
        if (pre->next != NULL)//不等于调整
            pre->next->prior = p;
        pre->next = p;
        p->prior = pre;//pre和p是包调整的
        p = q;//接着扫描
    }
}

```



## 循环单链表

### 统计值为x的个数

> ⑴判断是否是空链表：head->next==head ;
>
> （2）判断是否是表尾结点： p->next==head ;

``` c
//循环单链表 统计表内值为x的个数
int countByValue(LinkList head, int x) {
    while (head->next == head or head==NULL)
        return -1;
    LNode *p = head->next;
    int count = 0;
    while (p != head) {
        if (p->data == x)
            count++;
        p = p->next;
    }
    return count;
}
```

## 循环双链表

> 1.链表中没有空指针域 
>
> 2.p所指结点为尾结点的条件：p->next==L 
>
> 3.一步操作即L->prior可以找到尾结点

### 删除第一个值为x



``` c
//删除循环双链表中 第一个值为x的结点
bool deleted(DLinkList head, int x) {
    if (head == NULL || head->next == head) {
        return -1; // 链表为空或只有一个头结点
    }
    DLNode *p = head->next;
    while (p != NULL and p->next != head and p->data!=x)
        p = p->next;
    if (p->data == x)//找到
    {
        p->next->prior = p->prior;
        p->prior->next = p->next;
        free(p);
        return true;
    }
    return false;
}
```

### 是否对称

> 初始化检查链表不为空
>
> 使用while遍历从两边向中间进行比较，若遇见左右值不相等直接返回
>
> 分别处理长度为奇数和偶数的情况

``` c 

//判断循环双链表 内部元素值 是否对称
bool check(DLinkList head) {
    if (head == NULL or head->next == head)
        return false;
    DLNode *left = head, *right = head->prior;//left之前头节点 right指向 尾结点
    while (left != right and left->next != right) { // 循环条件：left 和 right 不相遇且 left 的下一个结点不是 right
        if (left->data != right->data) {
            return false; // 如果左右结点的数据不相等，则返回 false
        }
        left = left->next; // 移动 left 指针到下一个结点
        right = right->prior; // 移动 right 指针到前一个结点
    }

    if (left == right) // 如果链表长度为偶数，最后 left 和 right 会相邻
        return true; // 单个中间结点，直接返回 true
    else
        return left->data == right->data; // 检查相邻的两个结点是否相等

}
```



## 线性表





### 合并有序数组

> 两个指针分别从两个数组 表头开始遍历，
>
> 每次从两个数组中各取一个元素比较，将较小的元素放置排序数组中
>
> 当其中一个遍历完成后，将剩余的元素加入排序数

``` c
void merge(int nums1[], int nums2[], int n, int m) {
    int p1 = 0, p2 = 0;
    int temp[25];

    int cur=0;//临时赋值数组的指针
    while (p1 < n and p2 < m) {
        if (nums1[p1] < nums2[p2])
            temp[cur++] = nums1[p1++];
        else
            temp[cur++] = nums2[p2++];
    }
    while (p1 < n)
        temp[cur++] = nums1[p1++];
    while (p2 < m)
        temp[cur++] = nums2[p2++];
    for (int i = 0; i < n + m; ++i) {
        nums1[i] = temp[i];
    }
}
```





### 删除值为k的值(数组)

> 思想：
>
>  从头开始遍历，并进行比较
>
>  若当前元素值等于x，则进行删除并将剩余元素进行移动
>
>  以此类推直至遍历结束 (注意边界条件)

``` c
// 删除数组中的重复元素
void removeDuplicates(int arr[], int n, int x) {
    int count = 0; // 用于记录需要移除的元素数量

    for (int i = 0; i < n - count; ++i) {
        if (arr[i] == x) {
            // 将当前元素之后的所有元素向前移动一位
            for (int j = i; j < n - count - 1; ++j) {
                arr[j] = arr[j + 1];
            }
            count++; // 增加计数器
            i--; // 由于删除了一个元素，需要重新检查当前位置
        }
    }
}
```



### 数组轮转

> 思路:
>
>   1.首先若k>n则对k取余
>
>   2.对右边 k个元素 进行反转，即(n-k ,n-1)
>
>   3.对左边 剩余元素 进行翻转，即（0 ，n-k-1)
>
> 4. 最后对整个数组进行翻转，即得到题目所要求的翻转数组

``` c

```



### 删除链表重复元素

> 算法思想:
>
>  1.使用库文件自带set<> 集合来记录是个否遇到重复元素
>
>  2.若数组非空对其进行遍历，遇到结点值进行判断
>
> ​    若set中包含此元素，则进行删除操作
>
> ​    反之则将其加入set中
>
>  3.以此类推，直至循环结束

``` c
// 删除单链表中重复出现的结点
void deletedLinkNodeByRepeat(LinkList head) {
    if (head == NULL || head->next == NULL) 
        return; // 链表为空或只有一个结点

    set<int> s; // 使用集合来记录已经遇到过的值
    LNode *pre = head;
    LNode *p = head->next;

    while (p != NULL) {
        if (s.find(p->data) == s.end()) { // 首次出现，非重复
            s.insert(p->data); // 将当前结点的数据加入集合
            pre = p;
            p = p->next;
        } else { // 重复出现的元素，进行删除
            pre->next = p->next; // 更新前驱结点的 next 指针
            free(p); // 释放当前结点的内存
            p = pre->next; // 更新 p 指针
        }
    }
}
```

### 是否有环

> 1. **初始化**：
>    - 初始化两个指针 `slow` 和 `fast`，都指向链表的头节点。
>    - `slow` 指针每次移动一步，`fast` 指针每次移动两步。
> 2. **环检测**：
>    - 在链表上移动这两个指针。
>    - 如果链表中存在环，那么快指针最终会追上慢指针，即 `slow == fast`。
>    - 如果 `fast` 或 `fast->next` 变成 `NULL`，则说明链表没有环。
> 3. **找到环的入口**：
>    - 一旦发现环，将 `fast` 指针重新指向链表头部，而 `slow` 保持在相遇点。
>    - 然后同时移动 `slow` 和 `fast`，每次各移动一步。
>    - 当 `slow` 和 `fast` 再次相遇时，它们所在的节点就是环的入口。

``` c
x// 检测单链表是否存在环，并找到环入口
LNode *check(LinkList head) {
    if (head == NULL || head->next == NULL)
        return NULL; // 如果链表为空或只有一个节点，则不可能有环

    LNode *slow = head; // 慢指针
    LNode *fast = head; // 快指针

    // 使用快慢指针遍历链表
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;          // 慢指针每次走一步
        fast = fast->next->next;    // 快指针每次走两步
        if (slow == fast) {         // 如果相遇，则存在环
            cout << "There is a circle." << endl;
            break;
        }
    }

    if (fast == NULL || fast->next == NULL)   // 如果没有环
        return NULL;
    // 找到环的入口
    fast = head; // 将快指针移回到链表头
    while (slow != fast) { // 当两个指针相等时，即为环的入口
        slow = slow->next;
        fast = fast->next;
    }

    return slow; // 返回环的入口
}
```

#### 法二

> 思想:
>
>   1.在链表结构体中加入变量vis，判断是否该节点被访问
>
>   2.每次进行判当前结点vis是否为1，
>
> ​      Ⅰ.若不为1则代表未访问,将其置1
>
> ​      Ⅱ.若为1则代表有环 ，且该节点为环的入口

``` c 
//检测单链表是否存在环，若有并找到环入口
LNode *check(LinkList head) {
    if (head == NULL or head->next == NULL)
        return NULL;
    LNode *p = head->next;
    while (p != NULL) {
        if (p->vis == 1)//有环且找到 环的入口
            return p;
        else //无环 将其vis置1
            p->vis = 1;
        p = p->next;
    }
    return NULL;
}
```



## 栈(stack)

>栈
>
>- 只能再一丢按进行插入或者删除的，操作受限的线性表
>
>- 允许操作的一端称为栈顶，另一端称为栈底
>
>- 没有元素时即为空栈
>
>  特点：
>
>  先进后出

### 顺序栈

> 定义：利用一组地址连续的单元一次存放栈底到栈顶的元素

``` c
//顺序栈
#define  MAXSIZE 4
struct SeqStack {
    int data[MAXSIZE];
    int top;//栈顶指针 此处下标从-1开始
};

bool empty(SeqStack s) {
    return s.top == -1;
}

bool full(SeqStack s) {
    return s.top == MAXSIZE - 1;
}

bool push(SeqStack &s, int x) {
    if (full(s))//栈满
        return false;
    s.data[++s.top] = x;// 先增加栈顶指针，然后将值存入
    return true;
}

bool pop(SeqStack &s, int &x) {//通过形参返回
    if (empty(s))
        return false;
    x = s.data[s.top--];//先取栈顶元素，然后减少栈顶指针
    return true;
}

void initStack(SeqStack &s) {
    s.top = -1; // 初始时栈顶指针为 -1，表示栈为空
}


```

### 链栈

``` c
//链栈
#define  MAXSIZE 4
typedef struct LNode {
    int data;
    struct LNode *next;
} *LinkStack;

bool empty(LinkStack &s) {
    return s->next == NULL;
}

// 入栈操作
bool push(LinkStack &s, int x) {
    LNode *p = new LNode;
    p->data = x;
    p->next = s->next; // 新节点的 next 指向原来的头结点的 next
    s->next = p; // 更新头结点的 next 为新节点
    return true;
}

// 出栈操作
bool pop(LinkStack &s, int &x) {
    if (empty(s))
        return false;
    LNode *p = s->next; // 临时指针指向要删除的节点
    x = p->data; // 保存要删除节点的数据
    s->next = p->next; // 更新头结点的 next 指针
    free(p); // 释放删除的节点
    return true;
}

```

### 共享栈

``` c
//共享栈
#define  MAXSIZE 4
struct SeqStack {
    int data[MAXSIZE];
    int top1, top2;//栈顶指针 此处下标从-1开始 top2从maxsize开始往前
};
// 检查栈1是否为空
bool empty1(SeqStack s) {
    return s.top1 == -1;
//    return s.top2 == MAXSIZE;
    
}

// 检查共享栈是否为空
bool empty(SeqStack s) {
    return empty1(s) && empty2(s);
}

// 检查共享栈是否已满
bool full(SeqStack s) {
    return s.top1 + 1 == s.top2;
}

// 栈1入栈操作
bool push1(SeqStack *s, int x) {
    if (full(*s)) {// 栈满
        return false;
        s->data[++s->top1] = x; // 先增加栈顶指针，然后将值存入
        return true;
    }

// 栈2入栈操作
    bool push2(SeqStack *s, int x) {
        if (full(*s))  // 栈满
            return false;
        s->data[--s->top2] = x; // 先减少栈顶指针，然后将值存入
        return true;
    }

// 栈1出栈操作
    bool pop1(SeqStack *s, int *x) { // 通过形参返回
        if (empty1(*s))
            return false;
        *x = s->data[s->top1--]; // 先取栈顶元素，然后减少栈顶指针
        return true;
    }

```

### 括号匹配(链栈)

>思想:
>
>- 对待匹配数组进行遍历，依次取出元素判断
>- 若c=='(' 则进行入栈
>- 若c==')' 则进行判断
>  - 如果栈顶元素不等于'(' 则返回false 结束循环
>  - 反之 则继续判断直至循环结束
>- 循环结束判断，栈是否为空，若包含元素则匹配失败
>
>  

``` c
//括号匹配
bool match(char arr[], int n) {
    char c;
    LinkStack st;
    initStack(st);
    for (int i = 0; i < n; ++i) {
        if (arr[i] == '(') {
            push(st, '(');
        } else if (arr[i] == ')') {
            if (pop(st, c) == '(') {
                continue;
            } else {
                clearStack(st);
                return false; // 括号不匹配
            }
        }
    }
    bool result = empty(st);
    clearStack(st);
    return result;
}
```

### 中缀转后缀

> ### 基本思想
>
> 1. **扫描中缀表达式**：从左到右依次扫描每个字符。
> 2. **数字直接输出**：如果遇到操作数（数字），直接将其输出到后缀表达式中。
> 3. **操作符入栈**：如果遇到操作符（如 `+`, `-`, `*`, `/`），根据其优先级和栈顶元素的优先级决定是否将栈顶的操作符出栈并输出，然后再将当前操作符入栈。
> 4. **左括号入栈**：如果遇到左括号 `(`，直接将其入栈。
> 5. **右括号处理**：如果遇到右括号 `)`，则将栈中的操作符依次出栈并输出，直到遇到左括号 `(` 为止。左括号 `(` 不输出。
> 6. **清空栈**：当整个中缀表达式扫描完毕后，将栈中剩余的操作符依次出栈并输出。
>
> ### 详细步骤
>
> 1. **初始化一个空栈**，用于存储操作符。
>
> 2. **初始化一个空字符串**，用于存储后缀表达式。
>
> 3. 从左到右扫描中缀表达式
>
>    ：
>
>    - **如果是操作数**（数字或变量），直接将其添加到后缀表达式中。
>    - **如果是左括号 `(`**，将其压入栈中。
>    - **如果是右括号 `)`**，将栈中的操作符依次弹出并添加到后缀表达式中，直到遇到左括号 `(` 为止。左括号 `(` 弹出但不添加到后缀表达式中。
>    - 如果是运算符
>      - 如果栈为空，或者栈顶是左括号 `(`，或者当前运算符的优先级大于栈顶运算符的优先级，则将当前运算符压入栈中。
>      - 否则，将栈顶运算符弹出并添加到后缀表达式中，然后再次比较当前运算符与新的栈顶运算符的优先级，重复上述过程，直到满足条件再将当前运算符压入栈中。
>
> 4. **当扫描完中缀表达式后**，将栈中剩余的所有运算符依次弹出并添加到后缀表达式中。

``` c 
int getPriority(char ch) {
    if (ch == '+' || ch == '-') {
        return 1;
    } else if (ch == '*' || ch == '/') {
        return 2;
    }
}

void InfixToSuffix(string infix, stack<char> &s2) {
    stack<char> s1;
    int i = 0;
    while (i < infix.length()) {
        if (isdigit(infix[i])) {
            s2.push(infix[i++]);  // 将数字压入栈
        } else if (infix[i] == '(') {  // 左括号
            s1.push(infix[i++]);
        } else if (infix[i] == '+' || infix[i] == '-' || infix[i] == '*' || infix[i] == '/') {  // 运算符
            while (!s1.empty() && s1.top() != '(' and getPriority(infix[i]) <= getPriority(s1.top())) {
                s2.push(s1.top());
                s1.pop();
            }
            s1.push(infix[i++]);
        } else if (infix[i] == ')') {  // 右括号
            while (s1.top() != '(') {
                s2.push(s1.top());
                s1.pop();
            }
            s1.pop();  // 弹出左括号
            i++;
        } else {
            i++;  // 忽略其他字符（如空格）
        }
    }

    while (!s1.empty()) {
        s2.push(s1.top());
        s1.pop();
    }
}

int main() {
    string str = "8+(3-1)*5*3";
    stack<char> s2;
    InfixToSuffix(str, s2);

    // 输出后缀表达式
    stack<char> tempStack;
    while (!s2.empty()) {
        tempStack.push(s2.top());
        s2.pop();
    }

    while (!tempStack.empty()) {
        cout << tempStack.top() << " ";
        tempStack.pop();
    }

    return 0;
}
```



## 队列(Queue)

>定义 ： 
>
>• 是一种操作受限的线性表。 
>
>• 只允许在表的一端进行插入，称为队尾。 
>
>• 在变的另一端进行删除，称为队头。 
>
>特点： 先进先出

### 顺序栈

>顺序队列(sequential queue) ： 
>
>• 采用顺序存储结构的队列称为顺序队列。 
>
>• 指的是用一组地址连续的存储单元依次存储自队尾至队头的数据元素

``` c
typedef struct QNode {
    int data[MAXSIZE];//下标-1开始
    int front, rear;
} *SeqQueue;

bool push(SeqQueue &q, int x) {
    if (q->rear == MAXSIZE - 1)
        return false;
    q->data[++q->rear] = x;
    return true;
}

bool pop(SeqQueue &q, int &x) {
    if (q->front == q->rear)
        return false;
    x = q->data[++q->front];
    return true;
}
// 检查队列是否为空
bool isEmpty(SeqQueue q) {
    return q->front == q->rear;
}

// 检查队列是否已满
bool isFull(SeqQueue q) {
    return (q->rear + 1) % MAXSIZE == q->front;
}

```

### 循环队列

>判断队满 队空
>
>- 增加length表示元素个数
>- 两给一个空间 队空: front==rear,队满: (rear+1)%MAXSIZE == front
>- 增设flag，flag=1,front==rear 表示满，flag=0 表示空

``` c


typedef struct QNode {
    int data[MAXSIZE];//下标-1开始
    int front, rear;
} *cirQueue; //循环队列


bool push(cirQueue &q, int &x) {
    if (q->front == (q->rear + 1) % MAXSIZE)
        return false;

    // 尾指针先自增，然后在新的位置插入数据
    q->rear = (q->rear + 1) % MAXSIZE;
    q->data[q->rear] = x;
    return true;
}

bool pop(cirQueue &q, int &x) {
    if (q->front == q->rear)
        return false;
    // 如果队列变空，重置 front 和 rear
    if (q->front == (q->rear + 1) % MAXSIZE) {
        q->front = -1;
        q->rear = -1;
    }
    return true;
}
```

### 链队

``` c
struct QNode {
    int data;
    struct QNode *next;
};
typedef struct {
    QNode *front, *rear;
} *LinkQueue;


bool push(LinkQueue &q, int x) {
    QNode *s = new QNode;
    s->data = x;
    s->next = NULL;
    if (q->rear == NULL)
        q->front = q->rear = s;
    else
        q->rear->next = s;
    return true;
}

bool pop(LinkQueue &q, int &x) {
    if (q->front == q->rear)
        return false;
    x = q->front->next->data;
    q->front = q->front->next;
    return true;

}
```

### 循环报数

``` c

int arr[] = {1, 2, 3, 4, 5, 6, 7, 8};
int n = 8;

void fun() {
    queue<int> q1, q2;
    for (int i = 0; i < n; ++i)
        q1.push(arr[i]);
    while (!q1.empty() or !q2.empty()) {
        bool flag = false;// false =1 ,true=2
        while (!q1.empty()) {
            if (flag == false)
                cout << q1.front() << " ";
            else
                q2.push(q1.front());
            q1.pop();
            flag = !flag;
        }
        flag = false;
        while (!q2.empty()) {
            if (flag == false)
                cout << q2.front() << " ";
            else
                q1.push(q2.front());
            q2.pop();
            flag = !flag;
        }
    }
}
```

### 循环单链表删除最小值

>设有一个带头结点的循环单链表，其节点值均为正整数，设计一个算法，反复找出单链表中节点值最小的结点并输出，然后将 该结点从中删除，直到单链表空为止，再删除表头结点

``` c

void LoopListDeleteMinimum(LinkList &head) {
    if (head == nullptr || head->next == head)
        return;  // 如果链表为空或只有一个节点，直接返回
    //不断删除最小结点
    while (head->next != head) {
        LNode *minp = head->next;
        LNode *minpre = head;
        LNode *pre = head;
        LNode *p = head->next->next;
        while (p != head) {//循环一遍找最小值
            if (p->data < minp->data) {
                minpre = pre;
                minp = p;
            }
            pre = p;
            p = p->next;
        }
        minpre->next = minp->next;
        free(minp);
    }
    free(head);

}
```



## 栈

>a

``` c

```

## 栈

>a

## 10-9

### 二叉树定义 求sum

> 写出二叉树的定义
>
> 答: 二叉树是一种特殊的树，每个结点至多有2个孩子结点，
>
>    除根结点外每个结点都有一个唯一的父节点。
>
>    孩子有左右之分，不可颠倒。
>
>    子节点也具有相同特性。

>   递归的基本思想
>
> - 是从根节点开始，逐步向下遍历每个节点，并检查是否存在一条路径满足条件。
>
> - 每次递归调用时，我们将当前节点的值从 `sum` 中减去，并将剩余的 `sum` 传递给子节点。
> - 如果到达叶子节点且剩余的 `sum` 正好为 0，则说明找到了一条满足条件的路径返回`true`。
> - 如果在某个节点处，剩余的 `sum` 不为 0 且该节点没有子节点，则返回 `false`。
> - 
> - - **递归调用**：对于非叶子节点，递归地检查左子树和右子树。每次递归调用时，将 `sum` 减去当前节点的值，并将剩余的 `sum` 传递给子节点。
>   - **合并结果**：如果左子树或右子树中存在一条路径满足条件，则返回 `true`；否则返回 `false`。
>
> 



``` c
// 判断是否存在从根节点到叶子节点的路径，使得路径上的节点值之和等于 sum
bool hasPathSum(BiTree T, int sum) {
    // 如果当前节点为空，返回 false
    if (T == NULL)
        return false;
    // 如果当前节点是叶子节点，检查其值是否等于剩余的 sum
    if (T->left == NULL and T->right == NULL) {
        return T->data == sum;
    }
    // 递归检查左子树和右子树
    return hasPathSum(T->left,  sum - T->data) or hasPathSum(T->right,  sum - T->data);
}

```





 ### kruskal

> ### Kruskal算法思想
>
> Kruskal算法是一种贪心算法，其基本思想是：
>
> 1. **初始化**：
>    - 将所有边按权重从小到大排序。
>    - 初始化一个并查集（Union-Find），每个顶点自成一个集合。
> 2. **选择边**：
>    - 从权重最小的边开始，依次检查每条边。
>    - 如果这条边连接的两个顶点不在同一个集合中，则将这条边加入最小生成树，并将这两个顶点所在的集合合并。
>    - 如果这条边连接的两个顶点已经在同一个集合中，则跳过这条边。
> 3. **终止条件**：
>    - 当选中的边数等于顶点数减一时，最小生成树构建完成。

``` c

// 定义边的结构体
typedef struct Edge {
    int vex1, vex2; // 边所依附的两个顶点
    int weight;     // 权值
} Edge;

// 定义图的结构体
typedef struct {
    int vexNum;     // 顶点数
    int EdgeNum;    // 边数
    Edge edges[MAX_SIZE]; // 边表
} MGraph;

// 比较函数，用于 qsort 排序
bool cmp(const Edge &a, const Edge &b) {
    return a.weight < b.weight;
}

// 初始化并查集
void Initial(int roots[], int n) {
    for (int i = 0; i < n; ++i) {
        roots[i] = i; // 默认自己是自己的父节点
    }
}

// 查找父节点，即根节点
int getRoot(int roots[], int x) {
    while (roots[x] != x) {
        x = roots[x];
    }
    return x;
}

// 检查两个顶点是否属于同一个集合
bool isSameRoot(int roots[], int x1, int x2) {
    return getRoot(roots, x1) == getRoot(roots, x2);
}

// 合并两个集合
void merge(int roots[], int x1, int x2) {
    int s1 = getRoot(roots, x1);
    int s2 = getRoot(roots, x2);
    if (s1 != s2) {
        roots[s1] = s2;
    }
}

// Kruskal 算法
int Kruskal(MGraph *g) {
    int sum = 0; // 初始化总权重
    int edgeNum = g->EdgeNum;
    int vexNum = g->vexNum;
    int count = 0;
    int roots[g->vexNum]; // 并查集
    Initial(roots, vexNum); // 初始化并查集

    // 对边进行排序
    sort(g->edges, g->edges + edgeNum, cmp);

    for (int i = 0; i < edgeNum; ++i) {
        if (!isSameRoot(roots, g->edges[i].vex1, g->edges[i].vex2)) {
            // 如果两个顶点不在同一个集合中
            sum += g->edges[i].weight;
            printf("Edge %d-%d with weight %d is included in MST\n", g->edges[i].vex1, g->edges[i].vex2, g->edges[i].weight);
            merge(roots, g->edges[i].vex1, g->edges[i].vex2);
            count++; // 生成树的边数+1
            if (count == vexNum - 1) {
                // 达到生成树完成构造
                break;
            }
        }
    }

    if (count == vexNum - 1) {
        printf("Total weight of the Minimum Spanning Tree: %d\n", sum);
        return sum;
    } else {
        printf("The graph is not connected, cannot form a Minimum Spanning Tree.\n");
        return -1; // 图不连通
    }
}
```





### 插入排序(数组)

> 插入排序（Insertion Sort）是一种简单直观的排序算法，其基本思想是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上通常使用原地排序（即只需要用到O(1)的额外空间），因此空间复杂度较低。
>
> ### 算法思想
>
> 1. **初始状态**：假设第一个元素已经是有序的。
> 2. **遍历数组**：从第二个元素开始，依次将每个元素插入到前面已经排好序的部分中。
> 3. 插入过程
>    - 取出当前元素，与前面已经排好序的元素进行比较。
>    - 如果当前元素小于前一个元素，则将前一个元素向后移动一位。
>    - 重复上述步骤，直到找到当前元素应该插入的位置。
>    - 将当前元素插入到正确的位置。

``` c
void insertSort(int arr[], int n) {
    for (int i = 1; i < n; ++i) {
        if (arr[i] < arr[i - 1]) {//如果小于前一个元素，才向前找插入位置
            int temp = arr[i];
            int j;
            for (j = i - 1; j >= 0 and arr[j] > temp; j--) //检查前面所有元素
                arr[j + 1] = arr[j];//比temp大的后移
            arr[j + 1] = temp;
        }
    }
}
```

### 插排(单链表)

> 单链表插入排序（Insertion Sort for Singly Linked List）的基本思想与数组的插入排序类似，都是通过逐步构建有序序列，将每个新节点插入到已排序部分的正确位置。下面是单链表插入排序的详细算法思想：
>
> ### 算法思想
>
> 1. **初始状态**：
>
>    - 假设第一个节点已经是有序的。从第二个节点开始，依次将每个节点插入到前面已经排好序的部分中。
>
> 2. **遍历待排序节点**：
>
>    - 从第二个节点开始，遍历整个链表。每次取出一个待排序节点，称为 `current` 节点。
>
> 3. **找到插入位置**：
>
>    - 从头结点开始遍历已排序部分，找到 `current` 节点应该插入的位置。
>    - 插入位置是已排序部分中最后一个数据小于 `current` 节点数据的位置。
>
> 4. **插入节点**：
>
>    - 将 `current` 节点插入到找到的插入位置之后。更新指针
>
> 5. **继续处理下一个待排序节点**：
>
>    

``` c
void InsertSort(LinkList head) {
    if (!head || !head->next) return; // 如果链表为空或只有一个节点，直接返回

    LNode *p = head->next;
    p->next = NULL; // 初始有序链表只有第一个节点
    LNode *q = head->next->next; // 当前待排序节点
    head->next = NULL; // 断开已排序部分和待排序部分
    while (q) {
        LNode *nextNode = q->next; // 暂存下一个待排序节点
        LNode *insertPos = head; // 从头开始遍历有序链表，找到插入位置

        // 找到合适的插入位置
        while (insertPos->next && insertPos->next->data < q->data) {
            insertPos = insertPos->next;//往后找
        }
        // 插入节点
        q->next = insertPos->next;
        insertPos->next = q;

        q = nextNode; // 移动到下一个待排序节点
    }
}
```

### 二叉树是否对称

>算法思想：
>
>**定义镜像对称**：
>
>- 两棵树互为镜像对称，当且仅当：
>  - 它们的根节点具有相同的值。
>  - 一棵树的左子树与另一棵树的右子树镜像对称。
>  - 一棵树的右子树与另一棵树的左子树镜像对称。
>
>- **递归检查**：
>  - 使用递归函数 `check` 来比较两棵树是否镜像对称。
>  - 递归的基本情况是处理空节点的情况。
>  - 递归地检查每个节点的左右子树是否镜像对称 

``` c
bool check(BiNode *l, BiNode *r) {
    if (l == NULL and r == NULL) // 两个节点都为空，对称
        return true;
    if (l == NULL or r == NULL) // 一个节点为空，另一个不为空，不对称
        return false;
    return l->data == r->data and check(l->left, r->right) and check(l->right, r->left);
}
```



### 荷兰国旗(数组)

> 1.用0～i表示0元素区间。 
>
> 2.k～n-1表示2元素区间。 
>
> 3.中间部分为1元素区间。 
>
> 4.用j从头开始扫描顺序表L中部的所有元素。 
>
> - （1）j指向元素1：说明它属于中部，保持不动，j++。 
> - （2）j指向元素0：说明它属于前部，i增1（扩大0元素区间），将i、j位置的元素交换，j++。 
> - （3）j指向元素2：说明它属于后部，k减1（扩大2元素区间），将j、k位置的元素交换，此时j位置的元素可能还要交换到前部，所以j不前进

``` c
//荷兰国旗问题
void move() {
    L.length = n;
    int i = -1, j = 0, k = L.length;// i -k 前=0  中=1 在它们之间  k+1 n 后=2
    while (j < k) {//中和右的边界
        if (L.data[j] == 0) {
            i++;//交换00
            swap(L.data[i], L.data[j]);
            j++;
        } else if (L.data[j] == 2) {
            k--;
            swap(L.data[k], L.data[j]);
        } else {//
            j++;
        }
    }
}

```





### 荷兰国旗(链表)

> ### 算法思想
>
> 1. **初始化指针**：
>    - `l1` 和 `r1` 分别指向 1 的头结点和尾结点。
>    - `l2` 和 `r2` 分别指向 2 的头结点和尾结点。
>    - `r` 指向当前已处理部分的尾结点（即 0 部分的尾结点）。
>    - `p` 用于遍历整个链表。
> 2. **遍历链表**：
>    - 使用 `p` 遍历链表，直到 `p` 为空。
>    - 根据 p的数据值进行不同的处理：
>      - 如果 `p->data == 0`，将 `p` 插入到 `r` 之后，并更新 `r`。
>      - 如果 `p->data == 1`，将 `p` 插入到 1 部分的尾部，并更新 `r1`。
>      - 如果 `p->data == 2`，将 `p` 插入到 2 部分的尾部，并更新 `r2`。
> 3. **连接各部分**：
>    - 将 0 部分的尾结点 `r` 连接到 1 部分的头结点 `l1`。
>    - 将 1 部分的尾结点 `r1` 连接到 2 部分的头结点 `l2`。
>    - 最后将 2 部分的尾结点 `r2` 的 `next` 设置为 `NULL`。

``` c
//荷兰国旗问题
void move(LinkList &head) {
    LNode *l1 = NULL, *r1 = NULL; // 1 的头结点和尾结点
    LNode *l2 = NULL, *r2 = NULL; // 2 的头结点和尾结点
    LNode *r = head; // 当前已处理部分的尾结点
    LNode *p = head->next; // 用于遍历链表
    while (p != NULL) {
        if (p->data == 0) {
            r->next = p;
            r = p;
        } else if (p->data == 1) {
            if (l1 == NULL) {
                l1 = p;
                r1 = p;
            }
        } else {//==2
            if (l2 == NULL) {
                l2 = p;
                r2 = p;
            } else {
                r2->next = p;
                r2 = p;
            }
        }
        p = p->next;
    }
    r->next = r1->next = r2->next = NULL;
    r->next = l1;
    r1->next = l2;
}
```





> ### 算法思想
>
> 1. **初始化指针**：
>
>    - `pa` 指向 `ha` 的第一个节点。
>    - `pb` 指向 `hb` 的第一个节点。
>    - `pc` 指向 `hc` 的头结点（假设 `hc` 已经初始化为一个空链表）。
>
> 2. **遍历两个链表**：
>
>    - 使用 `while` 循环同时遍历 `ha` 和 `hb`，直到其中一个链表遍历结束。
>    - 在每一步中，比较 `pa` 和 `pb` 所指向节点的数据值。
>
> 3. **处理不同情况**：
>
>    - 如果 `pa->data < pb->data`，则移动 `pa` 到下一个节点。
>
>    - 如果 `pa->data > pb->data`，则移动 `pb` 到下一个节点。
>
>    - 如果pa->data == pb->data
>
>      ，则找到了一个公共元素：
>
>      - 创建一个新的节点 `s`，其数据值为 `pa->data`。
>      - 将 `s` 插入到 `hc` 的尾部。
>      - 移动 `pa` 和 `pb` 到各自的下一个节点。
>
> 4. **结束条件**：
>
>    - 当 `pa` 或 `pb` 为空时，循环结束，所有公共元素已经找到并插入到 `hc` 中。



### 查找公共元素

> ### 算法思想 二路归并与尾插法
>
> 1. **初始化指针**：
>
>    - `pa` 指向 `ha` 的第一个节点。
>    - `pb` 指向 `hb` 的第一个节点。
>    - `pc` 指向 `hc` 的头结点（假设 `hc` 已经初始化为一个空链表）。
>
> 2. **遍历两个链表**：
>
>    - 使用 `while` 循环同时遍历 `ha` 和 `hb`，直到其中一个链表遍历结束。
>    - 在每一步中，比较 `pa` 和 `pb` 所指向节点的数据值。
>
> 3. **处理不同情况**：
>
>    - 如果 `pa->data < pb->data`，则移动 `pa` 到下一个节点。
>
>    - 如果 `pa->data > pb->data`，则移动 `pb` 到下一个节点。
>
>    - 如果pa->data == pb->data
>
>      ，则找到了一个公共元素：创建结点插入并修改相应指针
>
> 4. **结束条件**：
>
>    - 当 `pa` 或 `pb` 为空时，循环结束，所有公共元素已经找到并插入到 `hc` 中。

``` c
void findCommonElements(LinkList ha, LinkList hb, LinkList &hc) {
    LNode *pa = ha->next;
    LNode *pb = hb->next;
    hc->next = NULL; // 确保 hc 是空链表
    LNode *pc = hc; // pc 指向 hc 的当前尾结点

    while (pa != NULL && pb != NULL) {// 遍历两个链表
        if (pa->data < pb->data) 
            pa = pa->next;
         else if (pa->data > pb->data) 
            pb = pb->next;
         else { // 找到公共元素
            LNode *s = new LNode; // 创建新节点
            s->data = pa->data;
            pc->next = s; // 将新节点插入到 hc 的尾部
            pc = s; // 更新 pc
            pa = pa->next; // 移动 pa
            pb = pb->next; // 移动 pb
        }
    }
    // 确保 hc 的尾结点指向 NULL
    pc->next = NULL;
}

```

### 迷宫问题(DFS)

>- 初始结点标记为已访问，判断结点若到达终点则结束循环，
>- 否则继续递归搜索四个可能的方向。并且确保新坐标在迷宫范围内。且不是障碍物。
>- **回溯**：如果当前路径无法到达终点，撤销访问标记，尝试其他路径
>- 直至走到终点

``` c
void dfs(int maze[10][10], int x, int y, int n) {
    if (x == n - 1 and y == n - 1) {//右下角为出口
        show();
        return;
    }
    for (int i = 0; i < 4; ++i) {
        int x2 = x + dir[0][i];
        int y2 = y + dir[1][i];
        if (x2 >= 0 and x2 < n and y2 >= 0 and y2 < n) {//没越界继续找
            maze[i][j]=2;//代表访问
            dfs(maze, x2, y2, n);
        }
    }
}
```



### 迷宫问题(BFS)

>1. **初始化**：
>   - 创建一个队列，并将起点加入队列。
>   - 标记起点为已访问。
>2. **循环处理**：
>   - 当队列不为空时，从队列中取出一个节点。
>   - 检查该节点是否是终点，如果是，则找到了一条路径。
>   - 如果不是终点，则对该节点的四个相邻节点进行处理：
>     - 计算相邻节点的位置。
>     - 检查相邻节点是否在迷宫范围内且未被访问过。
>     - 将符合条件的相邻节点加入队列，并标记为已访问。
>3. **结束条件**：
>   - 如果队列为空且没有找到终点，则说明没有路径。
>   - 如果找到终点，打印路径结束程序。

``` c
void bfs(int maze[10][10], int n) {
    queue<Node*> q;  // 使用队列存储待处理的节点
    Node* start = new Node{0, 0};  // 起点
    q.push(start);
    maze[0][0] = 2;  // 标记起点已访问（使用2来避免与障碍物1冲突）
    while (!q.empty()) {
        Node* now = q.front();
        q.pop();
        // 如果到达终点
        if (now->x == n - 1 && now->y == n - 1) {
            show();
            return ;  // 找到路径
        }
        
        for (int i = 0; i < 4; ++i) {        // 遍历四个方向
            int x2 = now->x + dir[i][0];
            int y2 = now->y + dir[i][1];
            // 检查新位置是否在迷宫内且可通行
            if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < n && maze[x2][y2] == 0) {
                Node* next = new Node{x2, y2};
                q.push(next);  // 将新位置加入队列
                maze[x2][y2] = 2;  // 标记为已访问
            }
        }
    }
}
```





### 最小栈

> ### 算法思想
>
> 1. **主栈**：用于存储实际的数据。
> 2. **辅助栈**：用于存储每个位置对应的最小值。每次有新元素入栈时，如果该元素小于或等于辅助栈顶的元素，则将该元素也压入辅助栈。这样，辅助栈顶的元素始终是主栈中所有元素的最小值。
>
> ### 具体步骤
>
> 1. **初始化** 两个栈都为空。
> 2. **入栈 (`Push`)**：将新元素压入主栈。 如果辅助栈为空，或者新元素小于或等于辅助栈顶的元素，则将新元素也压入辅助栈。
> 3. **出栈 (`Pop`)**：从主栈弹出元素。 如果弹出的元素与辅助栈顶的元素相同，则从辅助栈也弹出该元素。
> 4. **获取最小值 (`Min`)**：  辅助栈顶的元素即为主栈中的最小值。

``` c
typedef struct MinStack {
    int data[MAXSIZE];  // 用于存储栈中的数据
    int minn[MAXSIZE];  // 用于存储每个位置对应的最小值
    int top1;           // 栈顶指针
} MinStack;

// 初始化栈
void init(MinStack &s) {
    s.top1 = -1; // 初始时栈为空
}
// 判断栈是否为空
bool empty(MinStack s) {
    return s.top1 == -1;
}
// 判断栈是否已满
bool full(MinStack s) {
    return s.top1 == MAXSIZE - 1;
}
// 获取栈顶元素
bool top(MinStack s, int &x) {
    if (empty(s))
        return false;
    x = s.data[s.top1];
    return true;
}
// 入栈操作
bool push(MinStack &s, int x) {
    if (full(s))
        return false;
    s.data[++s.top1] = x;
    // 如果是第一个元素或者新元素小于等于当前最小值，则更新最小值
    if (empty(s) || x <= s.minn[s.top1 - 1]) {
        s.minn[s.top1] = x;
    } else {
        s.minn[s.top1] = s.minn[s.top1 - 1];
    }
    return true;
}

// 出栈操作
bool pop(MinStack &s, int &x) {
    if (empty(s))
        return false;
    x = s.data[s.top1--];
    return true;
}

// 获取当前栈中的最小值
bool getMinimum(MinStack s, int &x) {
    if (empty(s))
        return false;
    x = s.minn[s.top1];
    return true;
}
```



### 栈模拟队列



> ### 基本思想
>
> 1. **入队操作**：将新元素压入第一个栈 `stack1`。
> 2. 出队操作：如果第二个栈 `stack2` 为空，则将 `stack1` 中的所有元素依次弹出并压入 `stack2`。
>    - 从 `stack2` 弹出一个元素，这就是队列的前端元素。
> 3. 获取队首元素：如果 `stack2` 不为空，直接返回 `stack2` 的栈顶元素。
>    -   如果 `stack2` 为空，将 `stack1` 中的所有元素依次弹出并压入 `stack2`，然后返回 `stack2` 的栈顶元素。

``` c
// 初始化队列
void initQueue(Queue *q) {
    initStack(&q->stack1);
    initStack(&q->stack2);
}

// 入队操作
int enqueue(Queue *q, int x) {
    return push(&q->stack1, x); // 将元素压入 stack1
}

// 出队操作
int dequeue(Queue *q, int *x) {
    if (isEmpty(&q->stack2)) {
        // 如果 stack2 为空，将 stack1 中的所有元素转移到 stack2
        while (!isEmpty(&q->stack1)) {
            int temp;
            if (!pop(&q->stack1, &temp))
                return 0; // 出栈失败
            if (!push(&q->stack2, temp))
                return 0; // 入栈失败
        }
    }
    // 从 stack2 弹出一个元素
    return pop(&q->stack2, x);
}
```





### InfixToSuffix



>1. **初始化**：
>
>   - 使用一个字符串 `pos` 来存储生成的后缀表达式。使用一个栈 `s` 来临时存储操作符。
>
>2. **遍历中缀表达式**：
>
>   - 从左到右逐个字符地遍历中缀表达式 `infix`。
>
>3. **处理每个字符**：
>
>   - **操作数**（数字或字母）：直接将其添加到 `pos` 中。
>
>   - **左括号 `(`**：将左括号压入栈 `s`。
>
>   - 右括号 `)`：
>
>     - 从栈 `s` 中弹出所有操作符并添加到 `pos` 中，直到遇到左括号 `(`。
>     - 弹出左括号 `(` 并丢弃它。
>
>   - 操作符
>
>     （如）：当前操作符 `ch` 的优先级小于或等于栈顶操作符的优先级，则将栈顶操作符弹出并添加到 `pos` 中，然后继续比较新的栈顶操作符。
>
>     - 将当前操作符 `ch` 压入栈 `s`。
>
>4. **处理剩余的操作符**：
>
>   - 遍历完中缀表达式后，栈 `s` 中可能还剩下一些操作符。将这些操作符依次弹出并添加到 `pos` 中。

```c
int getPriority(char ch) {
    if (ch == '+' or ch == '-') {
        return 1;
    } else if (ch == '*' or ch == '/') 
        return 2;
    return 0;
}
// 中缀表达式转后缀表达式
void InfixToSuffix( string &infix, stack<char> &s2) {
    string pos = ""; // 存储后缀表达式
    stack<char> s;   // 操作符栈

    for (size_t i = 0; i < infix.length(); ++i) {
        char ch = infix[i];
        if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z')) {
            pos += ch; // 操作数直接加入后缀表达式
        } else if (ch == '(') {
            s.push(ch); // 左括号入栈
        } else if (ch == ')') {
            while (!s.empty() && s.top() != '(') {
                pos += s.top();
                s.pop();
            }
            if (!s.empty())
                s.pop(); // 弹出左括号
        } else { // 操作符
            while (!s.empty() && getPriority(ch) <= getPriority(s.top())) {//(+ or - )< ( * or / )
                pos += s.top();
                s.pop();
            }
            s.push(ch);
        }
    }
    while (!s.empty()) { // 将剩余的操作符从栈中弹出
        pos += s.top();
        s.pop();
    }
    cout << "pos: " << pos << endl;
}
```





### 序列匹配(栈)

> ### 算法思想
>
> 1. **初始化**：
>    - 使用一个辅助栈 `s` 来模拟实际的栈操作。
>    - 使用两个索引 `i` 和 `j` 分别跟踪输入序列和输出序列的当前处理位置。
> 2. **遍历输出序列**：
>    - 对于输出序列中的每个元素 `output[j]`，我们需要检查它是否可以与栈顶元素匹配或者通过入栈操作到达栈顶。
>    - 如果栈顶元素与 `output[j]` 匹配，则从栈中弹出该元素，并移动到输出序列的下一个元素（即 `j++`）。
>    - 如果栈顶元素不匹配，则从输入序列中继续入栈新的元素，直到找到匹配的元素或输入序列耗尽。
>    - 如果在输入序列耗尽前仍然找不到匹配的元素，则说明无法通过栈操作得到输出序列。
> 3. **结束条件**：
>    - 如处理完输出序列中的所有元素，则可通过栈操作得到输出序列。
>    - 如发现无法匹配，则说明不能通过栈操作得到输出序列。



``` c
// 判断是否可以通过栈操作得到输出序列
bool canGetOutputFromStack(int input[], int output[], int n) {
    stack<int> s; // 辅助栈
    int i = 0; // 输入序列的索引
    int j = 0; // 输出序列的索引
    while (j < n) {
        // 尝试将输入序列中的元素入栈，直到找到与输出序列匹配的元素
        while (i < n and (s.empty() or s.top() != output[j]))
            s.push(input[i++]);
        // 如果栈顶元素与输出序列当前元素匹配，则弹出栈顶元素
        if (!s.empty() and s.top() == output[j]) {
            s.pop();
            j++; // 移动到输出序列的下一个元素
        } else
            // 如果找不到匹配的元素，则返回 false
            return false;
    }
    return true;   // 如果成功处理完输出序列中的所有元素，则返回 true
}
```





### 字符串比较大小

>### 算法思想
>
>1. **初始化**：
>   - 计算两个字符串的较小长度 `len`，这样可以确保在比较过程中不会越界。
>2. **逐字符比较**：
>   - 从第一个字符开始，逐个比较两个字符串中的字符。
>   - 如果 `s` 的当前字符小于 `t` 的当前字符，返回 `-1` 表示 `s` 小于 `t`。
>   - 如果 `s` 的当前字符大于 `t` 的当前字符，返回 `1` 表示 `s` 大于 `t`。
>   - 如果相等，继续比较下一个字符。
>3. **处理字符串长度不等的情况**：
>   - 如果在较短字符串的范围内所有字符都相等，那么需要根据字符串的长度来决定返回值。
>   - 如果 `s` = `t` 的长度，返回 `0` 
>   - 如果 `s` >`t` 的长度，返回 `1` 
>   - 如果 `s` < `t` 的长度，返回 `-1` 

``` c
int Strcmp(SqString s, SqString t) {
    int len = min(s.length, t.length);  // 取较小的长度
    for (int i = 0; i < len; ++i) {
        if (s.data[i] < t.data[i])
            return -1;  // s 小于 t
        else if (s.data[i] > t.data[i])
            return 1;  // s 大于 t
    }
    if (s.length == t.length)
        return 0;  // s 和 t 相等
    if (s.length > len)
        return 1;  // s 长度大于 t
    return -1;     // s 长度小于 t
}
```





### 顺序表二路归并

> - 定义两个指针i,j,初始分别指向la，lb的起始元素  
> - 进行遍历i，j不超过线性表的长度
> - 如果la元素<lb的元素 ，将元素插入lc表后
> -  反之 将lb插入lc表后  
> - 直至下标越界 ；
>   - 判断la 和 lb中是否还有未遍历元素 将其插入到lc后。
> - 最后，设置 `lc` 的长度为 `k`，即合并后的顺序表的实际长度



``` c 
void merge(SeqList *la, SeqList *lb, SeqList *&lc) {
    int i = 0, j = 0;
    int k = 0;
    lc = (SeqList *) malloc(sizeof(SeqList));
    while (i < la->length and j < lb->length) {
        if (la->data[i] < lb->data[j])
            lc->data[k++] = la->data[i++];
        else
            lc->data[k++] = lb->data[j++];
    }
    while (i < la->length)
        lc->data[k++] = la->data[i++];
    while (j < lb->length)
        lc->data[k++] = lb->data[j++];
    lc->length = k;
}
```





## 10-12



### 树

>树定义 ：树是一种非线性的数据结构，树是n（n>=0）个结点的有限集,n=0时，称为空树,任意一个非空树中，
>
>• 有且只有一个特定的称为根的节点； 
>
>• 当n>1时，其余结点可分为m个互不相交的有限集T1,T2,....,Tn，其中每一个集合本身又是一棵树，称为根的子树。 
>
>• 树的根结点没有前驱，除根结点外的所有结点有且仅有一个前驱； 
>
>• 树中所有结点可以有零个或多个后继



>树的性质： 
>
>• 1.树中的结点数等于所有结点的度数之和+1 
>
>• 2.度为m的树中第i层上最多有m^(i-1)个结点 
>
>• 3.高度为h的m叉树最多有(m^h -1)/(m-1)个结点



### 二叉树

> 二叉树定义 ：是另一种树形结构，特点是每个节点至多只有两颗子树，即二叉树中不存在度大于2的几点， 并且，二叉树的子树有左右之分，其次序不能任意颠倒。 
>
>    二叉树性质： 
>
> - 1.二叉树的第i层上至多有2^(i-1)个结点，i>=1; 
> - 2.深度为k的二叉树至多有2^k-1个节点，k>=1; 
> - 3.对任意一颗二叉树，如果其终端节点数为n0，度为2的节点数为n2，则有n0=n2+1。 
> - 4.具有n个结点的完全二叉树的深度为⌊ log2n⌋ +1 
> - 5.对一颗具有n个结点的完全二叉树的结点按照层序编号，对任一节点i，有： 
>   - （1）如果i=1，则结点i时二叉树的根，无双亲；如果i>1,则双亲是节点⌊ i/2⌋ ; 
>   - （2）如果2i>n，则节点i无左孩子，否则其左孩子是结点2i； 
>   - （3）如果2i+1>n，则结点i无右孩子,否则其右孩子是节点2i+1.





### else 

> 其他定义 ： 
>
> • 满二叉树：高度为h，且含有2^h -1个结点的二叉树称为满二叉树。 
>
> • 完全二叉树：高度为h有n个结点的二叉树，当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。 
>
> • 二叉排序树：左子树上的所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字；左子树和右子树又各是 一棵二叉排序树。 
>
> • 平衡二叉树：树上任意结点的左子树和右子树的深度之差不超过1。



### 树遍历

#### 先中后(递归)

``` c
// 前序遍历
void preOrder(BiNode *root) {
    if (root == NULL)
        return;
    cout << " " << root->data; // 访问根节点
    preOrder(root->left);      // 递归遍历左子树
    preOrder(root->right);     // 递归遍历右子树
}
// 中序遍历
void inOrder(BiNode *root) {
    if (root == NULL)
        return;
    inOrder(root->left);       // 递归遍历左子树
    cout << " " << root->data; // 访问根节点
    inOrder(root->right);      // 递归遍历右子树
}
// 后序遍历
void postOrder(BiNode *root) {
    if (root == NULL)
        return;
    postOrder(root->left);     // 递归遍历左子树
    postOrder(root->right);    // 递归遍历右子树
    cout << " " << root->data; // 访问根节点
}
```



#### 先序(非递归)

> 1. **初始化**：
>    - 创建一个空栈 `st`。设置指针 `p` 指向根节点 `root`。
> 2. **主循环**：
>    - 使用 `while (p != NULL || !st.empty())` 循环，只要当前节点 `p` 不为空或栈不为空，就继续循环。
> 3. **处理左子树**：
>    - 使用内部while (p != NULL)循环，一直向左子树走：
>      - 输出当前节点 `p` 的数据。
>      - 将当前节点 `p` 压入栈中。
>      - 将 `p` 指向其左子节点。
> 4. **处理右子树**：
>    - 当左子树走到头（即p为空）时：
>      - 从栈中弹出一个节点，并将其赋值给 `p`。
>      - 将 `p` 指向其右子节点，并继续循环。
> 5. **结束条件**：
>    - 当 `p` 为空且栈也为空时，表示整个树已经遍历完成，退出循环。



``` c 
void preOrder(BiNode *root) {
    if (root == NULL)
        return;
    stack<BiNode *> st;
    BiNode *p = root;
    while (p != NULL or !st.empty()) {
        if (p != NULL) {
            cout << " " << p->data;
            st.push(p);
            p = p->left;
        } else {
            p = st.top();
            st.pop();
            p = p->right;
        }
    }
}
```





#### 中序 非递归

``` c
void inOrder(BiNode *root) {
    if (root == NULL)
        return;
    stack<BiNode *> st;
    BiNode *p = root;
    while (p != NULL or !st.empty()) {
        if (p != NULL) {
            st.push(p);
            p = p->left;
        } else {
            p = st.top();
            cout << " " << p->data;
            st.pop();
            p = p->right;
        }
    }
}

void inOrder2(BiNode *root) {
    if (root == NULL)
        return;
    stack<BiNode *> st;
    BiNode *p = root;
    while (p != NULL || !st.empty()) {
        // 一直向左子树走，并将路径上的所有节点压入栈
        while (p != NULL) {
            st.push(p);
            p = p->left;
        }
        // 弹出栈顶节点并访问它
        if (!st.empty()) {
            p = st.top();
            st.pop();
            cout << " " << p->data;
            // 转向该节点的右子树
            p = p->right;
        }
    }
}

```



#### 后序 非递归

> ### 详细解释
>
> 1. **初始化**：
>    - 初始化 `preVisited` 为 `NULL`，用于记录上一个被访问的节点。
> 2. **主循环**：
>    - 使用 `while (p != NULL || !st.empty())` 循环，只要当前节点 `p` 不为空或栈不为空，就继续循环。
> 3. **处理左子树**：
>    - 使用内部while (p != NULL)循环，一直向左子树走：
>      - 将当前节点 `p` 压入栈中。
>      - 将 `p` 指向其左子节点。
> 4. **处理右子树和根节点**：
>    - 获取栈顶节点 `p`。
>    - 检查当前节点p是否满足以下条件之一：
>      - `p` 没有右子树（即 `p->right == NULL`）。
>      - `p` 的右子树已经被访问过（即 `p->right == preVisited`）。
>    - 如果满足上述条件之一，则访问当前节点 `p`，并更新 `preVisited` 为当前节点 `p`。
>    - 将 `p` 设为 `NULL`，以便下一次循环从栈中取新的节点。
>    - 如果不满足上述条件，则转向右子树（即 `p = p->right`）。
> 5. **结束条件**：
>    - 当 `p` 为空且栈也为空时，表示整个树已经遍历完成，退出循环。

``` c

// 非递归后序遍历
void postOrder(BiTree root) {
    if (root == NULL)
        return;
    stack<BiNode*> st;
    BiNode *p = root;
    BiNode *preVisited = NULL; // 用于记录上一个被访问的节点
    while (p != NULL || !st.empty()) {
        // 一直向左子树走，并将路径上的所有节点压入栈
        while (p != NULL) {
            st.push(p);
            p = p->left;
        }
        // 获取栈顶节点
        p = st.top();
        // 如果当前节点没有右子树，或者右子树已经被访问过
        if (p->right == NULL || p->right == preVisited) {
            cout << " " << p->data; // 访问当前节点
            st.pop();
            preVisited = p; // 更新上一个被访问的节点
            p = NULL; // 将 p 设为 NULL，以便下一次循环从栈中取新的节点
        } else {
            // 否则，转向右子树
            p = p->right;
        }
    }
}
```



> 1. **主循环**：
>
>    - 使用 `while (p != NULL || !st.empty())` 循环，只要当前节点 `p` 不为空或栈不为空，就继续循环。
>
> 2. **处理左子树**：
>
>    - 使用内部while (p != NULL)
>
>       循环，一直向左子树走：
>
>      - 将当前节点 `p` 压入栈中，并设置 `p->isFirst` 为 `true`，表示这是第一次访问该节点。
>      - 将 `p` 指向其左子节点。
>
> 3. **处理右子树和根节点**：
>
>    - 获取栈顶节点 `p` 并弹出。
>
>    - 如果p->isFirst 为true
>
>      ，表示这是第一次访问该节点：
>
>      - 将 `p->isFirst` 设置为 `false`，表示已经访问过。
>      - 再次将 `p` 压入栈中。
>      - 将 `p` 指向其右子节点。
>
>    - 如果
>
>      p->isFirst为false
>
>      ，表示这是第二次访问该节点：
>
>      - 输出当前节点 `p` 的数据。
>      - 将 `p` 设为 `NULL`，以便下一次循环从栈中取新的节点。
>
> 4. **结束条件**：
>
>    - 当 `p` 为空且栈也为空时，表示整个树已经遍历完成，退出循环。

``` c
// 非递归后序遍历
void postOrder2(BiTree root) {
    if (root == NULL)
        return;
    stack<BiNode*> st;
    BiNode *p = root;

    while (p != NULL || !st.empty()) {
        // 一直向左子树走，并将路径上的所有节点压入栈
        while (p != NULL) {
            p->isFirst = true; // 标记为第一次访问
            st.push(p);
            p = p->left;
        }
        if (!st.empty()) {
            p = st.top();
            st.pop();
            if (p->isFirst == true) {
                // 第一次访问，标记为已访问并处理右子树
                p->isFirst = false;
                st.push(p); // 再次压入栈
                p = p->right; // 转向右子树
            } else {
                // 第二次访问，输出节点数据
                cout << " " << p->data;
                p = NULL; // 将 p 设为 NULL，以便下一次循环从栈中取新的节点
            }
        }
    }
}
```





#### 层序

> 1. **初始化**：
>    - 检查根节点 `root` 是否为空，如果为空则直接返回。
>    - 创建一个队列 `q` 并将根节点 `root` 压入队列。
> 2. **主循环**：
>    - 使用 `while (!q.empty())` 循环，只要队列不为空，就继续循环。
> 3. **处理当前节点**：
>    - 从队列中取出一个节点 `p` 并访问它，输出其数据。
>    - 如果 `p` 的左子节点不为空，则将其压入队列。
>    - 如果 `p` 的右子节点不为空，则将其压入队列。
> 4. **结束条件**：
>    - 当队列为空时，表示整个树已经遍历完成，退出循环。

``` c

// 层次遍历
void level(BiTree root) {
    if (root == NULL)
        return;
    queue<BiNode*> q;
    q.push(root);
    while (!q.empty()) {
        BiNode *p = q.front();
        q.pop();
        cout << " " << p->data;
        // 将左子节点压入队列（如果存在）
        if (p->left != NULL) 
            q.push(p->left);
        // 将右节点压入队列（如果存在）
        if (p->right != NULL) 
            q.push(p->right);
    }
}	
```





#### 求深度

>1. **基本情况**： 采用递归思想
>   - 如果 `root` 为空（即 `root == NULL`），则返回 0，表示空树的深度为 0。
>2. **递归情况**：
>   - 递归计算左子树的深度 `leftDepth = deep(root->left)`。
>   - 递归计算右子树的深度 `rightDepth = deep(root->right)`。
>   - 使用 `std::max` 函数比较左右子树的深度，取较大值，并加 1（表示当前节点本身）。

``` c
int deep(BiNode *root){
    if (root==NULL)
        return 0;
    return max(deep(root->left), deep(root->right))+1;
}
```

