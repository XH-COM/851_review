# 851复习文档

> ### By Liuxiao && Jianjian

## 线性结构

​	*什么是线性结构，链表和线性表的区别，二者的特点*



>  线性结构是一种数据元素之间存在一对一关系的数据结构。在这种结构中，除了第一个和最后一个元素外，每个元素都有一个直接前驱和一个直接后继。线性结构可以是顺序存储的（如数组），也可以是非顺序存储的（如链表）
>
> ***\*线性表（Linear List）\**** 通常指的是逻辑上的概念，它是一个由n个数据元素组成的有限序列。这些数据元素具有相同的类型，并且有先后次序。如数组。
>
> ***\*链表（Linked List）\**** 是一种物理存储单元上非连续、非顺序的线性结构，用一组任意的存储单元来存放线性表中的数据元素。链表中的数据元素被称为节点，每个节点包含数据域和指向下一个节点的指针域。根据指针的连接方式，链表可以分为单链表、双链表和循环链表等。
>
> ***\*二者的特点：\****
>
> 线性表（以数组为例）
>
> o 随机访问：可以直接通过下标在O(1)时间内访问到指定位置的元素。
>
> o 存储密度高：由于元素在内存中是连续存储的，所以没有额外的空间浪费。
>
> o 插入删除效率低：如果需要在中间插入或删除元素，则可能需要移动大量元素，平均时间复杂度为O(n)。
>
> o 固定大小：一般而言，数组创建时需要指定大小，在使用过程中不容易改变。
>
> 链表
>
> o 顺序访问：只能从头节点开始，逐个访问后续节点，无法直接跳转到某个特定位置，访问时间为O(n)。
>
> o 插入删除效率高：只需要修改前后节点的指针即可完成插入或删除操作，不需要移动元素，时间复杂度为O(1)。
>
> o 存储密度较低：因为每个节点除了数据域外还需要额外的指针域来链接下一个节点

## 树、二叉树、 森林

### 树

> 树（Tree） 是一种非线性的数据结构，它由n（n>=0）个有限节点组成一个具有层次关系的集合。这个集合满足以下条件：
>
> 1. 有一个特定的称为根（root）的节点。
> 2. 剩余的节点可以被分为m（m >= 0）个互不相交的子集T1, T2, ..., Tm，每个子集本身又是一棵树，并且这些子集被称为根的子树。
> 3. 在树结构中，除了根节点之外，每个节点有且仅有一个父节点，而根节点没有父节点。同时，一个节点可以有零个或多个子节点。

### 二叉树

> **二叉树（**Binary Tree） 是一种特殊的树结构，它的特点是每个节点最多只能有两个子节点：左子节点和右子节点。即使某节点只有一个子节点，也要区分是左子节点还是右子节点。二叉树的定义如下：
>
> 二叉树可以为空。如果非空，则该树由根节点、左子树和右子树组成，其中左子树和右子树也是二叉树。
>
> 二叉树的一些重要特性包括：
>
>  每个节点至多只有两个子节点。
>
> 左子树和右子树是有顺序的，不能随意交换。
>
> 即使树中某个节点只有一棵子树，也要区分它是左子树还是右子树。

#### 二叉树结构

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;
```

#### 非递归先序(Pre)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void PreOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            printf(" %d--", p->data);
            s.push(p);
            p = p->left;//访问左边先 跟左右
        } else {
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            p = p->right;
        }
    }
}

```

#### 非递归中序(In)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void InOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            s.push(p); //先入栈不访问
            p = p->left;//一路向左找

        } else {//某个父节点的左孩子为空 返回父结点并访问
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            printf("%d--", p->data);//这里和先序不太一样
            p = p->right;
        }
    }
}

```

#### 非递归后序(Post)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;


void postOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *visited = NULL;//记录最近访问过的结点
    BiTNode *p = t;
    while (p or !s.empty()) {
        while (p) {
            //尽可能往左走
            s.push(p);
            p = p->left;
        }
        //左边到头了 查看栈元素
        p = s.top();
        if (p->right == NULL or p->right == visited) {
            cout << "--" << p->data;//没右孩子 或 右边已经访问过了
            s.pop();//已经访问该结点
            visited = p;//更新最新结点
            p = NULL;//设置为NULL  以便下一次迭代可以处理栈中的下一个结点
            //比如最后一个结点是根节点 你访问了肯定要设为空 不然is.empty一直为true
        } else {
            //去遍历右子树先
            p = p->right;
        }
    }
}
```

### 平衡二叉树(BST)

>平衡二叉树是一种特殊的二叉树，它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都必须是平衡二叉树。这种结构确保了树的高度保持在对数级别（以2为底），从而保证了各种操作（如查找、插入和删除）的时间复杂度都是O(log n)，其中n是节点的数量。

### 森林

>  森林（Forest） 是指零个或多个不相交的树的集合。换句话说，如果将一棵树的根节点移除，那么剩下的部分就变成了一个森林。森林中的每棵树都是独立的，没有任何节点共享相同的父节点。森林可以看作是树的一种扩展形式，二叉树是对树的一种限制，而森林则是多棵树的集合。
>
> 

```c++
#include <bits/stdc++.h>

using namespace std;

int main(){
    
   
}
```

## 图

### 邻接矩阵



``` c
const int Maxn = 1e3 + 7;
// 邻接矩阵定义
typedef struct MGraph {
char vexes[Maxn]; // 顶点表，可以不要
int edges[Maxn][Maxn]; // 用邻接矩阵存储边
int vexNum, arcNum; // 顶点数，边数
} MGraph;
```

### 邻接表

``` c
const int Maxn = 1e3 + 7;
//边结点
struct ArcNode {
int adjvex; //顶点编号
ArcNode *next; //指向vi的下一个邻接顶点
};
// 顶点结点
struct VNode {
int data; //顶点信息
ArcNode *firstarc; //指向vi的第一个邻接顶点（边）
};
// 图的邻接表表示
typedef struct AGraph {
VNode adjlist[Maxn]; // 顺序存储所有顶点链表的表头结点
int vexNum, arcNum; // 图的顶点个数，边数
} AGraph;
```

### 深搜(DFS)

> 设初始状态时图中的所有顶点未被访问，则： 
>
> 1. 首先，访问开始结点从起始结点开始任选一个相邻并未被 访问的结点，访问； 
> 2. 接着，把找到的结点作为起始结点继续访问其相邻且未被 访问的一个结点； 
> 3. 重复2的操作直到某一个结点所有相邻结点都被访问，则 退回最近被访问且还有相邻结点未被访问的结点；  
> 4. 把3中结点作为起始结点继续执行2，3操作直到所有结点 都被访问完为止

#### dfs邻接表

``` 	c

int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(AGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    ArcNode *p = g->adjlist[v].firstarc;//v指向的第一个邻接结点
       while (p != NULL) {//从起始结点开始任选一个相邻并为访问的结点
        if (visited[p->adjvex] != 1) {
            dfs(g,p->adjvex);//把找到的边 作为起始顶点继续访问
            //未访问过 深度优先
        }
        p = p->next;
    }
}
void dfsTraverse(AGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
        if (visited == 0)  //不需要 重置0 因为 可能有点 不连通 需要继续dfs
            dfs(g, i);
    }//遍历每个没被访问的结点,从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}

```

#### dfs邻接矩阵

``` 	c
int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(MGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    for (int i = 0; i < g->vexNum; ++i) {
        if (g->edges[v][i] == 1 and !visited[i])//有路径且未访问过
            dfs(g, i);
    }
}

void dfsTraverse(MGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
         if (visited[i] == 0)
            dfs(g, i);
    }//遍历每个没被访问的结点 从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}
```





## 排序

>  ==*堆排序*==（Heap Sort）是一种基于比较的排序算法，它利用了堆这种数据结构所设计的一种选择排序。堆是一种特殊的完全二叉树，其中每个父节点的值都大于或等于（最大堆）其所有子节点的值，或者每个父节点的值都小于或等于（最小堆）其所有子节点的值。
>
>  ==堆排序的三个时间复杂度都是O(longn),空间复杂度O(1)==
>
>  在堆排序中，我们通常使用最大堆来对数组进行升序排序。以下是堆排序的基本思想和步骤：
>
>  ### 堆排序的思想
>
>  - 首先将待排序序列构建成一个最大堆。
>  - 然后将堆顶元素（即最大值）与序列末尾的元素交换，使得最大值位于已排序部分的末尾。
>  - 重新调整剩余的序列成为一个新的最大堆。
>  - 重复上述过程，直到整个序列排序完成。
>
>  ### 堆排序的步骤
>
>  1. **构建初始堆**：从最后一个非叶子节点开始，向下调整以确保满足最大堆性质。这个过程称为“堆化”
>    - 对于一个大小为 n 的数组，最后一个非叶子节点的位置是 (n/2) - 1。
>    - 从这个位置开始，向前遍历每一个非叶子节点，并调用堆化函数来维护最大堆属性。
>  2. **交换堆顶元素与末尾元素**：将当前堆顶元素（最大值）与未排序序列的最后一个元素交换，然后缩小未排序序列的范围。
>  3. **调整堆**：对于新调整后的堆，再次执行堆化操作，使剩下的元素重新构成最大堆。
>  4. **重复步骤2和3**：持续上述过程，每次都将当前的最大值移动到已排序部分的末尾，直至整个数组变为有序。
>
>  

### 堆排序

``` c++
//
// Created by nvjiachengba on 20/9/2024.
//
#include <bits/stdc++.h>
using namespace std;
// 调整为大根堆 以k为根节点的子树  数组下标从1开始
void HeapAdjust(int arr[], int k, int n) {
    int i = 2 * k;//左孩子
    while (i <= n) {
        //一层一层向下筛选
        if (i < n and arr[i] < arr[i + 1]) {
            i++;//i指向较大的子节点 沿着值大的子节点往下筛选
        }

        if (arr[k] < arr[i]) {
            //根节点比两个孩子中较大的孩子小 交换
            swap(arr[k], arr[i]);
            k = i;//继续调整受影响的子树
            i = k * 2;
        } else {
            break;//无影响 调整结束
        }
    }
}

// 构建大根堆
void buildMaxHeap(int arr[], int n) {
    // 从最后一个非叶子节点开始调整
    for (int i = n / 2; i >= 0; i--)//从后往前调整 例如7个元素 1-2-3 非叶节点是1，2，3下标
        HeapAdjust(arr, n, i);
}

// 堆排序
void heapSort(int arr[], int n) {
    // 构建大根堆
    buildMaxHeap(arr, n);
    // 逐个移除堆顶元素 与待排序序列中的最后一个元素进行交换
    for (int i = n; i > 1; i--) {
        // 将堆顶元素移到数组末尾
        //为什么移动到末尾 因为如果你 这相当于排序 你要给他移动到 n n-1 n-2····1
        swap(arr[1], arr[i]);
        // 调整剩余元素为大根堆
        HeapAdjust(arr, 1, i - 1);
    }
}

// 打印数组
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = 6;
    printf("Original array: \n");
    printArray(arr, n);
    heapSort(arr, n);
    printf("Sorted array: \n");
    printArray(arr, n);
    return 0;
}
```



# 算法



## 递归

### 定义思想

> 1. 直接或间接地调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。 
> 2. 直接递归：p函数中调用p函数 
> 3. 间接递归：p函数调用q函数，q函数又调用p函数。 
> 4. 递归函数的两个要素：边界条件、递归方程

> ### 递归小结： 
>
> 1.优点：结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序 带来很大方便。 
>
> 2.缺点：递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。 
>
> 3.解决方法：在递归算法中消除递归调用，使其转化为非递归算法。采用一个用户定义的栈来模拟系统的递归调用工作栈。该方法通用性强，但本质上还是递归 优化效果不明显。 （2）、用递推来实现递归函数。 （3）、通过变换能将一些递归转化为尾递归，从而迭代求出结果

### 分治与递归的区别

> **分治法与递归区别**： 
>
> 1. 分治法是解决问题的方法。
>
> 2. 递归是实现各种算法的工具，二叉树、回溯、贪心算法等都可以选择用递归的方式来解决。

## 分治

### 定义思想

> **定义：** 分治法是一种将问题分解成若干个规模较小的相同子问题，然后递归地解决这些子问题，并将各个子问题的解合并得到原问题解的方法。
>
> **思想：**
>
> 1. **分解**：将原问题分解为几个规模较小、相互独立且与原问题形式相同的子问题。
> 2. **解决**：若子问题规模足够小，则直接求解；否则继续分解为更小的子问题，直到可以直接求解。
> 3. **合并**：将子问题的解逐层合并，形成最终的原问题的解

## 动规

### 定义思想

> **定义**：
> 动态规划是通过把原问题分解为相对简单的子问题来求解复杂问题的一种方法。它通常用来解决最优化问题，即从许多可行解中找出一个最优解。
>
> **思想**：
>
> 重叠子问题：动态规划适用于子问题会重复出现的情况，这样可以通过保存已经解决过的子问题的答案来避免重复计算。
> 最优子结构：一个问题的最优解依赖于其子问题的最优解。这意味着可以通过组合子问题的最优解来构造整个问题的最优解。记忆化：利用数组或哈希表存储已解决子问题的结果，以减少计算量。

## 动规和分治联系与区别

> ### 相同点
>
> 1. **分解思想**：
>    - 两者都将原问题分解成较小的子问题。
>    - 都试图通过解决这些子问题来构建整个问题的解决方案。
> 2. **递归结构**：
>    - 分治法通常采用自顶向下的递归来解决问题。
>    - 动态规划也可以使用带有记忆化的递归来实现，这被称为自顶向下的方法。
>
> ### 不同点
>
> 1. **子问题的独立性**：
>    - 分治法中的子问题是独立的，不共享状态信息。
>    - 动态规划处理的是具有重叠子问题的情况，这些子问题之间可能存在依赖关系。
> 2. **求解方式**：
>    - 分治法通常是自顶向下的递归过程。
>    - 动态规划可以是自底向上的迭代过程，也可以采用带备忘录的自顶向下的递归方法。
> 3. **适用场景**：
>    - 分治法适合用于能够被分解为多个完全独立的子问题的问题。
>    - 动态规划适合于那些可以通过分解为更小的子问题并且子问题存在重叠的情况，以及需要寻找最优解的问题。

## 贪心

> **定义**： 贪心算法总是作出在当前看来最好的选择,即贪心选择。也就是说贪心算法并不从整体最优考虑， 
>
> 它所作出的选择只是在某种意义上的局部最优选择。 (当然，希望贪心算法得到的最终结果也是整体最优的。 虽然贪心算法不能对所有问题都得到整体最 优解， 但对许多问题它能产生整体最优解。 在一些情况下， 即使贪心算法不能得到整体最优解， 其最终结果却是最优解的很好近似。
>
> **基本要素**： 贪心选择性质：指所求问题的整体最优解可以通过一系列局部最优的选择， 即贪心选择来达到。（动规的每一步选择往往与其子问题的解有关，而贪心选择不顾前后，仅看当下。） 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质
>
> 贪心算法的特点： 
>
>  a.贪心算法并不保证得到最优解，但是，对于很多问题确实可以求得最优解。 
>
> b.贪心算法可能依赖之前作出的决定，但是，不依赖任何将来的选择或是子问题的解。 
>
> c.贪心算法适用于组合优化问题 
>
> d.贪心算法的求解过程是多步判断过程，最终的判断序列对应于问题的最优解。 
>
> e.依据**某种** “眼前最好，短视的” （这说明在具体的问题中，有多种不同的贪心策略，我们需 要进行可行性的判定）贪心选择性质判断，性质好坏决定算法的成败。 
>
> f. 贪心法必须进行正确性证明 
>
> g.证明贪心法的不正确的技巧： 举反例



### 贪心和动规

> ### 贪心算法
>
> - **局部最优选择**：贪心算法在每一步都做出当前看起来最好的选择，并且期望这些局部最优的选择能够导致全局最优解。
> - **适用范围有限**：贪心算法只适用于那些具有“贪心选择性质”的问题。也就是说，局部最优解可以累积成为全局最优解的问题。对于很多问题，贪心算法可能无法找到最优解。
>
> ### 动态规划
>
> - **全局考虑**：动态规划通过将问题分解为子问题来寻找最优解，并利用子问题的解来构造原问题的解。它会考虑到所有可能的情况，从而确保得到全局最优解。
> - **记忆化/重叠子问题**：动态规划利用了子问题的重叠性质，即同一个子问题不会被重复计算多次。通常通过使用数组或其他数据结构存储已经解决过的子问题的结果。
> - **递归与迭代**：动态规划既可以采用自顶向下的递归方式，也可以采用自底向上的迭代方式。
>
> ### 相同点
>
>    都要求最优子结构
>
> ### 贪心算法的优缺点： 
>
>    优点：算法简单，时间和空间复杂度低。 
>
>   缺点：适用范围有限。



## 回溯

> **定义**： 在问题的解空间树中， 按深度优先策略，从根结点出发搜索解空间树。（问题的解空间一般用树形式来组织，也称为解空间树或状态空间） 
>
> **问题的解空间**: 一个复杂问题的解决方案是由若干个小的决策步骤组成的决策序列，解决一个问题的所有可能的决策序列 构成该问题的解空间。 
>
> 解空间树: 问题的解空间一般用树形式来组织，也称为解空间树或状态空间，树中的每一个结点确定所求解问题的一个问题状态。 
>
> 树的根结点位于第1层，表示搜索的初始状态（不做任何选择），第2层的结点做出第一次选择后到达的状 态，以此类推。 
>
> 可行解与最优解: 解空间中满足约束条件的决策序列称为可行解。 解任何问题都有一个目标，在约束条件下使目标达到最优的可行解称为该问题的最优解。
>
> 其他概念: 活结点： 是指自身已生成但其孩子结点没有全部生成的结点。 
>
> 扩展结点： 是指正在产生孩子结点的结点。 
>
> 死结点： 是指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕。 
>
> 子孙： 结点E的子树上所有结点都是E的子孙。 
>
> 祖宗： 从结点E到树根路径上的所有结点都是E的祖宗。

### 回溯思想 

> 1. **试探**：从根节点（通常是初始状态）开始，按照一定的顺序探索可能的解。
> 2. **前进**：在每一步中，根据问题定义做出一个选择，进入下一个状态。
> 3. **检查**：到达某个状态后，判断这个状态是否满足问题的部分约束条件。如果满足，则继续深入；如果不满足，则需要进行回溯。
> 4. **回溯**：当发现当前的选择不能导致有效的解时，算法会撤销之前的选择（即“回溯”），回到上一个决策点，尝试其他未被探索过的选项。
> 5. **终止条件**：当找到一个完整的解或者所有可能的解都被探索完毕时，算法结束

> **剪枝**：在回溯过程中，通过某些条件提前终止对不可能产生有效解的分支的探索，从而减少不必要的计算。这包括限界函数和约束函数。
>
> - ==**约束函数**==：用来决定哪些节点是可行的，即这些节点对应的解部分满足问题的约束条件。//可行解
> - ==**限界函数**==：用于估计子树中的最优解，以确定是否值得进一步探索该子树  //最优解

## 分支限界

> ### 定义
>
> 分支限界法（Branch and Bound, B&B）是一种用于求解优化问题的算法，结合了广度优先搜索和贪心算法的思想，通过系统地生成可行解，并利用限界函数来避免探索那些不可能产生最优解的分支，从而提高搜索效率。

### 思想

> ### 分支限界法的思想
>
> 1. **分支**：将问题分解为更小的子问题，每个子问题代表了解空间的一部分。
> 2. **限界**：对于每一个子问题，==计算一个下界（最小化问题）或上界（最大化问题）==，这个界限用来估计从当前节点开始能够得到的最好结果。
> 3. **剪枝**：如果某个节点的界限已经超过了目前已知的最佳解，则可以放弃对该节点及其后代节点的进一步探索，因为它们不会导致更好的解。
> 4. **选择**：按照一定的策略（如队列、堆等）选择下一个要扩展的节点，通常选择最有希望改进当前最佳解的节点。
> 5. **更新**：一旦找到一个新的可行解，就更新最佳解，并用新的最佳解去修剪更多的分支。

> ### 相关概念
>
> - **状态空间树**：类似于回溯法中的解空间树，分支限界法也构建了一个表示所有可能解的状态空间树。
> - **活节点**：在搜索过程中尚未被完全处理的节点，即还有可能成为最终解路径上的节点。
> - **死节点**：已经被确定不能产生比现有最优解更好的解的节点。
> - **限界函数**：提供了一个关于解质量的估计，用来决定是否需要继续探索某个分支。对于最小化问题，限界函数给出的是下界；对于最大化问题，限界函数给出的是上界。
> - **最优性剪枝**：当一个节点的限界值大于等于当前已知最优解时，该节点及其子节点就可以被剪掉。
> - **可行性剪枝**：当一个节点不满足问题的约束条件时，也可以进行剪枝。
> - **优先队列/堆**：用来存储待处理的活节点，并根据某种标准（通常是限界值）对这些节点进行排序，以确保总是优先处理最有可能改进当前最优解的节点。

> ### 两种分支限界法：
>
>  1.队列式(FIFO)分支限界法：按照队列先进先出（ FIFO） 原则选取下一个节点为扩展节点。 
>
>  2.优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。

> ### 队列式分枝限界法组织结点表: 
>
> 1.将根结点加入活结点队列。 
>
> 2.从活结点队中取出队头结点，作为当前扩展结点。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，用约束条件检查，把所有满足约束条件的孩子 结点加入活结点队列。 
>
> 4.重复步骤2和3，直到找到一个解或活结点队列为空为止

> ### **优先队列式分枝限界法组织结点表**: 
>
> 1.计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。 
>
> 2.从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分枝推 进，以便尽快地找出一个最优解。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的 孩子结点计算优先级并加入优先队列。 
>
> 4.重复步骤2和3，直到找到一个解或优先队列为空为止

>### **回溯法与分支限界对比**: 
>
>相同：都需要搜索解空间求解 
>
>不同：1.回溯法按照深度优先搜索，分支限界按照广度优先 
>
>2.回溯法存储结点的数据结构是栈，而分支限界是队列、优先队列 
>
>3.回溯法结点多次成为活结点，分支限界每个结点只有一次成为活结点的机会

# 代码篇

## 阶乘

``` c
int fun(int n) {
    if (n == 0)
        return 1;
    return n * fun(n - 1);
}

int fun2(int n) {//非递归
    int sum = 1;

    if (n == 0) {
        return 1;
    } else {
        for (int i = 2; i <= n; ++i) {
            sum *= i;
        }
    }
    return sum;
}

```

## Fibonacci

``` c
    if (n == 1 or n == 2) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
```



## 二分查找

``` c
int BinarySearch(int arr[], int n, int x) {//记住 数组是有序的
     int left=0;
     int right=n-1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (x == arr[mid])
            return mid;
        if (x < arr[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;//**没找到
}
```

## 快排 (QuickSort)

> #### 思想
>
> 快速排序是一种分治算法，其基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分继续进行排序，以达到整个序列有序的目的。
>
> #### 步骤
>
> 1. **选择枢轴（Pivot）**：从数组中选择一个元素作为枢轴。
> 2. 分区（Partition）
>    - 将所有小于枢轴的元素移到枢轴的左边。
>    - 将所有大于枢轴的元素移到枢轴的右边。
> 3. 递归排序
>    - 对枢轴左边的子数组进行快速排序。
>    - 对枢轴右边的子数组进行快速排序。

``` c

int partition(int arr[], int low, int high) {
    //挖空法
    int pivot = arr[low];//选取第一个元素作为枢轴
    while (low < high) {
        while (low < high and arr[high] >= pivot)
            high--;
        arr[low] = arr[high];
        while (low < high and arr[low] <= pivot)
            low++;
        arr[high] = arr[low];
    }
    arr[low]=pivot;//基准元素最后的位置
    return low;//返回中间位置
}

void quickSort(int arr[],int low,int high){
    if (low<high){
        int pivot=partition(arr,low,high);
        quickSort(arr,low,pivot-1);
        quickSort(arr,pivot+1,high);
    }
}
```

## 归排

>#### 思想
>
>归并排序也是一种分治算法，其基本思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成一个有序数组。
>
>#### 步骤
>
>1. **分解**：将数组分成两个子数组。
>2. **递归排序**
>
>​    对左子数组进行归并排序。
>
>  - 对右子数组进行归并排序。
>
>3. **合并**：将两个有序的子数组合并成一个有序数组。

``` c
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k=0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}
void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left,right);
}
```

## 棋盘覆盖

> ### 算法思想
>
> 1. **分治法**：
>    - 将棋盘分成四个 2n−1×2n−12*n*−1×2*n*−1 的子棋盘。
>    - 特殊方格必然位于这四个子棋盘中的一个。
>    - 对于不含特殊方格的子棋盘，选择一个“伪”特殊方格，使得每个子棋盘都有一个特殊方格。//自己添加 tile
> 2. **递归处理**：
>    - 递归地对每个子棋盘进行同样的操作，直到子棋盘大小为 1x1。
>    - 当子棋盘大小为 1x1 时，直接返回，因为 1x1 的棋盘无法再分割。
> 3. **放置 L 形瓦片**：
>    - 在每个子棋盘中，选择一个位置放置 L 形瓦片，以覆盖除了特殊方格之外的其他三个方格。
>    - 通过递归调用，确保每个子棋盘都被正确覆盖。
>
> ### 详细步骤
>
> 1. **初始化**：
>
>    - 定义一个全局变量 `tile` 用于标记不同的 L 形瓦片。
>    - 定义一个二维数组 `board` 用于存储棋盘的状态。
>
> 2. **递归函数 `ChessBoard`**：
>
>    - `tr` 和 `tc`：当前子棋盘的左上角行和列。
>    - `dr` 和 `dc`：特殊方格的行和列。
>    - `size`：当前子棋盘的大小。
>
>    - 递归终止条件：如果 `size` 为 1，则直接返回。
>    - 计算子棋盘的边长的一半 `s = size / 2`。
>    - 根据特殊方格的位置，递归处理四个子棋盘，并在需要的地方放置 L 形瓦片。

```  c
//https://www.bilibili.com/video/BV1QV411m7ff/?spm_id_from=333.337.search-card.all.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int tile = 1;
int board[100][100] = {0};

void ChessBoard(int tr, int tc, int dr, int dc, int size) {
    // 左上角的行 列， 特殊方块的行 列，棋盘的大小
    if (size == 1) {//1*1 的棋盘无法再分割
        return;
    }
    //2*n 2*3 6*6
    int t = tile++;//标号用的
    int s = size / 2;//取边长一般
    //覆盖左上角  1 1
    //          1 0
    if (dr < tr + s and dc < tc + s) {   //若特殊方格在棋盘中 左下角的右下角
        ChessBoard(tr, tc, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s - 1] = t;//填上数 方便看
        ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s);//不能填的位置 左上角的右下角-1
    }

    //覆盖右上角  1 1
    //          0 1
    if (dr < tr + s and dc >= tc + s) {   //若特殊方格在棋盘右上角中
        // < 和 >=都可以 要么加上 -1或+1边界问题而已
        ChessBoard(tr, tc + s, dr, dc, s);
    } else {
        board[tr + s - 1][tc + s] = t;//特殊的-1
        ChessBoard(tr, tc + s, tr + s - 1, tc + s, s);//右上角的左下角
    }

    //再左下角    1 0
    //          1 1
    if (dr >= tr + s and dc < tc + s) {   //若特殊方格在棋盘中
        ChessBoard(tr + s, tc, dr, dc, s);
    } else {
        board[tr + s][tc + s - 1] = t;
        ChessBoard(tr + s, tc, tr + s, tc + s - 1, s);
    }
    //覆盖右下角
    if (dr >= tr + s and dc >= tc + s) {   //若特殊方格在棋盘中
        ChessBoard(tr + s, tc + s, dr, dc, s);
    } else {
        board[tr + s][tc + s] = t;
        ChessBoard(tr + s, tc + s, tr + s, tc + s, s);
    }
}

int main() {
    int size = 8;
    ChessBoard(0, 0, 1, 1, size);
    for (int i = 0; i < size; ++i) {
        for (int j = 0; j < size; ++j) {
            cout << board[i][j] << "  ";
        }
        cout << endl;
    }
}
```

## 循环日程表

> **符合分治策略的思想**，将所有的选手分为两半，n个选手的比赛日程就可以通过分成n/2个选手设计的比赛日程表来决定。采用递归的方式对选手进行割分，直至割分到只剩下1位选手时，比赛日程表就不在需要为其排列。
>
> **边界条件：**n = 1
>
> **分解子问题：**
>
> 1.递归左上角赛程表
>
> 2.递归左下角赛程表
>
> 3.将左上角赛程表copy到右下角
>
> 4.将左下角赛程表copy到右上角

``` c
//循环日程表
void table(int arr[maxNum][maxNum], int y, int len) {
    if (len == 1) {
        arr[0][y] = y + 1;//第0行
        return;
    }
    table(arr, y, len / 2);//左上
    table(arr, y + len / 2, len / 2);//右上
//    上面分治会把 其余的值 赋好 下面等着复制就行
    for (int i = 0; i < len / 2; ++i) {
        for (int j = 0; j < len / 2; ++j) {
            arr[len / 2 + i][y + len / 2 + j] = arr[i][y + j];//左上到右下
            arr[len / 2 + i][y + j] = arr[i][y + len / 2 + j];//右上 复制到左下
        }
    }
}
```

## 逆序对数

> **逆序对**是指在一个数组中，如果存在一对元素 (i, j)，其中 i < j 但 arr[i] > arr[j]，则称这对元素为一个逆序对。在归并排序的过程中，我们可以在合并两个有序子数组时高效地计算出逆序对的数量。
>
> 1. **分割**：将数组分成两个大致相等的部分。
> 2. **递归求解**：递归地在每个部分中计算逆序对的数量。
> 3. **合并**：在合并两个有序子数组的过程中，统计跨过中间点的逆序对数量。
> 4. **累加结果**：将各个部分的逆序对数量累加起来，得到整个数组的逆序对总数

``` c
using namespace std;
int sum = 0;
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            sum += mid - i + 1;// 左边比右边大 出现 逆序对求逆序对-------------------------------
        temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k = 0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}

void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left, right);
}
```

## 矩阵连乘

> 找到一个计算多个矩阵连乘的最优顺序，使得总的乘法次数最少。使用二维数组 `m` 来存储子问题的解，并使用另一个二维数组 `s` 来记录最优分割点，以便最后可以构造出最优解。
>
> ### 动态规划的思想
>
> 1. **定义子问题**：令 `m[i][j]` 表示从第 `i` 个矩阵到第 `j` 个矩阵的最小乘法次数。
> 2. **状态转移方程**：
>    - 如果 `i == j`，那么只有一个矩阵，不需要做任何乘法，所以 `m[i][i] = 0`。
>    - 如果 `i < j`，则考虑所有可能的分割点 `k`（`i <= k < j`），将矩阵链分成两部分 `A[i...k]` 和 `A[k+1...j]`，并计算这两部分的乘法次数加上合并这两部分的乘法次数。选择使总乘法次数最小的 `k` 作为最优分割点。
>    - 具体的状态转移方程为： m[i][j]=min⁡i≤k][k]+m[k+1][j]+pi−1×pk×pj)*m*[*i*][*j*]=min*i*≤*k*<*j*(*m*[*i*][*k*]+*m*[*k*+1][*j*]+*p**i*−1×*p**k*×*p**j*) 其中 `p` 是一个数组，表示每个矩阵的维度。`p_{i-1}` 是第 `i` 个矩阵的行数，`p_k` 是第 `k` 个矩阵的列数，也是第 `k+1` 个矩阵的行数，`p_j` 是第 `j` 个矩阵的列数。
> 3. **边界条件**：当 `i == j` 时，`m[i][j] = 0`，因为单个矩阵不需要进行乘法操作。
> 4. **确定子链长度**：从最短的子链（长度为2）开始，逐渐增加子链的长度，直到覆盖整个矩阵链。
> 5. **确定起点和终点**：对于每个子链长度，枚举所有可能的起点 `i` 和对应的终点 `j`。
> 6. **选择分割点**：在每个子链中，尝试所有可能的分割点 `k`，将子链分成两部分 `A[i...k]` 和 `A[k+1...j]`，并计算这两部分的乘法次数加上合并这两部分的乘法次数。
> 7. **更新最优解**：在所有可能的分割点 `k` 中，选择使得总乘法次数最小的那个 `k`，并将这个最小值记录到 `dp[i][j]` 中。
>
> 1. **matrixMultiply 函数**：
>    - 对于单个矩阵的情况，`dp[i][i] = 0`，因为单个矩阵不需要做任何乘法。
>    - 使用两层循环来处理不同长度的子链：
>      - 外层循环 `len` 表示当前考虑的子链长度。
>      - 内层循环 `i` 表示子链的起始位置。
>    - 计算 `j` 作为子链的结束位置。
>    - 初始化 `dp[i][j]` 为 `INT_MAX`，以便在后续比较中找到最小值。
>    - 使用内层循环 `k` 来尝试不同的分割点，并计算分割后的总乘法次数 `temp`。
>    - 更新 `dp[i][j]` 为 `temp` 的最小值。

``` c
int dp[10][10];
int n = 6;
int p[7] = {30, 35, 15, 5, 10, 20, 25};

void matrixMultiply() {
    for (int i = 1; i <= n; ++i)
        dp[i][i] = 0;//单个矩阵不需要乘法
    for (int len = 2; len <= n; ++len) {//len表示 要求连乘矩阵的长度
        for (int i = 1; i <= n - len + 1; ++i) {//i 为开始位置
            int j = i + len - 1;//j 结束位置
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {//p[i - 1] 是第 i 个矩阵的行数。
                dp[i][j] = min(dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j], dp[i][j]);//维护最小值 注意是加号
            }// p[k] 是第 k 个矩阵的列数（也是第 k+1 个矩阵的行数）。
        }//p[j] 是第 j 个矩阵的列数。
    }
}
```

## 最长公共子序列

> 1. **定义状态**：
>    - `dp[i][j]` 表示 `X` 的前 `i` 个字符和 `Y` 的前 `j` 个字符的最长公共子序列的长度。
> 2. **状态转移方程**：
>    - 如果 `X[i-1] == Y[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
>    - 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
> 3. **边界条件**：
>    - `dp[0][j] = 0`，`dp[i][0] = 0`。

``` c
char x[] = {'0', 'i', 'f', 'g', 'h', 'k', 'u'};
char y[] = {'0', 'e', 'h', 't', 'u'};//下标从1开始算 第一个不算入n
int sum = 0;
int n = 6, m = 4;
int dp[105][105];//dp i j a b
int LCS() {
    for (int i = 1; i <= n; ++i)   //设置边界
        dp[i][0] = 0;
    for (int i = 1; i <= m; ++i)
        dp[0][i] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (x[i] == y[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
}
```

## 最大字段和

> 1. **状态转移方程**：
>
>    - 对于每个 `i`，`dp[i]` 表示以 `arr[i]` 结尾的最大子段和。
>
>    - dp[i]
>
>      可以通过以下两种情况取最大值：
>
>      - 当前元素 `arr[i]` 自己作为一个新的子段。
>      - 当前元素 `arr[i]` 加上前一个子段的和 `dp[i-1]`。
>
> - `dp[i] = max(dp[i-1] + arr[i], arr[i])`。
> - `sum = max(sum, dp[i])`。

``` c
int sum = 0;
int arr[]={0,1,3,-2,4,-3,1};
int n=6;
int dp[25]={0};//dp i j a b
int MaxSub() {
    for (int i = 1; i <= n; ++i)
        dp[i]=arr[i];
    sum=dp[1];
    for (int i = 2; i <= n; ++i){
        dp[i]=max(dp[i-1],dp[i-1]+arr[i]);
        sum=max(dp[i],sum);
    }
}
```

## 01背包

> ### 动态规划思想
>
> 1. **定义状态**：
>    - `dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。
> 2. **状态转移方程**：
>    - 如果不选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j]`。
>    - 如果选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j-weights[i]] + values[i]`，前提是 `j >= weights[i]`。
>    - 综合起来，`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i]] + values[i])`。
> 3. **边界条件**：
>    - `dp[0][j] = 0` 对于所有 `j`，因为没有物品时，价值为 0。
>    - `dp[i][0] = 0` 对于所有 `i`，因为背包容量为 0 时，无法装入任何物品。
> 4. **最终结果**：
>    - `dp[n][capacity]` 即为所求的最大价值。

``` c
int w[] = {0, 2, 3, 4, 5};
int v[] = {0, 3, 4, 5, 6};//下标从1开始
int n = 4;//个数
int c = 5;//容量
int dp[11][11] = {0}; //`dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。

int knapsack() {
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= c; ++j) {
            if (w[i] <= j) {//可以放下
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);//放和不放 取价值最大
            } else {//放不下
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
}
```

## 路径问题

> ### 动态规划思想
>
> 1. **定义状态**：
>    - 用 `dp[i][j]` 表示从起点 (0, 0) 到达位置 (i, j) 的路径数。
> 2. **状态转移方程**：
>    - 如果当前位置 (i, j) 可以从上方 (i-1, j) 和左侧 (i, j-1) 到达，则 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
>    - 特殊情况：如果在第一行（i=0），则只能从左侧到达；如果在第一列（j=0），则只能从上方到达。
> 3. **边界条件**：
>    - 起点 (0, 0) 只有一种方式到达，即 `dp[0][0] = 1`。
>    - 第一行和第一列的每个位置都只有一种方式到达，即 `dp[0][j] = 1` 和 `dp[i][0] = 1`。
> 4. **最终结果**：
>    - `dp[N-1][M-1]` 即为从起点到终点的路径总数。

``` c
int n = 3;
int m = 3;
int dp[20][20];
int countPaths() {
    for (int i = 0; i < n; ++i){
        for (int j = 0; j <m ; ++j) {
            if (i==0 or j==0)//边界条件
                 dp[i][j]=1;
            else
                dp[i][j]= dp[i][j-1]+dp[i-1][j];//上来 + 左来
        }
    }
}
```

## 完全背包

> 1. **定义状态**：
>
>    - `dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。
>
> 2. **状态转移方程**：
>
>    - 如果不选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j]`。
>    - 如果选择第 `i` 个物品，并且 `j >= weights[i]`，则可以选择一次或多次，此时的价值为 `dp[i][j - weights[i]] + values[i]`。
>    - 因此，`dp[i][j] = max(dp[i-1][j], dp[i][j - weights[i]] + values[i])`。
>
> 3. **边界条件**：
>
>    - `dp[0][j] = 0` 对于所有 `j`，因为没有物品时，价值为 0。
>    - `dp[i][0] = 0` 对于所有 `i`，因为背包容量为 0 时，无法装入任何物品。
>
> 4. **最终结果**：
>
>    - `dp[n][capacity]` 即为所求的最大价值。
>
>    ### 为什么使用 `dp[i][j - weights[i-1]]` 而不是 `dp[i-1][j - weights[i-1]]`？
>
>    - 在 0/1 背包问题中，每个物品只能选择一次，因此使用 `dp[i-1][j - weights[i-1]]` 来表示不包含当前物品 `i` 的情况。
>    - 在完全背包问题中，每个物品可以选择多次，因此使用 `dp[i][j - weights[i-1]]` 来表示包含当前物品 `i` 的情况，这样可以继续在剩余容量中选择当前物品。

``` c
int n=3;
int w[] = {0,1, 3, 4};
int v[] = {0,15, 20, 30};
int c=6;
int dp[10][10];
int knapsack() {
    memset(dp,0,sizeof(dp));//初始化为0
    for (int i = 1; i <= n; ++i){
        for (int j = 1; j <=c ; ++j) {
            if (w[i]<=j)//放得下 放i 或者不放i
                 dp[i][j]= max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]);//可重复选 i=i 不能重复选i=i-1
            else
                dp[i][j]=dp[i-1][j];
        }
    }
}//60
```

## 合并石子

> 1. **定义状态**：
>    - `dp[i][j]` 表示将第 `i` 堆到第 `j` 堆石子合并成一堆的最小代价。
> 2. **状态转移方程**：
>    - 对于每一个区间 `[i, j]`，我们可以选择一个位置 `k`（`i <= k < j`），将 `[i, k]` 和 `[k+1, j]` 两部分先分别合并，然后再将这两部分合并。
>    - 因此，`dp[i][j] = min(dp[i][k] + dp[k+1][j] + pre[i][j])`，其中 `pre[i][j]` 表示从第 `i` 堆到第 `j` 堆石子的总数量。//左边 + 右边 加咱俩的代价
> 3. **边界条件**：
>    - `dp[i][i] = 0`，因为单个石子堆不需要合并。
>    - `pre[i][i] = stones[i]`，表示单个石子堆的数量。
> 4. **最终结果**：
>    - 不跨越环的情况可以通过直接计算 `dp[0][n-1]` 得到。
>    - 和矩阵连乘几乎一样
>    - - `i + len - 1 <= n` 确保区间的终点 `j` 不会超过数组的范围。
>      - `j = i + len - 1` 是区间的终点。
>      - 因此，`i + len - 1 <= n` 等价于 `i <= n - len + 1`。
>    - **改写后的写法**：
>      - `i <= n - len + 1` 直接确保了 `i` 的最大值不会超过 `n - len + 1`。
>      - 这样可以保证 `j = i + len - 1` 仍然在有效范围内。

``` c
int arr[] = {0, 3, 4, 3};//下标从1开始
int n = 3;
int pre[10];//前缀和数组
int dp[10][10];
//https://www.bilibili.com/video/BV1PG411H7sj/?spm_id_from=333.880.my_history.page.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int minCostToMergeStones() {
    for (int i = 1; i <= n; ++i)
        pre[i] = pre[i - 1] + arr[i];
    memset(dp, 0, sizeof(dp));//初始化0  单独1堆合并代价为
    for (int len = 2; len <= n; ++len) {//和矩阵连乘很像  最少两堆连乘
        for (int i = 1; i <= n-len+1; ++i) {//i 开始堆下标
            int j = i+len-1;//结束堆 下标
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + pre[j] - pre[i-1]);
            }
        }
    }
}

```

<img src="C:\Users\nvjiachengba\Desktop\851\file\复习文档.assets\image-20240930200525198.png" alt="image-20240930200525198" style="zoom: 50%;" />



## 最长递增子序列

> 1. **定义状态**：
>    - `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
> 2. **状态转移方程**：
>    - 对于每一个 `i`，我们需要检查所有 `j < i` 的位置，如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`。
>    - 如果没有这样的 `j`，则 `dp[i] = 1`，因为单个元素本身也是一个递增子序列。
> 3. **边界条件**：
>    - `dp[0] = 1`，因为单个元素本身就是一个递增子序列。
> 4. **最终结果**：
>    - `max(dp[0], dp[1], ..., dp[n-1])` 即为所求的最长递增子序列的长度。

``` c
int nums[] = {10, 9, 2, 5, 3, 7, 101, 18};
int n = 8;
int dp[20];
int maxLen=INT_MIN;

int lengthOfLIS(int *nums, int n) {
    if (n == 0) return 0;
    for (int i = 0; i < n; ++i)
        dp[i]=1;//初始化 最少包含自己 为1

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
            //满足升序
            dp[i]=max(dp[i],dp[j]+1);
            maxLen= max(maxLen,dp[i]);
            }
        }
    }
}
```

## 活动安排

> ### 问题描述
>
> 假设你有一组活动，每个活动都有一个开始时间和结束时间。这些活动需要使用同一资源（比如同一个会议室），并且在同一时间只能有一个活动使用该资源。你的任务是选出尽可能多的活动来安排，使得被选中的活动之间不会发生时间上的冲突。
>
> ### 解决思路
>
> 采用贪心策略。基本思想如下：
>
> 1. **排序**：首先按照活动的结束时间对所有活动进行升序排序。如果两个活动有相同的结束时间，则可以按开始时间排序。
> 2. **选择活动**：从最早结束的活动开始考虑，选择第一个活动加入集合。然后，对于剩下的活动，总是选择与当前已选活动集合中最后一个活动不冲突的第一个活动加入集合。
> 3. **重复步骤2**：持续执行步骤2直到遍历完所有的活动。
>
> 这种方法确保了在每一步都做出局部最优的选择，从而最终得到全局最优解。

``` c
typedef struct {
    int id;//活动的编号
    int start;//开始时间
    int finish;//结束时间
    int flag;//活动是否被选择
} Activity;
int sum=0;
//下标从1开始
Activity arr[] = {{0, 0, 0},
                         {1, 5, 9},
                         {2, 1, 2},
                         {3, 3, 4},
                         {4, 0, 6},
                         {5, 5, 7},
                         {6, 8, 9}};
int n = 6;
bool cmp(Activity a, Activity b) {
    return a.finish < b.finish; //结束时间早的排在前面
}

void fun() {
    sort(arr+1,arr+n, cmp);// 结束时间从小到大排序 cmp不需要括号
    int pre=1;//以第一个活动结束为开始
    arr[1].flag=1;
    sum++;
    for (int i = 2; i <= n; ++i){
        if (arr[pre].finish<=arr[i].start){//后一个活动开始时间 = 也可以晚于前一个结束时间 不冲突
            sum++;
            pre=i;
            arr[i].flag=1;
        }
    }
}
```

## 部分背包

>   其中每个物品可以被分割成任意小的部分。目标是在不超过背包容量的前提下，使得装入背包的物品总价值最大。这个问题可以通过贪心算法高效解决。
>
> ### 问题描述
>
> - **输入**：一组物品，每个物品有一个重量 `w` 和一个价值 `v`；一个背包，其最大承重为 `W`。
> - **输出**：选择哪些物品以及每种物品的数量，使得装入背包的物品总价值最大，且总重量不超过 `W`。
>
> ### 解决思路
>
> 1. **计算单位重量的价值**：对于每个物品，计算它的单位重量的价值，即 `value/weight`。
> 2. **排序**：根据单位重量的价值对所有物品进行降序排序。
> 3. **选择物品**：从单位重量价值最高的物品开始，尽可能多地选取该物品，直到不能完全放入下一个物品为止。然后继续选择下一个单位重量价值次高的物品，重复此过程，直到背包满或所有物品都已考虑。

``` c
typedef struct {
    int id;//可以不用这题
    int v;
    int w;
} goods;
goods arr[] = {{0, 0,   0,},
               {1, 60,  10},
               {2, 100, 20},
               {3, 120, 30}};
int c = 50;
int n = 3;
int sum = 0;

bool cmp(goods a, goods b) {//根据价值的平均价值 从高到低进行排序
    return a.v / a.w > b.v / b.w;
}

void fractionalKnapsack() {
    for (int i = 1; i <= n; ++i) {
        if (c >= arr[i].w) {//可全部放下
            sum += arr[i].v;
            c -= arr[i].w;
        } else {//部分可放下
            sum += c * (arr[i].v / arr[i].w);
            return;
        }
    }
}
```

## 简单装载

> 最优装载问题（也称为简单装载问题）是背包问题的一种特殊情况，其中每个物品的重量不同，但价值相同。目标是在不超过给定重量限制的情况下，装入尽可能多的物品。这个问题可以通过贪心算法高效解决。
>
> ### 问题描述
>
> - **输入**：一组物品，每个物品有一个重量 `w`；一个船或容器的最大承重为 `W`。
> - **输出**：选择哪些物品，使得装入的物品数量最多，且总重量不超过 `W`。
>
> ### 解决思路
>
> 1. **排序**：按照物品的重量从小到大进行排序。
> 2. **选择物品**：从最轻的物品开始，依次选择物品放入船或容器中，直到不能再装入更多物品为止。

``` c
typedef struct {
    int id;
    int w;//重量
    int flag;//是否选取
} container;
container arr[] = {{0, 0},
                   {1, 5},
                   {2, 3},
                   {3, 4},
                   {4, 2}};
int n = 4;
int c = 10;//容量
int sum = 0;
bool cmp(container a, container b) {//重量从小到大 排序
    return a.w < b.w;
}

void optimalLoading() {
    sort(arr + 1, arr + n, cmp);
    for (int i = 1; i <= n; ++i) {
        if (c >= arr[i].w) {
            arr[i].flag = 1;
            c -= arr[i].w;
            sum++;
        }
    }
}

```

## Dijkstra

> ### Dijkstra算法思想
>
> 1. **初始化**：
>    - 为每个顶点设置一个距离值（`dist`），表示从源顶点到该顶点的最短路径长度。初始时，源顶点的距离设为0，其他所有顶点的距离设为无穷大（表示尚未找到路径）。
>    - 创建一个集合`S`，用于存储已经确定最短路径的顶点。初始时，`S`为空。
> 2. **选择当前距离最小的顶点**：
>    - 从未处理的顶点中选择一个距离最小的顶点`u`，将其加入集合`S`中。这意味着我们已经找到了从源顶点到`u`的最短路径。
> 3. **更新邻接顶点的距离**：
>    - 对于顶点`u`的所有邻接顶点`v`，如果通过`u`到达`v`的路径比当前已知的从源顶点到`v`的路径更短，则更新`v`的距离值。
> 4. **重复步骤2和3**：
>    - 重复上述过程，直到所有顶点都被加入集合`S`中，或者没有更多的顶点可以更新为止。
>
> - **初始化**：设置初始距离和路径。
> - **选择最小距离顶点**：从未处理的顶点中选择距离最小的顶点。
> - **更新距离**：更新通过该顶点到达其他顶点的距离。
> - **重复**：重复上述过程直到所有顶点都被处理

``` c
typedef struct {
    int edges[25][25];
    int vexNum;
    int arcNum;
} MGraph;

int visited[25] = {0};//是否访问
int path[25];   // 原点v到顶点i的前一个顶点
int dist[25];          // 源点到各个顶点的距离

void Dijkstra(MGraph *g, int v) {
    for (int i = 0; i < g->vexNum; ++i) {//初始化判断是否有边
        dist[i] = g->edges[v][i];
        if (g->edges[v][i] < INT_MAX) {
            path[i] = v;//前一个顶点
        } else {
            path[i] = -1;
        }
    }
    visited[v] = 1;//标记源顶点已访问
    dist[v] = 0;
    path[v] = -1;

    for (int i = 1; i < g->vexNum; ++i) {//选择未处理顶点中距离最小的顶点
        int minn = INT_MAX;//最小值
        int minVex;//最小值下标
        for (int j = 0; j < g->vexNum; ++j) {
            if (dist[j] < minn and visited[j] == 0) {
                minn = dist[j];
                minVex = j;//找到最小值
            }
        }
        visited[minVex] = 1;

        for (int j = 0; j < g->vexNum; ++j) {//更新邻接顶点的距离：
            if (visited[j] == 0 and dist[j] > dist[minVex] + g->edges[minVex][j]) {   //以为 minVex 为中介 更近
                dist[j] = dist[minVex] + g->edges[minVex][j];
                path[j] = minVex;
            }
        }
    }
}
```

## prime

> Prim 算法是一种用于找到加权无向图的最小生成树（Minimum Spanning Tree, MST）的贪心算法。其主要思想是从一个起始顶点开始，逐步扩展生成树，直到包含图中的所有顶点。每一步都选择当前未加入生成树的顶点中与生成树相连的边权重最小的那个顶点，并将其加入生成树。
>
> ### 代码的思想
>
> 1. **初始化**：
>    - `sum` 用于存储最小生成树的总权重。
>    - `visited` 数组用于标记顶点是否已经被加入到MST中。
>    - `lowcost` 数组用于存储从已加入MST的顶点到未加入MST的顶点的最小边权重。
> 2. **选择起点**：
>    - 将起始顶点 `v` 标记为已访问。
>    - 初始化 `lowcost` 数组，将起始顶点到其他顶点的距离赋值给 `lowcost` 数组，如果不存在直接连接的边，则设置为无穷大（`INT_MAX`）。
> 3. **迭代过程**：
>    - 执行 `g->vexNum - 1` 次循环，每次选择一个顶点加入MST。
>    - 在每次循环中，找到 `lowcost` 数组中最小的值 `minn` 及其对应的顶点 `k`。
>    - 将 `minn` 加入 `sum`，并将顶点 `k` 标记为已访问。
>    - 更新 `lowcost` 数组，检查新加入的顶点 `k` 到其他未访问顶点的边权重，如果这些边的权重小于 `lowcost` 中的值，则更新 `lowcost`。
> 4. **输出结果**：
>    - 最后输出最小生成树的总权重 `sum`。

``` c
typedef struct {
    int edges[25][25];
    int vexNum;
    int arcNum;
} MGraph;

void prime(MGraph *g, int v) {
    int sum = 0;
    int visited[25];
    int lowcost[25];
    for (int i = 1; i < g->vexNum; ++i) {
        lowcost[i] = g->edges[v][i];//候选边初始化
        visited[i] = 0;
    }

    visited[v] = 1;//起点
    int j, k;
    for (int i = 1; i < g->vexNum; ++i) {//执行n-1次
        int minn = INT_MAX;
        for (j = 1; j < g->vexNum; j++) {//寻找最小值
            if (lowcost[j] < minn and visited[j] == 0) {
                minn = lowcost[i];// 更新最小边权重
                k = j;//最小权值顶点
            }
        }
        sum += minn;
        visited[k] = 1;

        for (int j = 1; j <= g->vexNum; ++j) {//维护候选中的最小值
            if (visited[j] == 0 and g->edges[k][j] < lowcost[j])//未被访问，且最新的顶点到j的距离比原来近
                lowcost[j] = g->edges[k][j]; //更新
        }
    }
    printf("minn:%d", sum);
}
```

## Kruskal

> 1. **定义结构体**：
>    - `Edge` 结构体用于表示图中的边，包含两个顶点 `vex1` 和 `vex2` 以及边的权重 `weight`。
>    - `MGraph` 结构体用于表示图，包含顶点数 `vexNum`、边数 `EdgeNum` 和边表 `edges`。
> 2. **比较函数**：
>    - `cmp` 函数用于对边进行排序，按边的权重从小到大排序。
> 3. **并查集操作**：
>    - `Initial` 函数初始化并查集，使每个顶点的父节点指向自己。
>    - `getRoot` 函数查找顶点的根节点。
>    - `isSameRoot` 函数检查两个顶点是否属于同一个集合。
>    - `merge` 函数合并两个集合。
> 4. **Kruskal 算法**：
>    - `Kruskal` 函数实现了克鲁斯卡尔算法，计算最小生成树的总权重。
>    - 初始化并查集。
>    - 对边进行排序。
>    - 依次选择每条边，如果边的两个顶点不在同一个集合中，则加入 MST 并合并这两个顶点所在的集合。
>    - 当生成树中的边数达到 `vexNum - 1` 时，算法结束。
>    - 如果图不连通，返回 -1 并打印提示信息。

``` c
#define ElemType char
#define MAX_COST 0x7fffffff
const int MAX_SIZE = 23; // 最大容量

// 定义边的结构体
typedef struct Edge {
    int vex1, vex2; // 边所依附的两个顶点
    int weight;     // 权值
} Edge;

// 定义图的结构体
typedef struct {
    int vexNum;     // 顶点数
    int EdgeNum;    // 边数
    Edge edges[MAX_SIZE]; // 边表
} MGraph;

// 比较函数，用于 qsort 排序
bool cmp(const Edge &a, const Edge &b) {
    return a.weight < b.weight;
}

// 初始化并查集
void Initial(int roots[], int n) {
    for (int i = 0; i < n; ++i) {
        roots[i] = i; // 默认自己是自己的父节点
    }
}

// 查找父节点，即根节点
int getRoot(int roots[], int x) {
    while (roots[x] != x) 
        x = roots[x];
    return x;
}

// 检查两个顶点是否属于同一个集合
bool isSameRoot(int roots[], int x1, int x2) {
    return getRoot(roots, x1) == getRoot(roots, x2);
}

// 合并两个集合
void merge(int roots[], int x1, int x2) {
    int s1 = getRoot(roots, x1);
    int s2 = getRoot(roots, x2);
    if (s1 != s2) 
        roots[s1] = s2;
   
}

// Kruskal 算法
int Kruskal(MGraph *g) {
    int sum = 0; // 初始化总权重
    int edgeNum = g->EdgeNum;
    int vexNum = g->vexNum;
    int count = 0;
    int roots[g->vexNum]; // 并查集
    Initial(roots, vexNum); // 初始化并查集

    // 对边进行排序
    sort(g->edges, g->edges + edgeNum, cmp);

    for (int i = 0; i < edgeNum; ++i) {
        if (!isSameRoot(roots, g->edges[i].vex1, g->edges[i].vex2)) {// 如果两个顶点不在同一个集合中
            sum += g->edges[i].weight;
            printf("Edge %d-%d with weight %d is included in MST\n", g->edges[i].vex1, g->edges[i].vex2, g->edges[i].weight);
            merge(roots, g->edges[i].vex1, g->edges[i].vex2);
            count++; // 生成树的边数+1
            if (count == vexNum - 1)
                break; // 达到生成树完成构造
        }
    }

    if (count == vexNum - 1) {
        printf("Total weight of the Minimum Spanning Tree: %d\n", sum);
        return sum;
    } else {
        printf("The graph is not connected, cannot form a Minimum Spanning Tree.\n");
        return -1; // 图不连通
    }
}

```

## prime

> 

``` c

```

## prime

> 

``` 
Quick setup — if you’ve done this kind of thing before
or	
https://github.com/XH-COM/851_review.git
Get started by creating a new file or uploading an existing file. We recommend every repository include a README, LICENSE, and .gitignore.

…or create a new repository on the command line
echo "# 851_review" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/XH-COM/851_review.git
git push -u origin main
…or push an existing repository from the command line
git remote add origin https://github.com/XH-COM/851_review.git
git branch -M main
git push -u origin main
```

