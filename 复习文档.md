# 851复习文档

> ### By Liuxiao 

# 前言

> 有穷性，确定性，可行性，输入，输出
>
> 正确性，可读性，健壮性，高效性

## 线性结构

​	*什么是线性结构，链表和线性表的区别，二者的特点*



>  线性结构是一种数据元素之间存在一对一关系的数据结构。在这种结构中，除了第一个和最后一个元素外，每个元素都有一个直接前驱和一个直接后继。线性结构可以是顺序存储的（如数组），也可以是非顺序存储的（如链表）
>
> ***\*线性表（Linear List）\**** 通常指的是逻辑上的概念，它是一个由n个数据元素组成的有限序列。这些数据元素具有相同的类型，并且有先后次序。如数组。
>
> ***\*链表（Linked List）\**** 是一种物理存储单元上非连续、非顺序的线性结构，用一组任意的存储单元来存放线性表中的数据元素。链表中的数据元素被称为节点，每个节点包含数据域和指向下一个节点的指针域。根据指针的连接方式，链表可以分为单链表、双链表和循环链表等。
>
> ***\*二者的特点：\****
>
> 线性表（以数组为例）
>
> o 随机访问：可以直接通过下标在O(1)时间内访问到指定位置的元素。
>
> o 存储密度高：由于元素在内存中是连续存储的，所以没有额外的空间浪费。
>
> o 插入删除效率低：如果需要在中间插入或删除元素，则可能需要移动大量元素，平均时间复杂度为O(n)。
>
> o 固定大小：一般而言，数组创建时需要指定大小，在使用过程中不容易改变。
>
> 链表
>
> o 顺序访问：只能从头节点开始，逐个访问后续节点，无法直接跳转到某个特定位置，访问时间为O(n)。
>
> o 插入删除效率高：只需要修改前后节点的指针即可完成插入或删除操作，不需要移动元素，时间复杂度为O(1)。
>
> o 存储密度较低：因为每个节点除了数据域外还需要额外的指针域来链接下一个节点

## 线性表

> - 由n的特性相同元素构成的序列称为线性表n>0
>
>   存在唯一的表头，和表尾数据元素
>
> - 除第一个元素外，每个元素都由一个前驱、
> - 除最后一个元素外，每个元素都只有一个后继
> - 特点
>   - 有限性、逻辑性、相似性、抽象性

## 顺序表

> 一组地址连续的存储单源一次存储线性表的数据元素
>
> - 特点
>   - 逻辑上相邻的元素。其物理次序也是相邻的



``` c 
typedef struct {
    int data[MAXSIZE];
    int length;
}SqList;
```



### 插入元素

``` c
// 插入元素
int insertElement(SqList *list, int index, int x) {
    if (index < 0 || index > list->length || list->length == MAXSIZE) 
        return 0; // 插入失败
    for (int i = list->length - 1; i >= index; i--) 
        list->data[i + 1] = list->data[i]; // 将第i个元素及之后的元素后移
    list->data[index] = x;
    list->length++;
    return 1; // 插入成功
}

```



### 删除

``` c
// 删除指定位置的元素
int deleteElemByIndex(SqList *list, int index) {
    if (index < 0 || index >= list->length) 
        return 0; // 删除失败
    for (int i = index + 1; i < list->length; ++i) 
        list->data[i - 1] = list->data[i]; // 将第i个元素及之后的元素前移   
    list->length--;
    return 1; // 删除成功
}
```



### 查找

``` c
int FindElemById(SqList &list, int index) {
    //判断下标是否合法
    return list.data[index];
}
```



``` c
// 查找指定值的元素，并返回其索引
int FindElemByValue(SqList *list, int x) {
    for (int i = 0; i < list->length; ++i) {
        if (list->data[i] == x) 
            return i; // 返回找到的元素的索引
    }
    return -1; // 如果没有找到，返回-1
}
```



## 链表

>  通过一组任意的存储单元来存储线性表中的数据元素。每个链表结点括两个域，数据域存放元素自身信息外，指针域存放指向其 后继结点的指针。
>
>  链表的每个结点中只包含一个指针域，称单链表。 
>
> 存储链表中结点的一组任意的存储单元可以是不连续的，甚至是零散分布在内存中的任意位置上的。



> 链表增加头结点的作用： (1)便于首元结点的处理 增加了头结点后，首元结点的地址保存在头结点（即其 “前驱” 结点）的指针域中，则对链表的第一个数据元素 的操作与其他数据元素相同，无需进行特殊处理。
>
>  (2)则当单链表为长度n 为 0 的空表时， L 指 针为空（判定空表的条件可记为：L== NULL)。 增头结点后（判定空表的条件可记为：L ->next== NULL), 如图
>
> 何区分头节点与首节点？（基础） 
>
> （1）头节点的数据域中不含信息，首节点的数据域中包含信息。 
>
> （2）头节点一定没有前驱，首节点一定包含前驱。







### 查找第i个结点

> 计数器记录当前结点是第几个元素，从首元结点开始依次顺着链域 next 向下访问，直到到达序号为 i 的结点

``` c
LNode* GetElem(LinkList list, int i) {// 获取链表中的第 i 个节点
    if (i < 0) 
        return NULL; // 索引不合法
    int cnt = 0;
    LNode *p = list;
  
    while (p != NULL && cnt < i) {  // 遍历链表直到找到第 i 个节点或到达链表末尾
        p = p->next;
        cnt++;
    }
    return p; // 返回第 i 个节点
}
```



### 按值查找

> 从头开始遍历每个结点，只要指向当前结点的指针p不为空， 并且p所指结点的数据域不等于给定值x, 就一直往下找。

``` c
LNode* locatedElem(LinkList list, int x) {// 查找链表中值为 x 的节点
    // 从链表的第一个实际数据节点开始遍历
    LNode *p = list->next;  // 假设 list 是头节点，不存储实际数据
    // 遍历链表直到找到值为 x 的节点或到达链表末尾
    while (p != NULL && p->data != x) {
        p = p->next;
    }
    return p; // 返回找到的节点，如果未找到则返回 NULL
}
```



### 长度

``` c
// 计算链表的长度
int length(LinkList list) {
    int len = 0;
    LNode *p = list->next;  // 从第一个实际数据节点开始遍历
    
    while (p != NULL) {// 遍历链表直到到达链表末尾
        len++;
        p = p->next;
    }
    return len;  // 返回链表的长度
}
```



### 插入元素

``` c

// 在链表的第 i 个位置插入元素 e
int insertElem(LinkList *list, int i, int e) {
    if (i < 1) 
        return 0; // 索引不合法
    int cnt = 0;
    LNode *p = *list;
    // 遍历链表直到找到第 i-1 个节点或到达链表末尾
    while (p != NULL && cnt < i - 1) {
        p = p->next;
        cnt++;
    }
    if (p == NULL) 
        return 0; // 索引超出范围
    // 创建新节点
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s; // 插入新节点
    return 1; // 插入成功
}
```





### 按值删除

> 记录结点的前一个结点，找到第1个值为key的结点的时候，通过改变指针的指向来删除结点。

```  c
void deleteLinkList(LinkList list, int key) {
    LNode *p = list;
    LNode *q = list->next;
    while (q != NULL and q->data != key) {
        p = q;
        q = q->next;
    }
    if (q == NULL) {
        cout << "NULL";
        return;
    }
    p->next = q->next;
    free(q);
}
```







## 串

> 串(string) ： 
>
>  • 由零个或多个字符组成的有限序列，一般记作s=’a1 a2 a3 ...........an’(n>=0)； 
>
>  • 其中，s是串名，单引号内括起来的字符序列是串的值，可以是字母、数字或其他字符；（注意：单引号本身不属于串，它的作用只是为了避免 与变量名或数的常量混淆而已。） 
>
>  • 串中字符的数目 n 称为串的长度，零个字符的串称为空串（ null string )，它的长度为零；



## 稀疏矩阵

``` c
typedef struct {
    int r;
    int c;
    int d;
} TupNode;
typedef struct {
    int rows;
    int cols;
    int nums;
    TupNode data[MAXSIZE];
} TSMatrix;
// 创建稀疏矩阵
void createMat(TSMatrix *t, int arr[10][10]) {
    int i, j;
    t->rows = t->cols = 10;
    t->nums = 0;
    for (i = 0; i < 10; ++i) {
        for (j = 0; j < 10; ++j) {
            if (arr[i][j] != 0) {
                t->data[t->nums].r = i;
                t->data[t->nums].c = j;
                t->data[t->nums].d = arr[i][j];
                t->nums++;
            }
        }
    }
}
```





## 树、二叉树、 森林

### 树

> 树（Tree） 是一种非线性的数据结构，它由n（n>=0）个有限节点组成一个具有层次关系的集合。这个集合满足以下条件：
>
> 1. 有一个特定的称为根（root）的节点。
> 2. 剩余的节点可以被分为m（m >= 0）个互不相交的子集T1, T2, ..., Tm，每个子集本身又是一棵树，并且这些子集被称为根的子树。
> 3. 在树结构中，除了根节点之外，每个节点有且仅有一个父节点，而根节点没有父节点。同时，一个节点可以有零个或多个子节点。

### 二叉树

> **二叉树（**Binary Tree） 是一种特殊的树结构，它的特点是每个节点最多只能有两个子节点：左子节点和右子节点。即使某节点只有一个子节点，也要区分是左子节点还是右子节点。二叉树的定义如下：
>
> 二叉树可以为空。如果非空，则该树由根节点、左子树和右子树组成，其中左子树和右子树也是二叉树。
>
> 二叉树的一些重要特性包括：
>
>  每个节点至多只有两个子节点。
>
> 左子树和右子树是有顺序的，不能随意交换。
>
> 即使树中某个节点只有一棵子树，也要区分它是左子树还是右子树。

#### 二叉树结构

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;
```

#### 非递归先序(Pre)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void PreOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            printf(" %d--", p->data);
            s.push(p);
            p = p->left;//访问左边先 跟左右
        } else {
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            p = p->right;
        }
    }
}

```

#### 非递归中序(In)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void InOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *p = t;
    while (p or !s.empty()) {
        //p不空 或者栈不空
        if (p) {
            s.push(p); //先入栈不访问
            p = p->left;//一路向左找

        } else {//某个父节点的左孩子为空 返回父结点并访问
            p = s.top();//空 弹出上一个 去访问它的右孩子
            s.pop();
            printf("%d--", p->data);//这里和先序不太一样
            p = p->right;
        }
    }
}

```



#### 非递归后序(Post)

``` c
using namespace std;
typedef struct BiTNode{
   int data;
   struct  BiTNode *left,*right;
}&BiTree;

void postOrder(BiTree t) {
    stack<BiTNode *> s;
    BiTNode *visited = NULL;//记录最近访问过的结点
    BiTNode *p = t;
    while (p or !s.empty()) {
        while (p) {
            //尽可能往左走
            s.push(p);
            p = p->left;
        }
        //左边到头了 查看栈元素
        p = s.top();
        if (p->right == NULL or p->right == visited) {
            cout << "--" << p->data;//没右孩子 或 右边已经访问过了
            s.pop();//已经访问该结点
            visited = p;//更新最新结点
            p = NULL;//设置为NULL  以便下一次迭代可以处理栈中的下一个结点
            //比如最后一个结点是根节点 你访问了肯定要设为空 不然is.empty一直为true
        } else {
            //去遍历右子树先
            p = p->right;
        }
    }
}

```



#### 中序线索化



```c 
// 中序线索化
void inThread(BiTree &p, BiTree &pre) {
    if (p != NULL) {
        inThread(p->left, pre); // 先线索化左子树
        // 如果当前节点的左子树为空，将其左指针指向前驱节点
        if (p->left == NULL) {
            p->left = pre;
            p->ltag = 1; // 左指针为线索
        }
        // 如果前驱节点的右子树为空，将其右指针指向当前节点
        if (pre != NULL && pre->right == NULL) {
            pre->right = p;
            pre->rtag = 1; // 右指针为线索
        }
        pre = p; // 更新前驱节点为当前节点
        inThread(p->right, pre); // 线索化右子树
    }
}
// 创建中序线索二叉树
void CreateInThread(BiTree &tree) {
    BiNode *pre = NULL; // 初始前驱节点为 NULL
    if (tree != NULL) {
        inThread(tree, pre);
        if (pre != NULL) {
            pre->right = NULL; // 最后一个节点的右指针设为 NULL
            pre->rtag = 1; // 右指针为线索
        }
    }
}

// 查找中序遍历的第一个节点
BiNode *firstNode(BiNode *p) {
    while (p != NULL && p->ltag == 0)  // 一直找到最左边的节点
        p = p->left;
    return p;
}
// 查找中序遍历的下一个节点
BiNode *nextNode(BiNode *p) {
    if (p->rtag == 0)  // 如果有右子树，找到右子树中最左边的节点
        return firstNode(p->right);
     else 
        return p->right; // 如果没有右子树，直接返回右指针
    
}
// 中序遍历线索化二叉树
void inOrder(BiTree root) {
    BiNode *p = firstNode(root); // 找到第一个节点
    while (p != NULL) {
        cout << p->data << " "; // 输出当前节点的数据
        p = nextNode(p); // 找到下一个节点
    }
    cout << endl;
}
```





#### 树的三种表示

##### 双亲

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241021192436717-1729509878602-1.png" alt="image-20241021192436717" style="zoom:50%;" />

##### 孩子结点

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241021192528931-1729509931044-3.png" alt="image-20241021192528931" style="zoom:50%;" />



##### 孩子兄弟

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241021192608228-1729509969732-5.png" alt="image-20241021192608228" style="zoom: 67%;" />



### 平衡二叉树(BST)

>平衡二叉树是一种特殊的二叉树，它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都必须是平衡二叉树。这种结构确保了树的高度保持在对数级别（以2为底），从而保证了各种操作（如查找、插入和删除）的时间复杂度都是O(log n)，其中n是节点的数量。



### 哈夫曼树

> - 在n个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树称为哈夫曼树或最优二叉树
> - 结点的带权路径长度： 从根结点到该结点之间的路径长度与该结点的权的乘积。 
> - 树的带权路径长度（WPL）： 树中所有叶子结点的带权路径长度之和。
> - 约定左0 右1(也可自定义)



> 哈夫曼算法（Huffman Algorithm）是一种用于构建最优前缀码的贪心算法。使得出现频率较高的符号具有较短的码字，从而达到压缩数据的目的。
>
> ### 哈夫曼算法的思想
>
> 1. **频率统计**：
>
>    - 首先，统计输入数据中每个符号的出现频率。
>
> 2. **构建优先队列（最小堆）**：
>
>    - 将每个符号及其频率作为叶子节点插入到一个优先队列（通常是一个最小堆）中。优先队列中的元素按频率从小到大排序。
>
> 3. **构建哈夫曼树**：
>
>    1. 从优先队列中取出两个频率最小的节点。
>    2. 创建一个新的内部节点，其频率为这两个节点频率之和。
>    3. 将这个新节点插入到优先队列中。
>
>    - 最后剩下的那个节点就是哈夫曼树的根节点。
>
> 4. **生成哈夫曼编码**：
>
>    - 从根节点到叶子节点的路径上，左分支标记为0，右分支标记为1。

``` c
const int N = 20;//叶子结点的最大值
#define M 2*N-1 //所有结点数量的最大值
using namespace std;
typedef struct {
    int weight;
    int parent;
    int left;
    int right;
} HTNode, HuffmanTree[M + 1];//0号不用
typedef char *HuffManCode[N + 1];//存储哈夫曼编码串的头指针数组
/*求哈夫曼树的哈夫曼编码的算法*/
void CreateHuffmanCode(HuffmanTree ht, HuffManCode hc, int n) {
    //从叶节点到根，逆向求每个叶子结点对应的哈夫曼编码
    char *cd = new char[n * sizeof(char)];//辅助空间 巨鹿每个结点的编码长度
    //逆向放值 求得的值 放在数组的最后面
    cd[n - 1] = '\0';//标志结束 从右到左存放 首先存放结束符
    int i, start, c, p;
    for (int i = 1; i <= n; ++i) {
        start = n - 1;//初始化其实指针='\0'
        c = i;//当前叶子结点的下标
        p = ht[i].parent;//当前结点的双亲
        while (p != 0) { //没找到根结点
            --start;
            if (ht[p].left == c) 
                cd[start] = '0';//左0 右1
            } else 
                cd[start] = '1';
            c = p;
            p = ht[p].parent;
        }
        hc[i] = new char[n * sizeof(char)];//赋值回去
        strcpy(hc[i], &cd[start]);
    }
    free(cd);
}

void Select(HuffmanTree ht, int n, int &s1, int &s2) {
    //选择来哥哥最小的结点 parent=0 赋值给s1 s2
    int i, min1 = INT_MAX, min2 = INT_MAX;
    s1 = 0;
    s2 = 0;
    for (int i = 1; i <= n; ++i) {
        if (ht[i].parent == 0) {
            //是根结点 就是下面包含叶子
            if (ht[i].weight < min1) {
                //比min1小
                min2 = min1;
                s2 = s1;
                min1 = ht[i].weight;
                s1 = i;//min1 最小  min2 次小
            } else if (ht[i].weight < min2) {
                min2 = ht[i].weight;
                s2 = i;//比min2 小
            }
        }
    }
}

void CreateHuffmanTree(HuffmanTree ht, int w[], int n) {
    //w  要构造的那些结点 比如 13  57 23 4
    int i;
    for (int i = 1; i <= n; ++i) {
        ht[i].weight = w[i - 1];//丢到1-n
        ht[i].parent = 0;
        ht[i].left - 0;
        ht[i].right = 0;
    }
    int m = 2 * n - 1;// 实际 所有结点
    for (i = n + 1; i <= m; ++i) {//n+1 -m 存放非叶子结点 初始化
        ht[i].weight = 0;//丢到1-n
        ht[i].parent = 0;
        ht[i].left - 0;
        ht[i].right = 0;
    }
    //初始完毕 创建非叶节点
    int s1, s2;
    for (i = n + 1; i <= m; ++i) {
        Select(ht, i - 1, s1, s2);//每次选出2个最小的结点 切parent为0 也就是根结点不是叶结点
        ht[i].weight = ht[s1].weight + ht[s2].weight;
        ht[s1].parent = i;
        ht[s2].parent = i;
        ht[i].left = s1;//左边更小
        ht[i].right = s2;
    }
}
//https://www.bilibili.com/video/BV181421d7Es/?p=14&spm_id_from=pageDriver/
int main() {
    int w[] = {10, 15, 22, 18, 9};
    int n = 5;
    HuffmanTree huffmanTree;
    HuffManCode c;
    CreateHuffmanTree(huffmanTree, w, n);
    CreateHuffmanCode(huffmanTree, c, n);
    for (int i = 1; i <= n; ++i) 
        cout << "-->" << c[i];
}
```



### 森林

>  森林（Forest） 是指零个或多个不相交的树的集合。换句话说，如果将一棵树的根节点移除，那么剩下的部分就变成了一个森林。森林中的每棵树都是独立的，没有任何节点共享相同的父节点。森林可以看作是树的一种扩展形式，二叉树是对树的一种限制，而森林则是多棵树的集合。
>
> 

```c++
#include <bits/stdc++.h>

using namespace std;

int main(){
    
   
}
```

## 图

### 邻接矩阵



``` c
const int Maxn = 1e3 + 7;
// 邻接矩阵定义
typedef struct MGraph {
char vexes[Maxn]; // 顶点表，可以不要
int edges[Maxn][Maxn]; // 用邻接矩阵存储边
int vexNum, arcNum; // 顶点数，边数
} MGraph;
```

### 邻接表

``` c
const int Maxn = 1e3 + 7;
//边结点
struct ArcNode {
    int adjvex; // 邻接顶点的编号   // 邻接点域
    ArcNode *next; // 指向下一个邻接顶点的指针 // 指向下一条边的指针
};
// 顶点结点
struct VNode {
int data; //顶点信息 
ArcNode *firstarc; // 指向第一个邻接顶点的指针 //指向vi的第一个邻接顶点（边） // 指向第一条依附该顶点的边
};
// 图的邻接表表示
typedef struct AGraph {
VNode adjlist[Maxn]; // 顺序存储所有顶点链表的表头结点
int vexNum, arcNum; // 图的顶点个数，边数
} AGraph;

```

### 深搜(DFS)

> 设初始状态时图中的所有顶点未被访问，则： 
>
> 1. 首先，访问开始结点从起始结点开始任选一个相邻并未被 访问的结点，访问； 
> 2. 接着，把找到的结点作为起始结点继续访问其相邻且未被 访问的一个结点； 
> 3. 重复2的操作直到某一个结点所有相邻结点都被访问，则 退回最近被访问且还有相邻结点未被访问的结点；  
> 4. 把3中结点作为起始结点继续执行2，3操作直到所有结点 都被访问完为止

#### dfs邻接表

``` 	c

int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(AGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    ArcNode *p = g->adjlist[v].firstarc;//v指向的第一个邻接结点
       while (p != NULL) {//从起始结点开始任选一个相邻并为访问的结点
        if (visited[p->adjvex] != 1) {
            dfs(g,p->adjvex);//把找到的边 作为起始顶点继续访问
            //未访问过 深度优先
        }
        p = p->next;
    }
}
void dfsTraverse(AGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
        if (visited == 0)  //不需要 重置0 因为 可能有点 不连通 需要继续dfs
            dfs(g, i);
    }//遍历每个没被访问的结点,从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}

```

#### dfs邻接矩阵

``` 	c
int visited[100] = {0};//标记是否访问数组
void visit(int x) {
    cout << x << endl;
}
void dfs(MGraph *g, int v) {
    //访问开始结点
    visited[v] = 1;
    visit(v);
    for (int i = 0; i < g->vexNum; ++i) {
        if (g->edges[v][i] == 1 and !visited[i])//有路径且未访问过
            dfs(g, i);
    }
}

void dfsTraverse(MGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
         if (visited[i] == 0)
            dfs(g, i);
    }//遍历每个没被访问的结点 从他开始进行dfs遍历 每调用一次，将遍历一个连通分量
}
```



### 广搜(BFS)

#### bfs矩阵

> ### 算法思想
>
> 1. **初始化**：
>    - 使用一个队列 `q` 来存储待访问的结点。
>    - 使用一个数组 `visited` 来标记每个结点是否已被访问。
> 2. **广度优先搜索（BFS）**：
>    - 将起始结点加入队列，并标记为已访问。
>    - 从队列中取出一个结点，访问该结点。
>    - 获取该结点的所有邻接点，如果邻接点未被访问，则将其标记为已访问，并加入队列。
>    - 重复上述过程，直到队列为空。
> 3. **遍历图中的所有结点**：
>
> ​     为了确保所有连通分量都被遍历到，需要对每个未被访问的顶点调用一次 BFS 函数。

``` c
// 广度优先搜索 (BFS)
void bfs(MGraph *g, int v) {
    queue<int> q;  // 创建一个队列
    visited[v] = 1;  // 标记起始顶点为已访问
    visit(v);  // 访问起始顶点
    q.push(v);  // 将起始顶点入队

    while (!q.empty()) {  // 当队列不为空时继续处理
        int u = q.front();  // 取出队头元素
        q.pop();  // 弹出队头元素
        // 遍历所有顶点
        for (int i = 0; i < g->vexNum; ++i) {
            if (g->edges[u][i] == 1 && visited[i] == 0) {  // 如果有路径且未被访问
                visited[i] = 1;  // 标记为已访问
                visit(i);  // 访问邻接点
                q.push(i);  // 将邻接点入队
            }
        }
    }
}

void bfsTraverse(MGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
        if (visited[i] == 0) // 如果顶点未被访问
            bfs(g, i);  // 从该顶点开始进行BFS
    }
}
```



#### bfs邻接表

``` c
// 广度优先搜索
void bfs(AGraph *g, int v) {
    queue<int> q; // 用于存储待访问的结点
    q.push(v); // 将起始结点加入队列
    visited[v] = 1; // 标记起始结点已访问
    visit(v); // 访问起始结点

    while (!q.empty()) {
        int u = q.front(); // 获取队列前端的结点
        q.pop(); // 弹出队列前端的结点
        ArcNode *p = g->adjlist[u].firstarc; // 获取当前结点的第一个邻接点
        while (p != NULL) {
            int w = p->adjvex; // 获取邻接点的索引
            if (visited[w] == 0) { // 如果邻接点未被访问
                visited[w] = 1; // 标记邻接点已访问
                visit(w); // 访问邻接点
                q.push(w); // 将邻接点加入队列
            }
            p = p->next; // 移动到下一个邻接点
        }
    }
}

// 遍历图中的所有结点，进行广度优先搜索
void bfsTraverse(AGraph *g) {
    for (int i = 0; i < g->vexNum; ++i) {
        if (visited[i] == 0)  // 如果结点未被访问
            bfs(g, i); // 从该结点开始进行广度优先搜索
    }
}

```



### DFS&BFS时空复杂度

| 算法 | 数据结构 | 时间复杂度 | 空间复杂度 |
| ---- | -------- | ---------- | ---------- |
| DFS  | 邻接矩阵 | O(V2)      | O(V)       |
| DFS  | 邻接表   | O(V+E)     | O(V)       |
| BFS  | 邻接矩阵 | O(V2)      | O(V)       |
| BFS  | 邻接表   | O(V+E）    | O(V)       |

### 详细解释

1. **邻接矩阵**：
   - **时间**：需要检查所有顶点之间的连接，无论是否实际存在边，都需进行 V×V 次
   - **空间**：主要由递归调用栈或队列以及访问标记数组决定，均为 O(V)。
2. **邻接表**：
   - **时间**：只遍历实际存在的边，因此时间复杂度与边的数量 E 和顶点数量 V 相关。
   - **空间**：主要由递归调用栈或队列以及访问标记数组决定，均为 O(V)。

### 拓扑排序

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241021194648015-1729511209536-7.png" alt="image-20241021194648015" style="zoom:50%;" />



### Floyd

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241021195333516-1729511615184-9.png" alt="image-20241021195333516" style="zoom:67%;" />



``` c
const int Maxn = 100;
const int MaxInt = 1e4 + 1; // 自己定义的无穷大取值
// 邻接矩阵定义
typedef struct MGraph {
    int edges[Maxn][Maxn]; // 用邻接矩阵存储边
    int vexNum, arcNum; // 顶点数，边数
} MGraph;

void Floyd(MGraph *g, int D[][Maxn], int path[][Maxn]) {
    // 使用二重循环将图中各边的值赋值给一个二维数组
    for (int i = 0; i < g->vexNum; i++) {
        for (int j = 0; j < g->vexNum; j++) {
            D[i][j] = g->edges[i][j]; // 两端点无路径默认最大值
            if (D[i][j] > 0 && D[i][j] < MaxInt) // 如果i和j之间有弧
                path[i][j] = i; // 如果i和j之间有弧，则将j的前驱置为i
             else 
                path[i][j] = -1; // 如果i和j之间没有弧，则将j的前驱置为-1  
        }
    }
    // 利用三重循环求任意对顶点的最短路径, k表示中间结点
    for (int k = 0; k < g->vexNum; k++) { // k 表示中间节点
        for (int i = 0; i < g->vexNum; i++) { // i 表示行的枚举
            for (int j = 0; j < g->vexNum; j++) { // j 表示列的枚举
                if (D[i][k] + D[k][j] < D[i][j]) { // 如果通过中间节点k的路径更短
                    D[i][j] = D[i][k] + D[k][j]; // 更新最短路径
                    path[i][j] = path[k][j]; // 更改i->j路径中j的前驱为k->j路径中j的前驱
                }
            }
        }
    }
}

for (int i = 0; i < g->vexNum; i++) {//初始化
    for (int j = 0; j < g->vexNum; j++) {
        D[i][j] = g->edges[i][j]; // 两端点无路径默认最大值
        if (D[i][j] > 0 && D[i][j] < MaxInt) { // 如果i和j之间有弧
            path[i][j] = i; // 如果i和j之间有弧，则将j的前驱置为i
        } else {
            path[i][j] = -1; // 如果i和j之间没有弧，则将j的前驱置为-1
        }
    }
}
```



## 排序和查找

### 插入排序

> 插入排序的基本思想： 每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上， 直到所有待排序记录全部插入为止。

#### 直接插入

> 算法思想： 首先以第一个元素为有序序列，将后面的元素依次插入到有序序列中合适的位置，直到所有元素都插入到 有序序列中为止。
>
>  ==O(n²) O(1) 稳定==
>
> （1）时间复杂度： 
>
> • 最好O(n)——表中元素已经有序，此时每插入一个元素，都只需要比较一次而不需要移动元素。 
>
> • 最坏O(n 2)——表中元素顺序刚好与排序结果中的元素顺序相反，总的比较次数达到最大，总的移动次数也达到最大。 
>
> • 平均 O(n 2) 
>
> （2）空间复杂度：如果A[0]为哨兵，仅用常数个辅助单元，故空间复杂度为O(1) 
>
> （3）稳定排序——若后一个元素大于等于前一个元素，那么就不用移动。 
>
> （4）也适用于链式存储结构，只是在单链表上无需移动记录，只需修改相应的指针。 
>
> （5）更适合于初始记录基本有序（正序）的情况，这时候元素的对比次数和移动次数都少； 当初始记录无序，n较大时，此算法时间复杂度较高，





``` c
// 直接插入排序    
void insertSort(int arr[], int n) {
    for (int i = 1; i < n; ++i) {
        int temp = arr[i]; // 当前要插入的元素
        int j = i - 1;
        // 将大于 key 的元素向后移动
        while (j >= 0 && arr[j] > temp) {
            arr[j + 1] = arr[j];
            --j;
        }
        arr[j + 1] = temp;   // 插入 key 到正确的位置
    }
}
```



``` c
void insertSort2(int arr[], int n) {
    for (int i = 2; i <= n; ++i) {// 将第一个元素作为哨兵 下标0 从1开始
        if (arr[i] < temp) {
            arr[0] = arr[i]; // 设置哨兵
            int j = i - 1;
            // 将大于哨兵的元素向后移动
            while (arr[j] > arr[0]) {
                arr[j + 1] = arr[j];
                --j;
            }
            arr[j + 1] = arr[0];   // 插入哨兵到正确的位置
        }
    }
}
```



> （1）时间复杂度： 
>
> 折半插入排序在查找插入位置上面所花的时间大大减少，就是查找变成二分查找，但是折半插入排序在关键字移动次数方面和直接插入排序是一 样的。
>
> 因此折半插入排序的时间复杂度最好情况为O(nlog2n)，最差情况为O(n2)，平均情况为O(n2)。 
>
> （2）空间复杂度 仅用常数个辅助单元，故空间复杂度为O(1)。
>
> 稳定排序 只适合顺序表

``` c
void BinaryInsertSort(int arr[], int n) {
    for (int i = 2; i <= n; ++i) {
        if (arr[i] < arr[i - 1]) {
            arr[0] = arr[i]; // 将当前元素存储在哨兵位置
            int low = 1;
            int high = i - 1;//前面已经排序的部分 所以是i-1 每次插入的是都对前面进行二分插入
            while (low <= high) {
                int mid = (low + high) / 2;
                if (arr[mid] > arr[0])
                    high = mid - 1; // 当前中间值大于哨兵，缩小上界
                else
                    low = mid + 1; // 当前中间值小于或等于哨兵，缩小下界
            }
            // 将大于哨兵的元素向后移动
            int j = i - 1;
            while (j >= 1 && arr[j] > arr[0]) {
                arr[j + 1] = arr[j];
                --j;
            }
            arr[j + 1] = arr[0]; // 插入哨兵到正确的位置
        }
    }
}
```



#### 希尔排序

> ### 算法思想
>
> 1. **增量序列**：
>
>    - 希尔排序使用一个增量序列 `dt` 来逐步减小增量 `d`，从而将原始数据分割成多个子序列。
>    - 每个子序列由相隔 `d` 的元素组成，例如对于增量 `d = 5`，子序列分别为 `{arr[0], arr[5], arr[10], ...}`、`{arr[1], arr[6], arr[11], ...}` 等。
>
> 2. **插入排序**：
>
>    - 对每个子序列进行插入排序。随着增量 `d` 逐渐减小，子序列中的元素越来越多，最终当 `d = 1` 时，整个数组被作为一个子序列进行插入排序。
>
> 3. **优化**：
>
>    - 通过逐步减小增量 `d`，希尔排序能够在一定程度上减少插入排序中的比较和移动次数，从而提高排序效率。
>
>    （1）时间复杂度： 当 d=1时，最坏时间复杂度为 O(n2)，当n在某个特定范围内，时间复杂度可达到O(n1.3)。 
>
>    （2）空间复杂度： O(1)。 
>
>    （3）稳定性： 希尔排序是==不稳定==的。 希尔排序有多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱 不适合链表

``` c
// 希尔插入排序
void ShellInsert(int arr[], int n, int d) {
    for (int i = d; i < n; ++i) {
        int temp = arr[i]; // 当前要插入的元素
        int j = i - d; // 与当前元素相距 d 的位置
        while (j >= 0 && arr[j] > temp) {
            arr[j + d] = arr[j];
            j -= d;
        }
        arr[j + d] = temp; // 插入 temp 到正确的位置
    }
}

void ShellSort(int arr[], int n, int dt[], int t) {
    for (int i = 0; i < t; ++i)
        ShellInsert(arr, n, dt[i]); // 对每个增量 d 进行插入排序

    for (int d = n / 2; d >= 1; d = d / 2) //每次缩小一半 法二
        ShellInsert(arr, n, d);
}
```



### 交换排序

> #### 交换排序的基本思想：
>
>  两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，直到整个 序列全部满足要求为止



#### 冒泡排序

> 重复遍历要排序的列表，比较每对相邻项，并在必要时交换它们的位置。这个过程会将每一趟中最大的未排序元素“冒泡”到列表的末尾。
>
> ### 算法思想
>
> 1. **外层循环**：从数组的最后一个元素开始，逐步减少未排序部分的长度。
> 2. **内层循环**：从数组的第一个元素开始，比较相邻的两个元素，前一个元素大于后一个元素，则交换它们。
> 3. **优化**：使用一个标志 `flag` 来记录这一趟是否发生了交换。如没有发生交换，说明数组已有序，提前结束排序。

``` c
// 冒泡排序
void bubbleSort(int arr[], int n) {//n =n 
    for (int i = n - 1; i > 0; --i) { // 外层循环，逐步减少未排序部分的长度
        int flag = 0; // 用于记录这一趟是否有交换
        for (int j = 0; j < i; ++j) { // 内层循环，比较并交换相邻元素
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]); // 交换相邻元素
                flag = 1; // 发生了交换
            }
        }
        if (flag == 0) // 如果这一趟没有发生交换，说明数组已经有序
            return;
    }
}
```





### 快排

> 快速排序（Quick Sort）是一种高效的排序算法，它使用分治法策略来将一个数组分成较小的子数组，并递归地对这些子数组进行排序。快速排序的基本思想是选择一个“基准”元素，然后重新排列数组，使得所有比基准小的元素都排在基准前面，所有比基准大的元素都排在基准后面。这个过程称为一次“划分”操作。接着递归地对基准左右两边的子数组执行同样的操作，直到整个数组有序。
>
> ### 快速排序的思想
>
> 1. **选择基准**：从数组中选择一个元素作为基准（pivot）。通常可以选择第一个元素、最后一个元素、中间元素或随机元素作为基准。
> 2. **划分**：重新排列数组，使得所有小于基准的元素位于基准之前，所有大于基准的元素位于基准之后。完成这一步骤后，基准就处于数组中的最终位置。
> 3. **递归排序**：递归地对基准左右两边的子数组重复上述过程，直到每个子数组只有一个元素或为空。
>
> ### 时间复杂度
>
> - **最优情况**：均匀分割数组， O(nlog⁡n)
> - **最坏情况**：每次划分只能分割出一个元素，时间复杂度退化为 O(n2)这种情况发生在数组已经部分或完全有序的情况下。
> - **平均情况**： O(nlog⁡n)
>
> ### 空间复杂度
>
> - **递归栈空间**：由于快速排序使用递归来处理子数组，因此递归调用栈的空间复杂度取决于递归深度。
> - **最优情况**：递归深度为 O(log⁡n)
> - **最坏情况**：递归深度为 O(n)
> - **平均情况**：递归深度为 O(log⁡n)

``` c
// 分区函数
int partition(int arr[], int low, int high) {
    int pivot = arr[low];
    while (low < high) {
        while (low < high && pivot < arr[high])
            high--;
        arr[low] = arr[high];
        while (low < high && pivot > arr[low])
            low++;
        arr[high] = arr[low];
    }
    arr[low] = pivot;
    return low;
}
// 快速排序函数
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pivot = partition(arr, low, high);
        quickSort(arr, low, pivot - 1);
        quickSort(arr, pivot + 1, high);
    }
}
```





## 选择排序 

### 简单选择排序

> 简单选择排序（Selection Sort）是一种直观的比较排序算法。它的基本思想是遍历数组，每次从未排序的部分中找到最小（或最大）的元素，然后将它放到已排序序列的末尾。这个过程会重复进行，直到整个数组都变得有序。
>
> ### 简单选择排序的思想
>
> 1. **初始化**：数组分为两部分，左边是已排序部分，初始为空；右边是未排序部分，包含所有元素。
> 2. **查找最小值**：在未排序部分中找到最小值，并记住其索引。
> 3. **交换位置**：将找到的最小值与未排序部分的第一个元素交换位置，这样最小值就被放到了已排序部分的末尾。
> 4. **缩小范围**：将已排序部分的边界向右移动一位，未排序部分的边界相应地向左移动一位。
> 5. **重复步骤2-4**：重复上述过程，直到未排序部分只剩下一个元素为止。
>
> ### 时间复杂度
>
> - **最好情况**：即使数组已经有序，选择排序也需要遍历整个数组来确认这一点，因此时间复杂度仍然是O(n2)
> - **最坏情况**：当数组逆序时，时间复杂度为 O(n2)
> - **平均情况**：无论数组的初始状态如何，选择排序的时间复杂度都是 O(n2)
>
> ### 空间复杂度
>
> - **额外空间**： O(1)
>
> - **优点**：
>   - 实现简单，容易理解。不需要额外的存储空间。
> - **缺点**：
>   - 时间复杂度较高,对于大数据量的排序效率较低。
>   - 不稳定排序，相等元素的相对顺序可能会改变。



``` c
// 选择排序函数
void selectiveSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) { // 注意这里应该是 n-1，因为最后一个元素不需要再找最小值
        int minn = i;
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minn]) 
                minn = j;
        }
        swap(arr[i], arr[minn]);
    }
}
```



### 堆排序

> 堆排序（Heap Sort）是一种基于比较的排序算法，它利用了二叉堆的数据结构。二叉堆是一种特殊的完全二叉树，可以分为最大堆和最小堆。在最大堆中，父节点的值总是大于或等于其子节点的值；而在最小堆中，父节点的值总是小于或等于其子节点的值。堆排序通常使用最大堆来实现升序排序。
>
> ### 堆排序的思想
>
> 1. **构建初始堆**：将待排序数组构造成一个最大堆。
> 2. **移除堆顶元素**：将堆顶元素（即当前最大元素）与堆中的最后一个元素交换，然后减少堆的大小。
> 3. **调整堆**：由于堆顶元素被替换后可能破坏了最大堆的性质，需要对堆进行调整，使其重新成为一个最大堆。
> 4. **重复步骤2-3**：重复上述过程，直到堆中只剩下一个元素
>
> ### 时间复杂度
>
> - **构建最大堆**：构建最大堆的时间复杂度是 O(n)。虽然直观上看起来是 O(nlog⁡n)
> - **调整堆**：每次调整的时间复杂度是 O(log⁡n)，因为每次调整都涉及到从根节点到叶子节点的路径。
> - **排序过程**：总共需要进行 n−1次调整操作，因此总的时间复杂度是 O(nlog⁡n)
>
> ### 空间复杂度 O(1)
>
> - **优点**：
>   - 是一种稳定的、原地排序算法。
>   - 对于大数据量的排序效率较高，特别是当数据不能完全放入内存时。
> - **缺点**：
>   - 实现较为复杂，不如快速排序等其他算法直观。
>   - 由于频繁的交换操作，实际运行速度可能不如快速排序等算法快。

``` c
// 调整为大根堆 以k为根节点的子树  数组下标从1开始
void HeapAdjust(int arr[], int k, int n) {
    int i = 2 * k; // 左孩子
    while (i <= n) {
        // 一层一层向下筛选
        if (i < n && arr[i] < arr[i + 1]) 
            i++; // i指向较大的子节点 沿着值大的子节点往下筛选
        if (arr[k] < arr[i]) {
            // 根节点比两个孩子中较大的孩子小 交换
            swap(arr[k], arr[i]);
            k = i; // 继续调整受影响的子树
            i = k * 2;
        } else 
            break; // 无影响 调整结束
    }
}
// 构建大根堆
void buildMaxHeap(int arr[], int n) {
    // 从最后一个非叶子节点开始调整
    for (int i = n / 2; i >= 1; i--) // 从后往前调整
        HeapAdjust(arr, i, n);
}

void insertIntoMaxHeap(int arr[], int &n, int newElement) {
    n++; // 增加堆的大小
    arr[n] = newElement; // 将新元素放在数组末尾
    HeapAdjust(arr, n); // 调整堆
}

 int arr[] = {0, 12, 11, 13, 5, 6, 7}; 
    int n = 6;
// 堆排序
void heapSort(int arr[], int n) {// 注意：数组下标从1开始，所以第0个位置是无效的
    // 构建大根堆
    buildMaxHeap(arr, n);
    // 逐个移除堆顶元素 与待排序序列中的最后一个元素进行交换
    for (int i = n; i > 1; i--) {
        // 将堆顶元素移到数组末尾
        swap(arr[1], arr[i]);
        // 调整剩余元素为大根堆
        HeapAdjust(arr, 1, i - 1);
    }
}
```



### 归并排序

> 归并排序（Merge Sort）是一种高效的、基于比较的排序算法，它使用分治法策略来递归地将数组分成更小的部分，然后合并这些部分以达到排序的目的。归并排序是稳定的排序算法.
>
> ### 归并排序的思想
>
> 1. **分解**：将待排序的数组分成两个大致相等的部分。
> 2. **递归排序**：递归地对这两个子数组进行排序。
> 3. **合并**：将两个已排序的子数组合并成一个有序的数组。
>
> 
>
> ### 时间复杂度
>
> - **分解**：每次递归将数组分成两半，这一步的时间复杂度为 O(1)
> - **递归排序**：递归调用 `mergeSort` 函数，总共需要 O(log⁡n) 层递归。
> - **合并**：每层递归合并操作的时间复杂度为 O(n)，因为每个元素都需要被处理一次。
>
> 因此，归并排序的总时间复杂度为：O(nlog⁡n)
>
> ### 空间复杂度
>
> - **额外空间**：归并排序需要一个与原数组大小相同的临时数组来存储合并过程中的结果，因此空间复杂度为 O(n)
>
> - **优点**：
>   - 稳定排序算法。
>   - 时间复杂度稳定为 O(nlog⁡n)*O*(*n*log*n*)，不受输入数据的影响。
>   - 适合大数据量的排序，特别是当数据不能完全放入内存时。
> - **缺点**：
>   - 需要额外的存储空间 O(n)*O*(*n*)。
>   - 实现较为复杂，不如一些简单的排序算法直观。
>   - 对于小数据量的排序，可能不如插入排序等简单算法高效。



``` c
void merge(int arr[], int low, int mid, int high) {
    int temp[20];
    int i = low, j = mid + 1;
    int k = low;
    // 合并两个子数组
    while (i <= mid && j <= high) {
        if (arr[i] < arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    // 将左子数组剩余的元素复制到 temp
    while (i <= mid)
        temp[k++] = arr[i++];
    // 将右子数组剩余的元素复制到 temp
    while (j <= high)
        temp[k++] = arr[j++];
    // 将 temp 数组复制回原数组
    for (k = low; k <= high; ++k) // 注意这里应该是从 low 到 high
        arr[k] = temp[k]; // 调整索引
}
```



### 十大算法

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241026191504955-1729941306492-1.png" alt="image-20241026191504955" style="zoom:67%;" />







### 平衡二叉树

>平衡二叉树 树上的任一结点的左子树和右子树的高度只差不超过1
>
>- 结点的平均因子=左子树的高-右子树的高



<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241020211741579-1729430268804-1.png" alt="image-20241020211741579" style="zoom: 50%;" />





#### LL



<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241020214153532-1729431715519-9.png" alt="image-20241020214153532" style="zoom:50%;" />



#### RR

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241020213706744-1729431428719-3.png" alt="image-20241020213706744" style="zoom:50%;" />





#### RL



<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241020213757259-1729431478911-5.png" alt="image-20241020213757259" style="zoom:50%;" />





<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241020213825768.png" alt="image-20241020213825768" style="zoom:50%;" />



#### LR

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241020213959365-1729431600784-7.png" alt="image-20241020213959365" style="zoom:50%;" />



### 二叉排序树

#### 查找

> - 如果根节点为空，返回 `NULL`。
> - 如果根节点的键值等于 `x`，返回根节点。
> - 如果根节点的键值大于 `x`，递归查找左子树。
> - 如果根节点的键值小于 `x`，递归查找右子树。

``` c
typedef struct BSTNode {
    int key;
    struct BSTNode *lchild;
    struct BSTNode *rchild;
} BSTNode, *BSTTree;

BSTNode *BSTSearch(BSTNode *root, int x) {
    if (root == NULL)
        return NULL; // 如果根节点为空，返回NULL
    if (root->key == x) {
        return root; // 如果找到目标值，返回当前节点
    } else if (root->key > x) {
        return BSTSearch(root->lchild, x); // 在左子树中继续查找
    } else {
        return BSTSearch(root->rchild, x); // 在右子树中继续查找
    }
}
```





#### 插入

> - 如果当前节点为空，创建一个新节点并将其设置为当前节点。
> - 如果当前节点的键值等于 `x`，返回 `false` 表示不插入。
> - 如果当前节点的键值大于 `x`，递归调用 `BSTInsert` 在左子树中插入。
> - 如果当前节点的键值小于 `x`，递归调用 `BSTInsert` 在右子树中插入

``` c 
// 二叉搜索树插入函数
bool BSTInsert(BSTNode *root, int x) {
    if (root == NULL) {
        // 如果根节点为空，创建一个新节点并将其设置为根节点
        root = new BSTNode;
        root->key = x;
        root->lchild = NULL;
        root->rchild = NULL;
        return true;
    }
    if (root->key == x) 
        return false; // 如果找到目标值，不插入
    else if (root->key > x)
        return BSTInsert(root->lchild, x); // 在左子树中继续插入
    else
        return BSTInsert(root->rchild, x); // 在右子树中继续插入
}
```



#### 创建

``` c
void createBST(BSTNode *root,int arr[],int n){
    for (int i = 0; i < n; ++i)
        BSTInsert(root,arr[i]);
}
```



### B树

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183107973-1729593069486-1-1729593074524-3.png" alt="image-20241022183107973" style="zoom: 67%;" />



![image-20241022183142745](./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183142745-1729593104453-5-1729593106701-7.png)

#### 查找

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183317504-1729593199475-9.png" alt="image-20241022183317504" style="zoom:67%;" />



#### 插入

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183353702-1729593235172-11.png" alt="image-20241022183353702" style="zoom:67%;" />





#### 删除

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183428822-1729593270310-13.png" alt="image-20241022183428822" style="zoom: 67%;" />



### B+

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183523160-1729593324680-15.png" alt="image-20241022183523160" style="zoom: 67%;" />







### 哈希

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183617017-1729593378722-17.png" alt="image-20241022183617017" style="zoom:50%;" />

#### 解决冲突

> ==开放定址法==。 从冲突发生的地址d开始，依次探测d的下一个地址（当到达下标为n-1的Hash表表尾时，
>
> 下一个探查的地址是表首地址0)，直到找到一个空闲单元为止，将关键字保存在这个位置上

##### 失败

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183757923-1729593479328-19.png" alt="image-20241022183757923" style="zoom:67%;" />



#### 

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241022183839044-1729593520668-21.png" alt="image-20241022183839044" style="zoom:67%;" />







### 分块查找

> 1. - 遍历 `index` 数组，找到第一个 `key` 大于或等于 `x` 的块。
>    - 在该块内进行线性查找，如果找到 `x`，返回其索引；否则继续查找下一个块。
>
>    - 如果找到 `x`，输出其索引；否则输出未找到的信息。

``` c
typedef struct {
    int key;
    int low, high;
} indexElem;
int blockSearch(int arr[], indexElem index[], int n, int x) {
    for (int i = 0; i < n; ++i) {
        if (x <= index[i].key) {
            int left = index[i].low;
            int right = index[i].high;
            while (left <= right) {
                if (arr[left] == x)
                    return left;
                else
                    left++;
            }
        }
    }
    return -1; // 如果没有找到，返回-1
}
```





# 算法



## 递归

### 定义思想

> 1. 直接或间接地调用自身的算法称为递归算法。用函数自身给出定义的函数称为递归函数。 
> 2. 直接递归：p函数中调用p函数 
> 3. 间接递归：p函数调用q函数，q函数又调用p函数。 
> 4. 递归函数的两个要素：边界条件、递归方程
>
> 1.问题可以转化为一个或多个子问题来求解，这些子问题的求解方式与原问题完全相同，只是数量规模不同 
>
> 2.递归调用的次数必须有限 
>
> 3.必须有结束递归的条件来终止递归

> ### 递归小结： 
>
> 1.优点：结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序 带来很大方便。 
>
> 2.缺点：递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多。 
>
> 3.解决方法：在递归算法中消除递归调用，使其转化为非递归算法。采用一个用户定义的栈来模拟系统的递归调用工作栈。该方法通用性强，但本质上还是递归 优化效果不明显。 （2）、用递推来实现递归函数。 （3）、通过变换能将一些递归转化为尾递归，从而迭代求出结果





<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241023192300485-1729682582021-1.png" alt="image-20241023192300485" style="zoom: 67%;" />





### 分治与递归的区别

> **分治法与递归区别**： 
>
> 1. 分治法是解决问题的方法。
>
> 2. 递归是实现各种算法的工具，二叉树、回溯、贪心算法等都可以选择用递归的方式来解决。

## 分治

### 定义思想

> **定义：** 分治法是一种将问题分解成若干个规模较小的相同子问题，然后递归地解决这些子问题，并将各个子问题的解合并得到原问题解的方法。
>
> **思想：**
>
> 1. **分解**：将原问题分解为几个规模较小、相互独立且与原问题形式相同的子问题。
>
> 2. **解决**：若子问题规模足够小，则直接求解；否则继续分解为更小的子问题，直到可以直接求解。
>
> 3. **合并**：将子问题的解逐层合并，形成最终的原问题的解
>
>    
>
> - 规模缩小到一定程度就可以轻松解决 
> -  问题可以分解为若干规模较小的问题 
> -  子问题又可以合并为原问题的解 
> - 子问题之间相互独立，不包含公共的子问题

## 动规

### 定义思想

> **定义**：
> 动态规划是通过把原问题分解为相对简单的子问题来求解复杂问题的一种方法。它通常用来解决最优化问题，即从许多可行解中找出一个最优解。
>
> **思想**：
>
> 重叠子问题：动态规划适用于子问题会重复出现的情况，这样可以通过保存已经解决过的子问题的答案来避免重复计算。
> 最优子结构：一个问题的最优解依赖于其子问题的最优解。这意味着可以通过组合子问题的最优解来构造整个问题的最优解。记忆化：利用数组或哈希表存储已解决子问题的结果，以减少计算量。

## 动规和分治联系与区别

> ### 相同点
>
> 1. **分解思想**：
>    - 两者都将原问题分解成较小的子问题。
>    - 都试图通过解决这些子问题来构建整个问题的解决方案。
> 2. **递归结构**：
>    - 分治法通常采用自顶向下的递归来解决问题。
>    - 动态规划也可以使用带有记忆化的递归来实现，这被称为自顶向下的方法。
>
> ### 不同点
>
> 1. **子问题的独立性**：
>    - 分治法中的子问题是独立的，不共享状态信息。
>    - 动态规划处理的是具有重叠子问题的情况，这些子问题之间可能存在依赖关系。
> 2. **求解方式**：
>    - 分治法通常是自顶向下的递归过程。
>    - 动态规划可以是自底向上的迭代过程，也可以采用带备忘录的自顶向下的递归方法。
> 3. **适用场景**：
>    - 分治法适合用于能够被分解为多个完全独立的子问题的问题。
>    - 动态规划适合于那些可以通过分解为更小的子问题并且子问题存在重叠的情况，以及需要寻找最优解的问题。

## 贪心

> **定义**： 贪心算法总是作出在当前看来最好的选择,即贪心选择。也就是说贪心算法并不从整体最优考虑， 
>
> 它所作出的选择只是在某种意义上的局部最优选择。 (当然，希望贪心算法得到的最终结果也是整体最优的。 虽然贪心算法不能对所有问题都得到整体最 优解， 但对许多问题它能产生整体最优解。 在一些情况下， 即使贪心算法不能得到整体最优解， 其最终结果却是最优解的很好近似。
>
> **基本要素**： 贪心选择性质：指所求问题的整体最优解可以通过一系列局部最优的选择， 即贪心选择来达到。（动规的每一步选择往往与其子问题的解有关，而贪心选择不顾前后，仅看当下。） 最优子结构性质：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质
>
> 贪心算法的特点： 
>
>  a.贪心算法并不保证得到最优解，但是，对于很多问题确实可以求得最优解。 
>
> b.贪心算法可能依赖之前作出的决定，但是，不依赖任何将来的选择或是子问题的解。 
>
> c.贪心算法适用于组合优化问题 
>
> d.贪心算法的求解过程是多步判断过程，最终的判断序列对应于问题的最优解。 
>
> e.依据**某种** “眼前最好，短视的” （这说明在具体的问题中，有多种不同的贪心策略，我们需 要进行可行性的判定）贪心选择性质判断，性质好坏决定算法的成败。 
>
> f. 贪心法必须进行正确性证明 
>
> g.证明贪心法的不正确的技巧： 举反例



### 贪心和动规

> ### 贪心算法
>
> - **局部最优选择**：贪心算法在每一步都做出当前看起来最好的选择，并且期望这些局部最优的选择能够导致全局最优解。
> - **适用范围有限**：贪心算法只适用于那些具有“贪心选择性质”的问题。也就是说，局部最优解可以累积成为全局最优解的问题。对于很多问题，贪心算法可能无法找到最优解。
>
> ### 动态规划
>
> - **全局考虑**：动态规划通过将问题分解为子问题来寻找最优解，并利用子问题的解来构造原问题的解。它会考虑到所有可能的情况，从而确保得到全局最优解。
> - **记忆化/重叠子问题**：动态规划利用了子问题的重叠性质，即同一个子问题不会被重复计算多次。通常通过使用数组或其他数据结构存储已经解决过的子问题的结果。
> - **递归与迭代**：动态规划既可以采用自顶向下的递归方式，也可以采用自底向上的迭代方式。
>
> ### 相同点
>
>    都要求最优子结构
>
> ### 贪心算法的优缺点： 
>
>    优点：算法简单，时间和空间复杂度低。 
>
>   缺点：适用范围有限。



## 回溯

> **定义**： 在问题的解空间树中， 按深度优先策略，从根结点出发搜索解空间树。（问题的解空间一般用树形式来组织，也称为解空间树或状态空间） 
>
> **问题的解空间**: 一个复杂问题的解决方案是由若干个小的决策步骤组成的决策序列，解决一个问题的所有可能的决策序列 构成该问题的解空间。 
>
> 解空间树: 问题的解空间一般用树形式来组织，也称为解空间树或状态空间，树中的每一个结点确定所求解问题的一个问题状态。 
>
> 树的根结点位于第1层，表示搜索的初始状态（不做任何选择），第2层的结点做出第一次选择后到达的状 态，以此类推。 
>
> 可行解与最优解: 解空间中满足约束条件的决策序列称为可行解。 解任何问题都有一个目标，在约束条件下使目标达到最优的可行解称为该问题的最优解。
>
> 其他概念: 活结点： 是指自身已生成但其孩子结点没有全部生成的结点。 
>
> 扩展结点： 是指正在产生孩子结点的结点。 
>
> 死结点： 是指由根结点到该结点构成的部分解不满足约束条件，或者其子结点已经搜索完毕。 
>
> 子孙： 结点E的子树上所有结点都是E的子孙。 
>
> 祖宗： 从结点E到树根路径上的所有结点都是E的祖宗。

### 回溯思想 

> 1. **试探**：从根节点（通常是初始状态）开始，按照一定的顺序探索可能的解。
> 2. **前进**：在每一步中，根据问题定义做出一个选择，进入下一个状态。
> 3. **检查**：到达某个状态后，判断这个状态是否满足问题的部分约束条件。如果满足，则继续深入；如果不满足，则需要进行回溯。
> 4. **回溯**：当发现当前的选择不能导致有效的解时，算法会撤销之前的选择（即“回溯”），回到上一个决策点，尝试其他未被探索过的选项。
> 5. **终止条件**：当找到一个完整的解或者所有可能的解都被探索完毕时，算法结束

> **剪枝**：在回溯过程中，通过某些条件提前终止对不可能产生有效解的分支的探索，从而减少不必要的计算。这包括限界函数和约束函数。
>
> - ==**约束函数**==：用来决定哪些节点是可行的，即这些节点对应的解部分满足问题的约束条件。//可行解
> - ==**限界函数**==：用于估计子树中的最优解，以确定是否值得进一步探索该子树  //最优解

## 分支限界

> ### 定义
>
> 分支限界法（Branch and Bound, B&B）是一种用于求解优化问题的算法，结合了广度优先搜索和贪心算法的思想，通过系统地生成可行解，并利用限界函数来避免探索那些不可能产生最优解的分支，从而提高搜索效率。

### 思想

> ### 分支限界法的思想
>
> 1. **分支**：将问题分解为更小的子问题，每个子问题代表了解空间的一部分。
> 2. **限界**：对于每一个子问题，==计算一个下界（最小化问题）或上界（最大化问题）==，这个界限用来估计从当前节点开始能够得到的最好结果。
> 3. **剪枝**：如果某个节点的界限已经超过了目前已知的最佳解，则可以放弃对该节点及其后代节点的进一步探索，因为它们不会导致更好的解。
> 4. **选择**：按照一定的策略（如队列、堆等）选择下一个要扩展的节点，通常选择最有希望改进当前最佳解的节点。
> 5. **更新**：一旦找到一个新的可行解，就更新最佳解，并用新的最佳解去修剪更多的分支。

> ### 相关概念
>
> - **状态空间树**：类似于回溯法中的解空间树，分支限界法也构建了一个表示所有可能解的状态空间树。
> - **活节点**：在搜索过程中尚未被完全处理的节点，即还有可能成为最终解路径上的节点。
> - **死节点**：已经被确定不能产生比现有最优解更好的解的节点。
> - **限界函数**：提供了一个关于解质量的估计，用来决定是否需要继续探索某个分支。对于最小化问题，限界函数给出的是下界；对于最大化问题，限界函数给出的是上界。
> - **最优性剪枝**：当一个节点的限界值大于等于当前已知最优解时，该节点及其子节点就可以被剪掉。
> - **可行性剪枝**：当一个节点不满足问题的约束条件时，也可以进行剪枝。
> - **优先队列/堆**：用来存储待处理的活节点，并根据某种标准（通常是限界值）对这些节点进行排序，以确保总是优先处理最有可能改进当前最优解的节点。

> ### 两种分支限界法：
>
>  1.队列式(FIFO)分支限界法：按照队列先进先出（ FIFO） 原则选取下一个节点为扩展节点。 
>
>  2.优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。

> ### 队列式分枝限界法组织结点表: 
>
> 1.将根结点加入活结点队列。 
>
> 2.从活结点队中取出队头结点，作为当前扩展结点。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，用约束条件检查，把所有满足约束条件的孩子 结点加入活结点队列。 
>
> 4.重复步骤2和3，直到找到一个解或活结点队列为空为止

> ### **优先队列式分枝限界法组织结点表**: 
>
> 1.计算起始结点（根结点）的优先级并加入优先队列（与特定问题相关的信息的函数值决定优先级）。 
>
> 2.从优先队列中取出优先级最高的结点作为当前扩展结点，使搜索朝着解空间树上可能有最优解的分枝推 进，以便尽快地找出一个最优解。 
>
> 3.对当前扩展结点，先从左到右地产生它的所有孩子结点，然后用约束条件检查，对所有满足约束条件的 孩子结点计算优先级并加入优先队列。 
>
> 4.重复步骤2和3，直到找到一个解或优先队列为空为止

>### **回溯法与分支限界对比**: 
>
>相同：都需要搜索解空间求解 
>
>不同：1.回溯法按照深度优先搜索，分支限界按照广度优先 
>
>2.回溯法存储结点的数据结构是栈，而分支限界是队列、优先队列 
>
>3.回溯法结点多次成为活结点，分支限界每个结点只有一次成为活结点的机会

# 代码篇

## 阶乘

``` c
int fun(int n) {
    if (n == 0)
        return 1;
    return n * fun(n - 1);
}

int fun2(int n) {//非递归
    int sum = 1;

    if (n == 0) {
        return 1;
    } else {
        for (int i = 2; i <= n; ++i) {
            sum *= i;
        }
    }
    return sum;
}

```

## Fibonacci

``` c
    if (n == 1 or n == 2) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
```



## 二分查找

> 二分查找是一种高效的查找算法，广泛应用于有序数组中查找特定元素。它的核心思想是分治法（Divide and Conquer），即将问题分解为更小的子问题，递归地解决这些子问题，最后将子问题的解合并为原问题的解。
>
> ### 二分查找的分治思想
>
> 1. **分（Divide）**：
>    - 将数组分成两半，计算中间索引 `mid`
> 2. **治（Conquer）**：
>    - 如果 `arr[mid]` 等于目标值 `x`，直接返回 `mid`。
>    - 如果 `arr[mid]` 大于目标值 `x`，在左半部分继续查找。
>    - 如果 `arr[mid]` 小于目标值 `x`，在右半部分继续查找。
> 3. **合（Combine）**：
>    - 二分查找不需要显式的合并步骤，因为每次递归调用或循环迭代都直接返回找到的目标值的索引或未找到的标志 `-1`

``` c
int BinarySearch(int arr[], int n, int x) {//记住 数组是有序的
     int left=0;
     int right=n-1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (x == arr[mid])
            return mid;
        if (x < arr[mid]) 
            right = mid - 1;
         else 
            left = mid + 1;
    }
    return -1;//**没找到
}
```

## 快排 (QuickSort)

> #### 思想
>
> 快速排序是一种分治算法，其基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分继续进行排序，以达到整个序列有序的目的。
>
> #### 步骤
>
> 1. **选择枢轴（Pivot）**：从数组中选择一个元素作为枢轴。
> 2. 分区（Partition）
>    - 将所有小于枢轴的元素移到枢轴的左边。
>    - 将所有大于枢轴的元素移到枢轴的右边。
> 3. 递归排序
>    - 对枢轴左边的子数组进行快速排序。
>    - 对枢轴右边的子数组进行快速排序。

``` c

int partition(int arr[], int low, int high) {
    //挖空法
    int pivot = arr[low];//选取第一个元素作为枢轴
    while (low < high) {
        while (low < high and arr[high] >= pivot)
            high--;
        arr[low] = arr[high];
        while (low < high and arr[low] <= pivot)
            low++;
        arr[high] = arr[low];
    }
    arr[low]=pivot;//基准元素最后的位置
    return low;//返回中间位置
}

void quickSort(int arr[],int low,int high){//n-1
    if (low<high){
        int pivot=partition(arr,low,high);
        quickSort(arr,low,pivot-1);
        quickSort(arr,pivot+1,high);
    }
}
```

## 归排

>#### 思想
>
>归并排序也是一种分治算法，其基本思想是将数组分成两个子数组，分别对这两个子数组进行排序，然后将排序好的子数组合并成一个有序数组。
>
>#### 步骤
>
>1. **分解**：将数组分成两个子数组。
>2. **递归排序**
>
>​    对左子数组进行归并排序。
>
>  - 对右子数组进行归并排序。
>
>3. **合并**：将两个有序的子数组合并成一个有序数组。

``` c
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k=0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}
void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left,right);
}
```

## 寻找第K小的数

> ### 算法思想
>
> 1. **基本思路**：快速选择算法通过递归地将数组分成两部分，并根据基准元素的位置来决定继续在哪一部分查找第 *k* 小的元素。
>
> 2. **分区操作**：使用一个分区函数 `partition` 来选择一个基准元素，并将数组分为两部分，使得左边的部分都小于基准元素，右边的部分都大于基准元素。
>
> 3. 递归选择
>
>    - 如果基准元素的位置正好是 k−1*k*−1，则找到了第 k*k* 小的元素。
>    - 如果基准元素的位置大于 k−1*k*−1，则在左半部分继续查找。
>    - 如果基准元素的位置小于 k−1*k*−1，则在右半部分继续查找。
>    - 
>
>    - **最好情况**：每次分区都能将数组均匀分成两部分，时间复杂度为 O(n)
>    - **最坏情况**：每次分区都将数组分成非常不均匀的两部分，时间复杂度为 O(n2)
>    - **平均情况**：时间复杂度为 O(n)
>
>    - **递归调用栈**：递归调用的空间复杂度为 O(log⁡n)*O*(log*n*) 到 O(n)*O*(*n*)，取决于分区的均匀程度。
>
>      

``` c
int partition(int arr[], int low, int high) {
    int pivot = arr[low]; // 选取第一个元素作为枢轴
    while (low < high) {
        while (low < high && arr[high] > pivot)
            high--; // 从右向左找到第一个小于 pivot 的元素
        arr[low] = arr[high]; // 将其移到左边
        while (low < high && arr[low] < pivot)
            low++; // 从左向右找到第一个大于 pivot 的元素
        arr[high] = arr[low]; // 将其移到右边
    }
    arr[low] = pivot; // 基准元素最后的位置
    return low; // 返回中间位置
}
// 快速选择函数
int quickSelect(int arr[], int low, int high, int k) {
    if (low < high) {
        int pivot = partition(arr, low, high); // 分区操作
        if (pivot == k - 1) 
            return arr[pivot]; // 查找第 k 小的数
        else if (pivot > k - 1) 
            return quickSelect(arr, low, pivot - 1, k); // 在左半部分继续查找
         else 
            return quickSelect(arr, pivot + 1, high, k); // 在右半部分继续查找
    }
    return arr[low]; // 如果 low == high，返回 arr[low]
}
```





## 棋盘覆盖

> ### 算法思想
>
> 1. **分治法**：
>    - 将棋盘分成四个 2n−1×2n−12*n*−1×2*n*−1 的子棋盘。
>    - 特殊方格必然位于这四个子棋盘中的一个。
>    - 对于不含特殊方格的子棋盘，选择一个“伪”特殊方格，使得每个子棋盘都有一个特殊方格。//自己添加 tile
> 2. **递归处理**：
>    - 递归地对每个子棋盘进行同样的操作，直到子棋盘大小为 1x1。
>    - 当子棋盘大小为 1x1 时，直接返回，因为 1x1 的棋盘无法再分
>
> 3. **放置 L 形骨牌** ：
>
> ​     在每个小棋盘的相应位置放置一个 L 形骨牌，以确保四个小棋盘都可以被正确覆
>
> ### 详细步骤
>
> 1. **初始化**：
>
>    - 定义一个全局变量 `tile` 用于标记不同的 L 形瓦片。
>    - 定义一个二维数组 `board` 用于存储棋盘的状态。
>
> 2. **递归函数 `ChessBoard`**：
>
>    - `tr` 和 `tc`：当前子棋盘的左上角行和列。
>    - `dr` 和 `dc`：特殊方格的行和列。
>    - `size`：当前子棋盘的大小。
>
>    - 递归终止条件：如果 `size` 为 1，则直接返回。
>    - 计算子棋盘的边长的一半 `s = size / 2`。
>    - 根据特殊方格的位置，递归处理四个子棋盘，并在需要的地方放置 L 形瓦片。

```  c
//https://www.bilibili.com/video/BV1QV411m7ff/?spm_id_from=333.337.search-card.all.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int tile = 1; // 用于标记L形骨牌
int board[100][100] = {0}; // 棋盘数组
// tr, tc: 当前棋盘左上角的行和列
// dr, dc: 特殊方块的行和列
// size: 当前棋盘的大小
void ChessBoard(int tr, int tc, int dr, int dc, int size) {
    if (size == 1) // 1*1 的棋盘无法再分割
        return;
    int t = tile++; // 标号用的
    int s = size / 2; // 取边长的一半

    // 处理左上角
    if (dr < tr + s && dc < tc + s)  // 如果特殊方块在左上角
        ChessBoard(tr, tc, dr, dc, s);
    else {
        board[tr + s - 1][tc + s - 1] = t; // 在左上角的右下角放置L形骨牌
        ChessBoard(tr, tc, tr + s - 1, tc + s - 1, s); // 递归处理左上角
    }

    // 处理右上角
    if (dr < tr + s && dc >= tc + s)  // 如果特殊方块在右上角
        ChessBoard(tr, tc + s, dr, dc, s);
     else {
        board[tr + s - 1][tc + s] = t; // 在右上角的左下角放置L形骨牌
        ChessBoard(tr, tc + s, tr + s - 1, tc + s, s); // 递归处理右上角
    }

    // 处理左下角
    if (dr >= tr + s && dc < tc + s)  // 如果特殊方块在左下角
        ChessBoard(tr + s, tc, dr, dc, s);
     else {
        board[tr + s][tc + s - 1] = t; // 在左下角的右上角放置L形骨牌
        ChessBoard(tr + s, tc, tr + s, tc + s - 1, s); // 递归处理左下角
    }
    // 处理右下角
    if (dr >= tr + s && dc >= tc + s)  // 如果特殊方块在右下角
        ChessBoard(tr + s, tc + s, dr, dc, s);
     else {
        board[tr + s][tc + s] = t; // 在右下角的左上角放置L形骨牌
        ChessBoard(tr + s, tc + s, tr + s, tc + s, s); // 递归处理右下角
    }
}

int main() {
    int size = 8; // 棋盘的大小
    ChessBoard(0, 0, 1, 1, size); // 调用函数，移除(1, 1)位置的方块
    // 打印棋盘
    for (int i = 0; i < size; ++i) {
        for (int j = 0; j < size; ++j) {
            cout << board[i][j] << "  ";
        }
        cout << endl;
    }
    return 0;
}
```

## 循环日程表

> **符合分治策略的思想**，将所有的选手分为两半，n个选手的比赛日程就可以通过分成n/2个选手设计的比赛日程表来决定。采用递归的方式对选手进行割分，直至割分到只剩下1位选手时，比赛日程表就不在需要为其排列。
>
> **边界条件：**n = 1
>
> ### 算法思想
>
> 1. **基本思路**：每次将日程表分成四个相等的部分，然后递归地填充这些部分。
> 2. 递归处理
>    - 优先处理左上部分。优先处理右上部分。
> 3. 复制操作
>    - 根据已经填充好的左上部分，将其复制到右下部分。
>    - 根据已经填充好的右上部分，将其复制到左下部分。

``` c
int arr[8][8] = {0}; // 日程表数组
// y: 当前子部分的起始列
// len: 当前子部分的长度
void table(int arr[8][8], int y, int len) {
    if (len == 1) {
        arr[0][y] = y + 1; // 第0行
        return;
    }
   
    table(arr, y, len / 2);  // 递归处理左上部分
    table(arr, y + len / 2, len / 2); // 递归处理右上部分

    for (int i = 0; i < len / 2; ++i) {
        for (int j = 0; j < len / 2; ++j) {
            arr[len / 2 + i][y + len / 2 + j] = arr[i][y + j];// 左上部分复制到右下部分
            arr[len / 2 + i][y + j] = arr[i][y + len / 2 + j];// 右上部分复制到左下部分
        }
    }
}

```

## 逆序对数

> **逆序对**是指在一个数组中，如果存在一对元素 (i, j)，其中 i < j 但 arr[i] > arr[j]，则称这对元素为一个逆序对。在归并排序的过程中，我们可以在合并两个有序子数组时高效地计算出逆序对的数量。
>
> 1. **分割**：将数组分成两个大致相等的部分。
> 2. **递归求解**：递归地在每个部分中计算逆序对的数量。
> 3. **合并**：在合并两个有序子数组的过程中，统计跨过中间点的逆序对数量。
> 4. **累加结果**：将各个部分的逆序对数量累加起来，得到整个数组的逆序对总数

``` c
using namespace std;
int sum = 0;
int temp[100];//临时 辅助数组
void Merge(int arr[], int left, int right) {//合并
    int mid = (left + right) / 2;//分左右
    int i = left;
    int j = mid + 1;
    int k = 0;
    while (i <= mid and j <= right) {
        if (arr[i] <= arr[j])
            temp[k++] = arr[i++];
        else
            sum += mid - i + 1;// 左边比右边大 出现 逆序对求逆序对-------------------------------
        temp[k++] = arr[j++];
    }
    while (i <= mid)
        temp[k++] = arr[i++];
    while (j <= right)
        temp[k++] = arr[j++];
    k = 0;
    for (int l = left; l <= right; ++l)
        arr[l] = temp[k++];
}

void MergeSort(int arr[], int left, int right) {//n=8 right=7
    if (left == right)
        return;
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);
    MergeSort(arr, mid + 1, right);
    Merge(arr, left, right);
}
```

## 矩阵连乘

> 找到一个计算多个矩阵连乘的最优顺序，使得总的乘法次数最少。使用二维数组 `m` 来存储子问题的解，并使用另一个二维数组 `s` 来记录最优分割点，以便最后可以构造出最优解。
>
> ### 动态规划的思想
>
> 1. **定义子问题**：令 `m[i][j]` 表示从第 `i` 个矩阵到第 `j` 个矩阵的最小乘法次数。
>
> 2. **状态转移方程**：
>
>    - 如果 `i == j`，那么只有一个矩阵，不需要做任何乘法，所以 `m[i][i] = 0`。
>    - 如果 `i < j`，则考虑所有可能的分割点 `k`（`i <= k < j`），将矩阵链分成两部分 `A[i...k]` 和 `A[k+1...j]`，并计算这两部分的乘法次数加上合并这两部分的乘法次数。选择使总乘法次数最小的 `k` 作为最优分割点。
>    - 具体的状态转移方程为：dp[i] [j] = (i*≤*k*<*j)min(dp[i] [k] + dp[k + 1] [j] + p[i - 1] * p[k] * p[j], dp[i] [j]) 其中 `p` 是一个数组，表示每个矩阵的维度。`p_{i-1}` 是第 `i` 个矩阵的行数，`p_k` 是第 `k` 个矩阵的列数，也是第 `k+1` 个矩阵的行数，`p_j` 是第 `j` 个矩阵的列数。
>
> 3. **边界条件**：当 `i == j` 时，`m[i][j] = 0`，因为单个矩阵不需要进行乘法操作。
>
> 4. **确定子链长度**：从最短的子链（长度为2）开始，逐渐增加子链的长度，直到覆盖整个矩阵链。
>
> 5. **确定起点和终点**：对于每个子链长度，枚举所有可能的起点 `i` 和对应的终点 `j`。
>
> 6. **选择分割点**：在每个子链中，尝试所有可能的分割点 `k`，将子链分成两部分 `A[i...k]` 和 `A[k+1...j]`，并计算这两部分的乘法次数加上合并这两部分的乘法次数。
>
> 7. **更新最优解**：在所有可能的分割点 `k` 中，选择使得总乘法次数最小的那个 `k`，并将这个最小值记录到 `dp[i][j]` 中。
>
> 1. **matrixMultiply 函数**：
>    
>    - 对于单个矩阵的情况，`dp[i][i] = 0`，因为单个矩阵不需要做任何乘法。
>    
>    - 使用两层循环来处理不同长度的子链：
>      - 外层循环 `len` 表示当前考虑的子链长度。
>      - 内层循环 `i` 表示子链的起始位置。
>      
>    - 计算 `j` 作为子链的结束位置。
>    
>    - 初始化 `dp[i][j]` 为 `INT_MAX`，以便在后续比较中找到最小值。
>    
>    - 使用内层循环 `k` 来尝试不同的分割点，并计算分割后的总乘法次数 `temp`。
>    
>    - 更新 `dp[i][j]` 为 `temp` 的最小值。
>    
>      
>    
>    矩阵链乘法问题使用动态规划解决时的时间复杂度是 
>    𝑂(𝑛**³**)这是因为算法中有三层嵌套循环，每层循环的迭代次数都与 n 有关，导致总的时间复杂度为立方级。
>    
>    - **时间复杂度**：O(n3)*O*(*n*3)
>    - **空间复杂度**：O(n2)

``` c
int dp[10][10];
int n = 6;
int p[7] = {30, 35, 15, 5, 10, 20, 25};

void matrixMultiply() {
    for (int i = 1; i <= n; ++i)
        dp[i][i] = 0;//单个矩阵不需要乘法
    for (int len = 2; len <= n; ++len) {//len表示 要求连乘矩阵的长度
        for (int i = 1; i <= n - len + 1; ++i) {//i 为开始位置
            int j = i + len - 1;//j 结束位置
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {//p[i - 1] 是第 i 个矩阵的行数。
                dp[i][j] = min(dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j], dp[i][j]);//维护最小值 注意是加号
            }// p[k] 是第 k 个矩阵的列数（也是第 k+1 个矩阵的行数）。
        }//p[j] 是第 j 个矩阵的列数。
    }
}
```

## 最长公共子序列

> 1. **定义状态**：
>    - `dp[i][j]` 表示 `X` 的前 `i` 个字符和 `Y` 的前 `j` 个字符的最长公共子序列的长度。
> 2. **状态转移方程**：
>    - 如果 `X[i-1] == Y[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
>    - 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
> 3. **边界条件**：
>    - `dp[0][j] = 0`，`dp[i][0] = 0`。
>    - **时间复杂度**：`O(m * n)`
>    - **空间复杂度**：`O(min(m, n))`

``` c
char x[] = {'0', 'i', 'f', 'g', 'h', 'k', 'u'};
char y[] = {'0', 'e', 'h', 't', 'u'};//下标从1开始算 第一个不算入n
int sum = 0;
int n = 6, m = 4;
int dp[105][105];//dp i j a b
int LCS() {
    for (int i = 1; i <= n; ++i)   //设置边界
        dp[i][0] = 0;
    for (int i = 1; i <= m; ++i)
        dp[0][i] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (x[i] == y[j]) 
                dp[i][j] = dp[i - 1][j - 1] + 1;
             else 
               dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); 
        }
    }
}
```

## 最大连续字段和

> 1. **状态转移方程**：
>
>    - 对于每个 `i`，`dp[i]` 表示以 `arr[i]` 结尾的最大子段和。
>
>    - dp[i]
>
>      可以通过以下两种情况取最大值：
>
>      - 当前元素 `arr[i]` 自己作为一个新的子段。
>      - 当前元素 `arr[i]` 加上前一个子段的和 `dp[i-1]`。
>
> - `dp[i] = max(dp[i-1] + arr[i], arr[i])`。
> - `sum = max(sum, dp[i])`。

``` c
int sum = 0;
int arr[]={0,1,3,-2,4,-3,1};
int n=6;
int dp[25]={0};//dp i j a b
int MaxSub() {
    for (int i = 1; i <= n; ++i)
        dp[i]=arr[i];
    sum=dp[1];
    for (int i = 2; i <= n; ++i){
        dp[i]=max(arr[i],dp[i-1]+arr[i]);
        sum=max(dp[i],sum);
    }
}
```

## 01背包

> ### 动态规划思想
>
> 1. **定义状态**：
>    - `dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。
> 2. **状态转移方程**：
>    - 如果不选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j]`。
>    - 如果选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j-weights[i]] + values[i]`，前提是 `j >= weights[i]`。
>    - 综合起来，`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weights[i]] + values[i])`。
> 3. **边界条件**：
>    - `dp[0][j] = 0` 对于所有 `j`，因为没有物品时，价值为 0。
>    - `dp[i][0] = 0` 对于所有 `i`，因为背包容量为 0 时，无法装入任何物品。
> 4. **最终结果**：
>    - `dp[n][capacity]` 即为所求的最大价值。

``` c
int w[] = {0, 2, 3, 4, 5};
int v[] = {0, 3, 4, 5, 6};//下标从1开始
int n = 4;//个数
int c = 5;//容量
int dp[11][11] = {0}; //`dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。

int knapsack() {
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= c; ++j) {
            if (w[i] <= j) {//可以放下
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);//放和不放 取价值最大
            } else {//放不下
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
}
```

## 路径问题

> ### 动态规划思想
>
> 1. **定义状态**：
>    - 用 `dp[i][j]` 表示从起点 (0, 0) 到达位置 (i, j) 的路径数。
> 2. **状态转移方程**：
>    - 如果当前位置 (i, j) 可以从上方 (i-1, j) 和左侧 (i, j-1) 到达，则 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
>    - 特殊情况：如果在第一行（i=0），则只能从左侧到达；如果在第一列（j=0），则只能从上方到达。
> 3. **边界条件**：
>    - 起点 (0, 0) 只有一种方式到达，即 `dp[0][0] = 1`。
>    - 第一行和第一列的每个位置都只有一种方式到达，即 `dp[0][j] = 1` 和 `dp[i][0] = 1`。
> 4. **最终结果**：
>    - `dp[N-1][M-1]` 即为从起点到终点的路径总数。
>    - **时间复杂度**：O(m×n)
>    - 空间复杂度
>      - 标准解法为 O(m×n)

``` c
int n = 3;
int m = 3;
int dp[20][20];
int countPaths() {
    for (int i = 0; i < n; ++i){
        for (int j = 0; j <m ; ++j) {
            if (i==0 or j==0)//边界条件
                 dp[i][j]=1;
            else
                dp[i][j]= dp[i][j-1]+dp[i-1][j];//上来 + 左来
        }
    }
}
```

## 完全背包

> 1. **定义状态**：
>
>    - `dp[i][j]` 表示前 `i` 个物品在容量为 `j` 的背包中能够获得的最大价值。
>
> 2. **状态转移方程**：
>
>    - 如果不选择第 `i` 个物品，则 `dp[i][j] = dp[i-1][j]`。
>    - 如果选择第 `i` 个物品，并且 `j >= weights[i]`，则可以选择一次或多次，此时的价值为 `dp[i][j - weights[i]] + values[i]`。
>    - 因此，`dp[i][j] = max(dp[i-1][j], dp[i][j - weights[i]] + values[i])`。
>
> 3. **边界条件**：
>
>    - `dp[0][j] = 0` 对于所有 `j`，因为没有物品时，价值为 0。
>    - `dp[i][0] = 0` 对于所有 `i`，因为背包容量为 0 时，无法装入任何物品。
>
> 4. **最终结果**：
>
>    - `dp[n][capacity]` 即为所求的最大价值。
>
>    ### 为什么使用 `dp[i][j - weights[i-1]]` 而不是 `dp[i-1][j - weights[i-1]]`？
>
>    - 在 0/1 背包问题中，每个物品只能选择一次，因此使用 `dp[i-1][j - weights[i-1]]` 来表示不包含当前物品 `i` 的情况。
>    - 在完全背包问题中，每个物品可以选择多次，因此使用 `dp[i][j - weights[i-1]]` 来表示包含当前物品 `i` 的情况，这样可以继续在剩余容量中选择当前物品。

``` c
int n=3;
int w[] = {0,1, 3, 4};
int v[] = {0,15, 20, 30};
int c=6;
int dp[10][10];
int knapsack() {
    memset(dp,0,sizeof(dp));//初始化为0
    for (int i = 1; i <= n; ++i){
        for (int j = 1; j <=c ; ++j) {
            if (w[i]<=j)//放得下 放i 或者不放i
                 dp[i][j]= max(dp[i-1][j],dp[i][j-w[i-1]]+v[i-1]);//可重复选 i=i 不能重复选i=i-1
            else
                dp[i][j]=dp[i-1][j];
        }
    }
}//60
```

### 合并石子

> 1. **定义状态**：
>    - `dp[i][j]` 表示将第 `i` 堆到第 `j` 堆石子合并成一堆的最小代价。
> 2. **状态转移方程**：
>    - 对于每一个区间 `[i, j]`，我们可以选择一个位置 `k`（`i <= k < j`），将 `[i, k]` 和 `[k+1, j]` 两部分先分别合并，然后再将这两部分合并。
>    - 因此，`dp[i][j] = min(dp[i][k] + dp[k+1][j] + pre[i][j])`，其中 `pre[i][j]` 表示从第 `i` 堆到第 `j` 堆石子的总数量。//左边 + 右边 加咱俩的代价
> 3. **边界条件**：
>    - `dp[i][i] = 0`，因为单个石子堆不需要合并。
>    - `pre[i][i] = stones[i]`，表示单个石子堆的数量。
> 4. **最终结果**：
>    - 不跨越环的情况可以通过直接计算 `dp[0][n-1]` 得到。
>    - 和矩阵连乘几乎一样
>    - - `i + len - 1 <= n` 确保区间的终点 `j` 不会超过数组的范围。
>      - `j = i + len - 1` 是区间的终点。
>      - 因此，`i + len - 1 <= n` 等价于 `i <= n - len + 1`。
>    - **改写后的写法**：
>      - `i <= n - len + 1` 直接确保了 `i` 的最大值不会超过 `n - len + 1`。
>      - 这样可以保证 `j = i + len - 1` 仍然在有效范围内。

``` c
int arr[] = {0, 3, 4, 3};//下标从1开始
int n = 3;
int pre[10];//前缀和数组
int dp[10][10];
//https://www.bilibili.com/video/BV1PG411H7sj/?spm_id_from=333.880.my_history.page.click&vd_source=c2bfbb10b5c8153f1e5c3785b908c9b9
int minCostToMergeStones() {
    for (int i = 1; i <= n; ++i)
        pre[i] = pre[i - 1] + arr[i];
    memset(dp, 0, sizeof(dp));//初始化0  单独1堆合并代价为
    for (int len = 2; len <= n; ++len) {//和矩阵连乘很像  最少两堆连乘
        for (int i = 1; i <= n-len+1; ++i) {//i 开始堆下标
            int j = i+len-1;//结束堆 下标
            dp[i][j] = INT_MAX;
            for (int k = i; k < j; ++k) {
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + pre[j] - pre[i-1]);
            }
        }
    }
}

```

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241016090224978-1729040546382-11.png" alt="image-20241016090224978" style="zoom:50%;" />



### 最长递增子序列

> 1. **定义状态**：
>    - `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
> 2. **状态转移方程**：
>    - 对于每一个 `i`，我们需要检查所有 `j < i` 的位置，如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`。
>    - 如果没有这样的 `j`，则 `dp[i] = 1`，因为单个元素本身也是一个递增子序列。
> 3. **边界条件**：
>    - `dp[0] = 1`，因为单个元素本身就是一个递增子序列。
> 4. **最终结果**：
>    - `max(dp[0], dp[1], ..., dp[n-1])` 即为所求的最长递增子序列的长度。

``` c
int nums[] = {10, 9, 2, 5, 3, 7, 101, 18};
int n = 8;
int dp[20];
int maxLen=INT_MIN;

int lengthOfLIS(int *nums, int n) {
    if (n == 0) return 0;
    for (int i = 0; i < n; ++i)
        dp[i]=1;//初始化 最少包含自己 为1

    for (int i = 1; i < n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j]) {
            //满足升序
            dp[i]=max(dp[i],dp[j]+1);
            maxLen= max(maxLen,dp[i]);
            }
        }
    }
}
```

## 活动安排

> ### 问题描述
>
> 假设你有一组活动，每个活动都有一个开始时间和结束时间。这些活动需要使用同一资源（比如同一个会议室），并且在同一时间只能有一个活动使用该资源。你的任务是选出尽可能多的活动来安排，使得被选中的活动之间不会发生时间上的冲突。
>
> ### 解决思路
>
> 采用贪心策略。基本思想如下：
>
> 1. **排序**：首先按照活动的结束时间对所有活动进行升序排序。如果两个活动有相同的结束时间，则可以按开始时间排序。
> 2. **选择活动**：从最早结束的活动开始考虑，选择第一个活动加入集合。然后，对于剩下的活动，总是选择与当前已选活动集合中最后一个活动不冲突的第一个活动加入集合。
> 3. **重复步骤2**：持续执行步骤2直到遍历完所有的活动。
>
> 这种方法确保了在每一步都做出局部最优的选择，从而最终得到全局最优解。

``` c
typedef struct {
    int id;//活动的编号
    int start;//开始时间
    int finish;//结束时间
    int flag;//活动是否被选择
} Activity;
int sum=0;
//下标从1开始
Activity arr[] = {{0, 0, 0},
                         {1, 5, 9},
                         {2, 1, 2},
                         {3, 3, 4},
                         {4, 0, 6},
                         {5, 5, 7},
                         {6, 8, 9}};
int n = 6;
bool cmp(Activity a, Activity b) {
    return a.finish < b.finish; //结束时间早的排在前面
}

void fun() {
    sort(arr+1,arr+n, cmp);// 结束时间从小到大排序 cmp不需要括号
    int pre=1;//以第一个活动结束为开始
    arr[1].flag=1;
    sum++;
    for (int i = 2; i <= n; ++i){
        if (arr[pre].finish<=arr[i].start){//后一个活动开始时间 = 也可以晚于前一个结束时间 不冲突
            sum++;
            pre=i;
            arr[i].flag=1;
        }
    }
}
```

## 部分背包

>   其中每个物品可以被分割成任意小的部分。目标是在不超过背包容量的前提下，使得装入背包的物品总价值最大。这个问题可以通过贪心算法高效解决。
>
> ### 问题描述
>
> - **输入**：一组物品，每个物品有一个重量 `w` 和一个价值 `v`；一个背包，其最大承重为 `W`。
> - **输出**：选择哪些物品以及每种物品的数量，使得装入背包的物品总价值最大，且总重量不超过 `W`。
>
> ### 解决思路
>
> 1. **计算单位重量的价值**：对于每个物品，计算它的单位重量的价值，即 `value/weight`。
> 2. **排序**：根据单位重量的价值对所有物品进行降序排序。
> 3. **选择物品**：从单位重量价值最高的物品开始，尽可能多地选取该物品，直到不能完全放入下一个物品为止。然后继续选择下一个单位重量价值次高的物品，重复此过程，直到背包满或所有物品都已考虑。

``` c
typedef struct {
    int id;//可以不用这题
    int v;
    int w;
} goods;
goods arr[] = {{0, 0,   0,},
               {1, 60,  10},
               {2, 100, 20},
               {3, 120, 30}};
int c = 50;
int n = 3;
int sum = 0;

bool cmp(goods a, goods b) {//根据价值的平均价值 从高到低进行排序
    return a.v / a.w > b.v / b.w;
}

void fractionalKnapsack() {
    for (int i = 1; i <= n; ++i) {
        if (c >= arr[i].w) {//可全部放下
            sum += arr[i].v;
            c -= arr[i].w;
        } else {//部分可放下
            sum += c * (arr[i].v / arr[i].w);
            return;
        }
    }
}
```

### 简单装载

> 最优装载问题（也称为简单装载问题）是背包问题的一种特殊情况，其中每个物品的重量不同，但价值相同。目标是在不超过给定重量限制的情况下，装入尽可能多的物品。这个问题可以通过贪心算法高效解决。
>
> ### 问题描述
>
> - **输入**：一组物品，每个物品有一个重量 `w`；一个船或容器的最大承重为 `W`。
> - **输出**：选择哪些物品，使得装入的物品数量最多，且总重量不超过 `W`。
>
> ### 解决思路
>
> 1. **排序**：按照物品的重量从小到大进行排序。
> 2. **选择物品**：从最轻的物品开始，依次选择物品放入船或容器中，直到不能再装入更多物品为止。

``` c
typedef struct {
    int id;
    int w;//重量
    int flag;//是否选取
} container;
container arr[] = {{0, 0},
                   {1, 5},
                   {2, 3},
                   {3, 4},
                   {4, 2}};
int n = 4;
int c = 10;//容量
int sum = 0;
bool cmp(container a, container b) {//重量从小到大 排序
    return a.w < b.w;
}

void optimalLoading() {
    sort(arr + 1, arr + n, cmp);
    for (int i = 1; i <= n; ++i) {
        if (c >= arr[i].w) {
            arr[i].flag = 1;
            c -= arr[i].w;
            sum++;
        }
    }
}

```



单源最短路径：给定带权有向图G和源点v0 , 求从v0到G中其余各顶点的最短路径。

==权值相同的边不属于可以相互替代的关系==  最小生成树的充要条件

### Dijkstra（最短路径）

> ### Dijkstra算法思想 
>
> 1. **初始化**：
>    - 为每个顶点设置一个距离值（`dist`），表示从源顶点到该顶点的最短路径长度。初始时，源顶点的距离设为0，其他所有顶点的距离设为无穷大（表示尚未找到路径）。
>    - 创建一个集合`S`，用于存储已经确定最短路径的顶点。初始时，`S`为空。
> 2. **选择当前距离最小的顶点**：
>    - 从未处理的顶点中选择一个距离最小的顶点`u`，将其加入集合`S`中。这意味着我们已经找到了从源顶点到`u`的最短路径。
> 3. **更新邻接顶点的距离**：
>    - 对于顶点`u`的所有邻接顶点`v`，如果通过`u`到达`v`的路径比当前已知的从源顶点到`v`的路径更短，则更新`v`的距离值。
> 4. **重复步骤2和3**：
>    - 重复上述过程，直到所有顶点都被加入集合`S`中，或者没有更多的顶点可以更新为止。
>
> - **初始化**：设置初始距离和路径。
> - **选择最小距离顶点**：从未处理的顶点中选择距离最小的顶点。
> - **更新距离**：更新通过该顶点到达其他顶点的距离。
> - **重复**：重复上述过程直到所有顶点都被处理

``` c

typedef struct {
    int edges[25][25];
    int vexNum;
    int arcNum;
} MGraph;

int visited[25] = {0};//是否访问
int path[25];   // 原点v到顶点i的前一个顶点
int dist[25];          // 源点到各个顶点的距离

void Dijkstra(MGraph *g, int v) {
    for (int i = 0; i < g->vexNum; ++i) {//初始化判断是否有边
        dist[i] = g->edges[v][i];
        if (g->edges[v][i] < INT_MAX) {
            path[i] = v;//前一个顶点
        } else {
            path[i] = -1;
        }
    }
    visited[v] = 1;//标记源顶点已访问
    dist[v] = 0;
    path[v] = -1;

    for (int i = 1; i < g->vexNum; ++i) {//选择未处理顶点中距离最小的顶点
        int minn = INT_MAX;//最小值
        int minVex;//最小值下标
        for (int j = 0; j < g->vexNum; ++j) {
            if (dist[j] < minn and visited[j] == 0) {
                minn = dist[j];
                minVex = j;//找到最小值
            }
        }
        visited[minVex] = 1;

        for (int j = 0; j < g->vexNum; ++j) {//更新邻接顶点的距离：
            if (visited[j] == 0 and dist[j] > dist[minVex] + g->edges[minVex][j]) {   //以为 minVex 为中介 更近
                dist[j] = dist[minVex] + g->edges[minVex][j];
                path[j] = minVex;
            }
        }
    }
}
```

### prime

> **基本思想**:
>
> - Prim算法从任意一个顶点开始构建MST，逐步增加新的顶点直到所有的顶点都被包含在内。每次选择与当前MST连接的最短边所对应的顶点加入到MST中。
> - 算法的核心是维护一个顶点集合`S`，它表示当前已经加入到MST中的顶点。初始时`S`只包含一个顶点，然后不断地从剩余的顶点中选择距离`S`最近的一个顶点加入到`S`中，直到所有顶点都被加入为止。
>
> **步骤**:
>
> 1. 选择任意一个顶点作为起始点，将其加入到MST中。
> 2. 对于已加入MST的顶点，找到与之相邻且不在MST中的顶点之间的最小权值边，将该顶点及其相连的边加入到MST中。
> 3. 重复上述过程，直到MST包含了所有的顶点。

> Prim 算法是一种用于找到加权无向图的最小生成树（Minimum Spanning Tree, MST）的贪心算法。其主要思想是从一个起始顶点开始，逐步扩展生成树，直到包含图中的所有顶点。每一步都选择当前未加入生成树的顶点中与生成树相连的边权重最小的那个顶点，并将其加入生成树。
>
> ### 代码的思想
>
> 1. **初始化**：
>    - `sum` 用于存储最小生成树的总权重。
>    - `visited` 数组用于标记顶点是否已经被加入到MST中。
>    - `lowcost` 数组用于存储从已加入MST的顶点到未加入MST的顶点的最小边权重。
> 2. **选择起点**：
>    - 将起始顶点 `v` 标记为已访问。
>    - 初始化 `lowcost` 数组，将起始顶点到其他顶点的距离赋值给 `lowcost` 数组，如果不存在直接连接的边，则设置为无穷大（`INT_MAX`）。
> 3. **迭代过程**：
>    - 执行 `g->vexNum - 1` 次循环，每次选择一个顶点加入MST。
>    - 在每次循环中，找到 `lowcost` 数组中最小的值 `minn` 及其对应的顶点 `k`。
>    - 将 `minn` 加入 `sum`，并将顶点 `k` 标记为已访问。
>    - 更新 `lowcost` 数组，检查新加入的顶点 `k` 到其他未访问顶点的边权重，如果这些边的权重小于 `lowcost` 中的值，则更新 `lowcost`。
> 4. **输出结果**：
>    - 最后输出最小生成树的总权重 `sum`。 ==时间复杂度：O(n²)，适合用于边稠密图==

``` c
typedef struct {
    int edges[25][25];
    int vexNum;
    int arcNum;
} MGraph;

void prime(MGraph *g, int v) {
    int sum = 0;
    int visited[25];
    int lowcost[25];
    for (int i = 1; i < g->vexNum; ++i) {
        lowcost[i] = g->edges[v][i];//候选边初始化
        visited[i] = 0;
    }

    visited[v] = 1;//起点
    int j, k;
    for (int i = 1; i < g->vexNum; ++i) {//执行n-1次
        int minn = INT_MAX;
        for (j = 1; j < g->vexNum; j++) {//寻找最小值
            if (lowcost[j] < minn and visited[j] == 0) {
                minn = lowcost[i];// 更新最小边权重
                k = j;//最小权值顶点
            }
        }
        sum += minn;
        visited[k] = 1;

        for (int j = 1; j <= g->vexNum; ++j) {//维护候选中的最小值
            if (visited[j] == 0 and g->edges[k][j] < lowcost[j])//未被访问，且最新的顶点到j的距离比原来近
                lowcost[j] = g->edges[k][j]; //更新 不是缔结斯特啦 不会以新节点为中间结点进行更新
        }
    }
    printf("minn:%d", sum);
}
```

### Kruskal

> **基本思想**:
>
> - Kruskal算法通过将所有的边按照权值从小到大排序，然后依次选取最小的边来构建MST，只要这条边不会形成环路。
> - 算法的关键在于如何判断添加一条边是否会形成环路，这通常使用并查集
>
> **步骤**:
>
> 1. 将图中的所有边按照其权重进行升序排序。
> 2. 初始化一个空的MST，并为每个顶点创建一个独立的集合。
> 3. 遍历排序后的边列表，对于每条边，检查这条边连接的两个顶点是否属于同一个集合。如果不是，则将这条边加入到MST中，并合并这两个顶点所在的集合。
> 4. 重复上述过程，直到MST包含了足够的边数（即顶点数减一），或者所有可用的边都已经被检查过。
>
> 

> 1. ### **定义结构体**：
>
>    - `Edge` 结构体用于表示图中的边，包含两个顶点 `vex1` 和 `vex2` 以及边的权重 `weight`。
>    - `MGraph` 结构体用于表示图，包含顶点数 `vexNum`、边数 `EdgeNum` 和边表 `edges`。
> 2. **比较函数**：
>    
>    - `cmp` 函数用于对边进行排序，按边的权重从小到大排序。
> 3. **并查集操作**：
>    - `Initial` 函数初始化并查集，使每个顶点的父节点指向自己。
>    - `getRoot` 函数查找顶点的根节点。
>    - `isSameRoot` 函数检查两个顶点是否属于同一个集合。
>    - `merge` 函数合并两个集合。
> 4. **Kruskal 算法**：
>    - `Kruskal` 函数实现了克鲁斯卡尔算法，计算最小生成树的总权重。
>    - 初始化并查集。
>    - 对边进行排序。
>    - 依次选择每条边，如果边的两个顶点不在同一个集合中，则加入 MST 并合并这两个顶点所在的集合。
>    - 当生成树中的边数达到 `vexNum - 1` 时，算法结束。
>    - 如果图不连通，返回 -1 并打印提示信息。 ==时间复杂度：O(elog2e)， 适合用于边稀疏图==

``` c
#define ElemType char
#define MAX_COST 0x7fffffff
const int MAX_SIZE = 23; // 最大容量

// 定义边的结构体
typedef struct Edge {
    int vex1, vex2; // 边所依附的两个顶点
    int weight;     // 权值
} Edge;

// 定义图的结构体
typedef struct {
    int vexNum;     // 顶点数
    int EdgeNum;    // 边数
    Edge edges[MAX_SIZE]; // 边表
} MGraph;

// 比较函数，用于 qsort 排序
bool cmp(const Edge &a, const Edge &b) {
    return a.weight < b.weight;
}

// 初始化并查集
void Initial(int roots[], int n) {
    for (int i = 0; i < n; ++i) {
        roots[i] = i; // 默认自己是自己的父节点
    }
}

// 查找父节点，即根节点
int getRoot(int roots[], int x) {
    while (roots[x] != x) 
        x = roots[x];
    return x;
}

// 检查两个顶点是否属于同一个集合
bool isSameRoot(int roots[], int x1, int x2) {
    return getRoot(roots, x1) == getRoot(roots, x2);
}

// 合并两个集合
void merge(int roots[], int x1, int x2) {
    int s1 = getRoot(roots, x1);
    int s2 = getRoot(roots, x2);
    if (s1 != s2) 
        roots[s1] = s2;
}

// Kruskal 算法
int Kruskal(MGraph *g) {
    int sum = 0; // 初始化总权重
    int edgeNum = g->EdgeNum;
    int vexNum = g->vexNum;
    int count = 0;
    int roots[g->vexNum]; // 并查集
    Initial(roots, vexNum); // 初始化并查集
    // 对边进行排序
    sort(g->edges, g->edges + edgeNum, cmp);

    for (int i = 0; i < edgeNum; ++i) {
        if (!isSameRoot(roots, g->edges[i].vex1, g->edges[i].vex2)) {// 如果两个顶点不在同一个集合中
            sum += g->edges[i].weight;
            printf("Edge %d-%d with weight %d is included in MST\n", g->edges[i].vex1, g->edges[i].vex2, g->edges[i].weight);
            merge(roots, g->edges[i].vex1, g->edges[i].vex2);
            count++; // 生成树的边数+1
            if (count == vexNum - 1)
                break; // 达到生成树完成构造
        }
    }

    if (count == vexNum - 1) {
        printf("Total weight of the Minimum Spanning Tree: %d\n", sum);
        return sum;
    } else {
        printf("The graph is not connected, cannot form a Minimum Spanning Tree.\n");
        return -1; // 图不连通
    }
}

```

### HuffmanTree

> 1. **定义结构体**： 代码（了解）
>    - `HTNode` 结构体表示哈夫曼树的节点，包含四个字段：`weight`（权重）、`parent`（父节点索引）、`left`（左子节点索引）和 `right`（右子节点索引）。
>    - `HuffmanTree` 是一个类型别名，用于表示哈夫曼树的数组。
>    - `HuffManCode` 是一个类型别名，用于存储哈夫曼编码串的头指针数组。
> 2. **函数定义**：
>    - `Select`：选择两个最小的结点，这两个结点的 `parent` 为 0（即它们还没有被合并）。
>    - `CreateHuffmanTree`：初始化哈夫曼树的节点，并通过不断选择两个最小的结点来构建哈夫曼树。
> 3. 初始化哈夫曼树的节点，设置初始权重、父节点、左子节点和右子节点。
> 4. 计算非叶子节点的数量 `m`。
> 5. 初始化非叶子节点。
> 6. 通过不断选择两个最小的结点并合并它们来构建哈夫曼树。
> 7. 每次合并时，创建一个新的内部节点，其权重为两个最小结点的权重之和，并更新相关节点的 `parent`、`left` 和 `right` 字段。

``` c
const int N = 20;//叶子结点的最大值
#define M 2*N-1 //所有结点数量的最大值
using namespace std;
typedef struct {
    int weight;
    int parent;
    int left;
    int right;
} HTNode, HuffmanTree[M + 1];//0号不用

void Select(HuffmanTree ht, int n, int &s1, int &s2) {
    //选择最小的结点 parent=0 赋值给s1 s2
    int i, min1 = INT_MAX, min2 = INT_MAX;
    s1 = 0;
    s2 = 0;
    for (int i = 1; i <= n; ++i) {
        if (ht[i].parent == 0) {
            //是根结点 就是下面包含叶子
            if (ht[i].weight < min1) {
           
                min2 = min1; //比min1小
                s2 = s1;
                min1 = ht[i].weight;
                s1 = i;//min1 最小  min2 次小
            } else if (ht[i].weight < min2) {
                min2 = ht[i].weight;
                s2 = i;//比min2 小
            }
        }
    }
}

void CreateHuffmanTree(HuffmanTree ht, int w[], int n) {
    //w  要构造的那些结点 比如 13  57 23 4
    int i;
    for (int i = 1; i <= n; ++i) {
        ht[i].weight = w[i - 1];//丢到1-n
        ht[i].parent = 0;
        ht[i].left = 0;
        ht[i].right = 0;
    }
    int m = 2 * n - 1;// 实际 所有结点
    for (i = n + 1; i <= m; ++i) {//n+1 -m 存放非叶子结点 初始化
        ht[i].weight = 0;//丢到1-n
        ht[i].parent = 0;
        ht[i].left = 0;
        ht[i].right = 0;
    }
    //初始完毕 创建非叶节点
    int s1, s2;
    for (i = n + 1; i <= m; ++i) {
        Select(ht, i - 1, s1, s2);//每次选出2个最小的结点 切parent为0 也就是根结点不是叶结点
        ht[i].weight = ht[s1].weight + ht[s2].weight;
        ht[s1].parent = i;
        ht[s2].parent = i;
        ht[i].left = s1;//左边更小
        ht[i].right = s2;
    }
}

```



``` c
// 定义节点结构体
typedef struct _Node {
    // 字符
    char c;
    // 频率
    int freq;
    // 左孩子
    struct _Node *left;
    // 右孩子
    struct _Node *right;
} Node;

// NodePtr是Node的指针类型
typedef Node *NodePtr;

// 用于存储路径的栈
int path_stack[MAX_SIZE];
int stack_top = 0;

// 打印哈夫曼树的函数（假设已经定义）
void print_huffman_tree(NodePtr root) {
    // 递归打印哈夫曼编码
    if (root != NULL) {
        if (root->left || root->right) {
            path_stack[stack_top++] = 0; // 左子树路径标记为0
            print_huffman_tree(root->left);
            stack_top--;
            path_stack[stack_top++] = 1; // 右子树路径标记为1
            print_huffman_tree(root->right);
            stack_top--;
        } else {
            printf("%c: ", root->c);
            for (int i = 0; i < stack_top; i++) {
                printf("%d", path_stack[i]);
            }
            printf("\n");
        }
    }
}

int main() {
    // 定义小根堆，并传入比较函数
    MinHeap* heap = create_min_heap(MAX_SIZE, compare);

    // 字符数量
    int n;
    scanf("%d", &n);

    // 读取每个字符及其频率，并创建节点放入小根堆
    for (int i = 0; i < n; i++) {
        NodePtr node = create_node();
        // 每个下标分别代表a, b, c, d, ...以此类推
        node->c = 'a' + i;
        scanf("%d", &node->freq);
        // 放入小根堆
        push(heap, node);
    }

    // 构建哈夫曼树
    while (heap->size >= 2) {
        // 从堆顶取出最小的两个元素
        NodePtr node1 = top(heap);
        pop(heap);
        NodePtr node2 = top(heap);
        pop(heap);

        // 组成新的节点
        NodePtr new_node = create_node();
        new_node->c = '\0'; // 新节点不是叶子节点，所以字符为空
        new_node->freq = node1->freq + node2->freq;
        new_node->left = node1;
        new_node->right = node2;

        // 放回到堆中
        push(heap, new_node);
    }

    // 此时堆中应当只有一个元素，该元素就是哈夫曼树的根
    NodePtr huffman_tree_root = top(heap);

    // 输出每个字符的编码
    print_huffman_tree(huffman_tree_root);

    // 释放堆内存
    free(heap->array);
    free(heap);

    return 0;
}
```



## 回溯

### 排列树&&子集树

> ### 1. 排列树（Permutation Tree） O(n!)   回溯空间通常O(n)
>
> 排列树通过固定一个位置，然后递归地对剩余的位置进行全排列。每次递归调用时，交换当前元素与后续元素的位置，以生成不同的排列。
>
> ### 2. 子集树（Subset Tree）O(m^n)
>
> 子集树通过选择或不选择某个元素来生成所有可能的排列。这种方法通常使用一个布尔数组 `used` 来标记哪些元素已经被使用过。
>
> #### 排列树
>
> 1. **函数 `permute`**：
>    - 输入参数是数组 `arr`、起始位置 `start` 和结束位置 `end`。
>    - 如果 `start` 等于 `end`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
>    - 否则，通过一个循环遍历从 `start` 到 `end` 的每个位置，将 `start` 位置的元素与当前位置的元素交换，然后递归调用 `permute` 生成下一个位置的排列。
>    - 在递归调用返回后，再次交换回来以恢复原始数组状态，以便进行下一次交换。
>
> #### 子集树
>
> 1. **函数 `permuteSubsetTree`**：
>    - 输入参数是数组 `arr`、数组长度 `n`、当前结果数组 `result`、当前处理的位置 `pos` 和标记数组 `used`。
>    - 如果 `pos` 等于 `n`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
>    - 否则，通过一个循环遍历数组中的每个元素，如果该元素没有被使用过，则将其标记为已使用，加入到 `result` 中，然后递归调用 `permuteSubsetTree` 生成下一个位置的排列。
>    - 在递归调用返回后，将该元素从 `result` 中移除，并将其标记为未使用，以便进行下一次选择。
>
> ### 总结
>
> - **排列树**：通过交换数组中的元素来生成所有可能的排列。每次递归调用时，固定一个位置，然后递归地对剩余的位置进行全排列。
> - **子集树**：通过选择或不选择某个元素来生成所有可能的排列。这种方法通常使用一个布尔数组 `used` 来标记哪些元素已经被使用过。
>
> 这两种方法都能有效地生成数组的所有排列，选择哪种方法取决于具体的需求和偏好。排列树的方法在实现上较为直观，而子集树的方法则更符合回溯法的思路。

### 全排列

> **函数 `permute`**：
>
> - 输入参数是数组 `arr`、起始位置 `start` 和结束位置 `end`。
> - 如果 `start` 等于 `end`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
> - 否则，通过一个循环遍历从 `start` 到 `end` 的每个位置，将 `start` 位置的元素与当前位置的元素交换，然后递归调用 `permute` 生成下一个位置的排列。
> - 在递归调用返回后，再次交换回来以恢复原始数组状态，以便进行下一次交换。

``` c
//排序树
void dfs(int arr[], int n, int step) {//排列树
    if (step >= n)//一次排序结束
        print(arr, n);
    else {
        for (int i = step; i < n; ++i) {//从step 开始 0开始
            swap(arr[step], arr[i]);
            dfs(arr, n, step+1);
            swap(arr[step], arr[i]);
        }
    }
}
```

> **函数 `permuteSubsetTree`**：
>
> - 输入参数是数组 `arr`、数组长度 `n`、当前结果数组 `result`、当前处理的位置 `pos` 和标记数组 `used`。
> - 如果 `pos` 等于 `n`，表示已经生成了一个完整的排列，调用 `printArray` 函数打印该排列。
> - 否则，通过一个循环遍历数组中的每个元素，如果该元素没有被使用过，则将其标记为已使用，加入到 `result` 中，然后递归调用 `permuteSubsetTree` 生成下一个位置的排列。
> - 在递归调用返回后，将该元素从 `result` 中移除，并将其标记为未使用，以便进行下一次选择。

``` c
//子集树
void permuteSubsetTree(int arr[], int result[], int n, int step) {//子集树
    if (step >=n) { // 递归终止条件
        print(result, n);
    } else {
        for (int i = step; i < n; ++i) {
                result[step] = arr[i]; // 将当前元素放入结果数组
                permuteSubsetTree(arr, result, n,step + 1); // 递归调用
                result[step] = 0;//恢复
            }
        }
    }//子集树 只能从下一个选 类似去重
}
```



### 排列子集模板

> 1. 回溯与分支限界的区别仅在于遍历解空间树的方式不同，关注的结果不同； 
>
> 2. 这两个方法都可以排除明显不符合题目要求的结点来加快计算，这叫剪枝； 
>
>    很少有题目会单独考分支限界法（最短路径不算）； 
>
>    排列树和子集树的模板要会写。

### 简单装载(回溯)

> 1. **全局变量**：
>    - `w` 数组存储了每个物品的重量，注意数组下标从1开始。
>    - `n` 表示物品的数量。
>    - `c` 表示背包的容量。
>    - `maxw` 用于记录当前找到的最大重量。
>    - `x` 数组用于记录最优解，即哪些物品被选中。
> 2. **函数 `dfs`**：
>    - 输入参数包括当前步骤 `step`、当前重量 `cw`、剩余重量 `rw` 和当前选择方案 `op`。
>    - 如果 `step > n`，表示已经处理完所有物品，到达了一个叶节点。
>      - 如果当前重量 `cw` 大于 `maxw`，则更新 `maxw` 并将当前选择方案 `op` 复制到 `x` 中。
>    - 否则，继续处理当前物品：
>      - 如果当前重量加上当前物品的重量不超过背包容量 `c`，则选择当前物品，并递归调用 `dfs` 处理下一个物品。
>      - 不选择当前物品，并递归调用 `dfs` 继续处理当前物品（回溯）。

``` c
//子集树
int w[] = {0, 5, 2, 6, 4, 3}; // 物品重量 下标从1开始
int n = 5; // 物品数量
int c = 10; // 背包容量
int maxw = 0; // 最大重量
int x[6]; // 记录最优解

void dfs(int step, int cw, int rw, int op[]) {
    if (step > n) {//找到一个叶节点
        if (cw > maxw) {
            maxw=cw;
            for (int i = 1; i <= n; ++i)
                x[i] = op[i];//复制更优解
        }
    } else {//继续找
        if (cw + w[step] <= c) {
            op[step] = 1;//选取第i个
            dfs(step + 1, cw + w[step], rw - w[step], op);
        }
        if (cw + rw - w[step] > maxw) {//当前重量+剩余重量还有可能超过 最大值
            op[step] = 0;//不选回溯 -w[step]  否则剪枝
            dfs(step+1, cw, rw - w[step], op);
        }
    }
}
```

### 复杂装载

> 目标是将集装箱分配到两个轮船上，使得第一个轮船的总重量最大化，并且第二个轮船能够装下剩余的所有集装箱。你使用了深度优先搜索（DFS）来找到第一个轮船的最优解，并通过 `solve` 函数检查第二个轮船是否能够装下剩余的集装箱。
>
> 1. **初始化**：
>    - 定义集装箱的重量数组 `w`。
>    - 定义两艘船的最大载重量 `c1` 和 `c2`。
>    - 初始化全局变量 `maxw` 用于记录第一艘船的最大载重量。
>    - 初始化数组 `x` 用于记录第一艘船的最优解向量。
> 2. **深度优先搜索（DFS）**：
>    - 递归函数 `dfs` 尝试所有可能的集装箱组合。
>    - 如果当前步骤 `step` 超过集装箱数量 `n`，则到达叶节点，更新最大载重量 `maxw` 并记录当前解。
>    - 否则，继续处理当前集装箱：
>      - 如果当前重量加上当前集装箱的重量不超过 `c1`，则选择当前集装箱，并递归调用 `dfs` 处理下一个集装箱。
>      - 如果当前重量加上剩余重量减去当前集装箱的重量仍然有可能超过 `maxw`，则不选择当前集装箱，并递归调用 `dfs` 继续处理当前集装箱（回溯）。
> 3. **检查剩余集装箱**：
>    - 函数 `solve` 计算第一艘船装完后剩余的集装箱总重量 `sum`。
>    - 检查 `sum` 是否小于等于 `c2`，即第二艘船能否装下剩余的集装箱。
>
> 1. **第一艘船尽可能多装**：
>    - 使用深度优先搜索（DFS）来尝试所有可能的集装箱组合，找到一种使得第一艘船装载重量最大的方案。
>    - 在递归过程中，通过选择或不选择当前集装箱来生成所有可能的解，并使用剪枝技术来减少不必要的递归调用。
> 2. **检查剩余集装箱是否能被第二艘船装下**：
>    - 一旦找到了第一艘船的最大载重量方案，计算剩余未被选中的集装箱总重量。
>    - 检查这些剩余集装箱的总重量是否不超过第二艘船的最大载重量 `c2`。
>    - 如果第二艘船能够装下所有剩余的集装箱，则找到了一个可行的解决方案；否则，没有可行的解决方案。

``` c
//子集树
#define MAXN 20 // 最多集装箱个数
int w[] = {0, 10, 40, 40}; // 各集装箱重量, 不用下标 0 的元素
int n = 3; // 集装箱数量
int c1 = 50, c2 = 50; // 两艘轮船的最大载重量
int maxw = 0; // 存放第一艘轮船最优解的总重量
int x[MAXN]; // 存放第一艘轮船最优解向量

//将所有集装箱都装上船 由于集装箱必需整体装入 所以不能贪心
void dfs(int step, int cw, int rw, int op[]) //求第一艘轮船的最优解
{
    if (step > n) {
        if (cw > maxw) {
            for (int i = 1; i <= n; ++i) {
                x[i] = op[i];
                maxw = cw;
            }
        }
    } else {//继续找更小重量
        if (cw + w[step] <=c1) {//没超重
            op[step] = 1;
            dfs(step + 1, cw + w[step], rw - w[step], op);
        }
        if (cw + rw - w[step] > maxw) {//还有机会装更多 剪枝
            op[step] = 0;
            dfs(step + 1, cw, rw - w[step], op);
        }
    }
}

bool solve()//求解复杂装载问题
{   int sum = 0; //累计第一艘轮船装完后剩余的集装箱重量
    for (int j = 1; j <= n; j++)
        if (x[j] == 0)
            sum += w[j];
    if (sum <= c2)//第二艘轮船可以装完
        return true;
    else//第二艘轮船不能装完
        return false;
}
```

### 01背包(回溯)

> ### 算法思想
>
> 回溯的思想，尝试每一种可能的物品组合，然后根据约束条件（不超过背包容量）和目标（最大化价值）来筛选出最优解。
>
> 
>
> 1. **递归终止条件**：
>    - 当 `step > n` 时，表示所有物品都考虑过了。如果当前总价值 `cv` 大于 `maxv`，则更新 `maxv` 和最优解 `x`。
> 2. **递归过程**：
>    - 如果当前物品可以放入背包且不超重，则递归调用 `dfs`。
>    - 如果当前物品不放入背包，但还有机会获得更大的总价值，则继续递归调用 `dfs`。
>
> 
>
> - 如果可以放入当前物品（`cw + w[step] <= c`），则选择该物品并递归调用 `dfs` 来处理下一个物品。
> - 即使当前物品不被选中，如果后续物品的价值加上当前价值还有可能超过已知的最大价值（`cv + rv - v[step] > maxv`），那么也递归调用 `dfs` 来处理下一个物品而不选当前物品。
>
> - **优化剪枝**:
>   - 通过条件 `if (cv + rv - v[step] > maxv)` 来进行剪枝，避免不必要的递归调用。这个条件确保只有当后续有可能找到更好的解时才继续探索。

``` c
int n = 4;// 物品数量
int c = 10;// 背包最大容量
int w[] = {0, 2, 3, 4, 5};// 每个物品的重量
int v[] = {0, 3, 4, 5, 6};// 每个物品的价值
int maxv = 0;// 当前找到的最大价值
int x[21];// 保存最优解
//子集树只有选和不选 不用for
// 深度优先搜索函数
void dfs(int step, int cw, int cv, int rv, int op[]) {
    if (step > n) { // 所有物品都考虑过了
        if (cv > maxv) {
            maxv = cv;
            for (int i = 1; i <= n; ++i) 
                x[i] = op[i];
        }
    } else { // 继续找更大价值
        if (cw + w[step] <= c) { // 放得下
            op[step] = 1;
            dfs(step + 1, cw + w[step], cv + v[step], rv - v[step], op);
        }
        if (cv + rv - v[step] > maxv) { // 还有机会更大，剪枝
            op[step] = 0;
            dfs(step + 1, cw, cv, rv - v[step], op);
        }
    }
}
```





### N皇后

> #### 全局变量
>
> - `const int N = 8;`：定义了棋盘的大小，这里假设是8皇后问题。
> - `int q[N + 1];`：数组`q`用于存储每一行皇后的列位置。`q[i]`表示第`i`行的皇后位于第`q[i]`列。
>
> #### 函数 `place(int i, int j)`
>
> - **功能**：测试在位置 `(i, j)` 上是否可以放置皇后。
> - 参数：
>   - `i`：当前考虑的行号。
>   - `j`：当前考虑的列号。
> - 逻辑：
>   - 如果是第一行（`i == 1`），则总是可以放置皇后，因为此时没有其他皇后。
>   - 对于其他行，检查之前已经放置的所有皇后（从第1行到第i-1行）。
>     - 检查是否有任何已放置的皇后与当前位置 `(i, j)` 在同一列，即 `q[k] == j`。
>     - 检查是否有任何已放置的皇后与当前位置 `(i, j)` 在同一条对角线上，即 `abs(q[k] - j) == abs(i - k)`。
>   - 如果发现冲突，则返回 `false` 表示不能在此位置放置皇后。
>   - 如果没有发现冲突，循环结束后返回 `true` 表示可以在该位置放置皇后。
>
> #### 函数 `queen(int i, int n)`
>
> - **功能**：递归地尝试在第`i`行到第`n`行放置皇后。
> - 参数：
>   - `i`：当前考虑的行号。
>   - `n`：棋盘的大小（也是需要放置的皇后数量）。
> - 逻辑：
>   - 如果 `i > n`，说明已经成功放置了所有的皇后，调用 `dispasolution(n)` 来输出当前解决方案。
>   - 否则，对于第i行的每一个列j（从1到n），尝试放置皇后。
>     - 调用 `place(i, j)` 来检查是否可以在 `(i, j)` 位置放置皇后。
>     - 如果可以放置，则将 `q[i]` 设置为 `j`，表示在第`i`行的第`j`列放置皇后。
>     - 递归调用 `queen(i + 1, n)` 来尝试放置下一行的皇后。
>   - 如果在当前行的所有列都尝试过且无法放置皇后，则回溯到上一行重新选择。
>
> ### 算法思想
>
> 1. **递归与回溯**：
>    - 使用递归来尝试每一种可能的皇后放置方式。
>    - 当发现当前路径不可行时（即不能在某一行找到合适的位置放置皇后），通过回溯回到上一步，尝试另一种可能性。
> 2. **约束传播**：
>    - 在每次尝试放置皇后时，通过 `place` 函数检查当前放置是否会违反规则（同行、同列、对角线）。
>    - 只有当不违反规则时，才会继续递归下去。
> 3. **剪枝**：
>    - 通过提前检测冲突来减少不必要的递归调用。如果发现某个位置不能放置皇后，就不再继续尝试该位置。
> 4. **解决方案收集**：
>    - 当所有皇后都被成功放置后，调用 `dispasolution(n)` 来输出当前的解决方案。

``` c
const int N = 8; // 假设我们要解决的是8皇后问题
int q[N + 1]; // 用于存储每行皇后的列位置

// 测试(i, j)位置能否摆放皇后
bool place(int i, int j) {
    if (i == 1) return true; // 第一个皇后总是可以放置
    for (int k = 1; k < i; ++k) { // k=1～i-1 是已放置了皇后的行
        if ((q[k] == j) || (abs(q[k] - j) == abs(i - k))) {//qk=j列冲突
            return false;
        }
    }
    return true;
}
// 放置 1～i 的皇后
void queen(int i, int n) {
    if (i > n) {
        dispasolution(n); // 所有皇后放置结束
    } else {
        for (int j = 1; j <= n; ++j) { // 在第 i 行上试探每一个列 j
            if (place(i, j)) { // 在第 i 行上找到一个合适位置(i, j) 
                q[i] = j;
                queen(i + 1, n);
            }
        }
    }
}

```



### 流水作业调度(批处理)

><img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241016090249815-1729040571249-13.png" alt="image-20241016090249815" style="zoom:50%;" />

> 1. **初始化**：
>
>    - 初始化 `bestx` 和 `x` 数组，用于存储最优解和当前解的作业顺序。
>    - 初始化 `f1` 和 `f2` 数组，用于记录当前的完成时间和每个节点的完成时间。
>    - 初始化 `bestf` 为 `INT_MAX`，表示当前最优解的完成时间。
>
> 2. **深度优先搜索 (DFS) 函数 `dfs(int i)`**：
>
>    - **边界条件**：如果到达叶节点（即 `i > n`），则检查当前完成时间 `f2[n]` 是否优于最优解 `bestf`。如果是，则更新 `bestf` 并将当前解 `x` 复制到 `bestx` 中。
>
>    - **继续搜索**：对于当前层 `i`，尝试将 `i` 位置的作业与后续位置的作业交换，然后递归地进行下一层搜索。
>
>    - 更新完成时间
>
>      ：在每次交换后，更新f1 和f2
>
>      - `f1 += m1[x[i]]`：更新当前在第一台机器上的完成时间。
>      - `f2[i] = max(f1, f2[i - 1] + m2[x[i]])`：计算当前节点的完成时间。`f2[i]` 是 `f1` 和 `f2[i - 1] + m2[x[i]]` 中的较大值，确保了作业在第二台机器上的完成时间不会早于第一台机器。
>
>    - **剪枝**：如果当前节点的完成时间 `f2[i]` 已经大于或等于最优解的完成时间 `bestf`，则不需要继续搜索。
>
>    - 回溯：恢复原来的作业顺序和完成时间，以便尝试其他可能的作业顺序。
>
>      - `f1 -= m1[x[i]]`：回溯 `f1`。
>      - `swap(x[i], x[j])`：恢复原来的作业顺序。

``` c
int n = 4;
int m1[] = {0, 5, 12, 4, 8};  // 下标从1开始
int m2[] = {0, 6, 2, 14, 7};  // 下标从1开始
int bestx[11];  // 最优解组
int x[11];  // 临时解组
int f1 = 0;  // 当前在m1上的完成时间
int f2[11];  // 每个节点的完成时间
int bestf = INT_MAX;  // 最优解的完成时间

void dfs(int i) {
    if (i > n) {  // 到达叶节点
        if (f2[n] < bestf) {
            bestf = f2[n];
            for (int j = 1; j <= n; ++j) 
                bestx[j] = x[j];//x[1]=3 第一个任务是3
        }
    } else {  // 继续找
        for (int j = i; j <= n; ++j) {
            swap(x[i], x[j]);  // 交换作业顺序
            f1 += m1[x[i]];  // 更新当前在m1上的完成时间
            f2[i] = max(f1, f2[i - 1] + m2[x[i]]);  // 计算当前节点的完成时间
            // 限界函数：如果当前节点的完成时间已经大于或等于最优解，直接剪枝
            //f2[i] 表示前 i 个作业的总完成时间。我们可以在每次递归调用 dfs(i + 1) 之前，
            // 检查当前的 f2[i] 是否已经大于或等于已知的最优解 bestf。如果是，则不需要继续搜索这个分支。
            if (f2[i] < bestf) {  // 剪枝
                dfs(i + 1);
            }
            f1 -= m1[x[i]];  // 回溯
            swap(x[i], x[j]);  // 恢复原来的顺序
        }
    }
}
```

## 分支限界法



### 简单装载(分治限界 队列)



``` c
// 定义节点结构体
struct Node {
    int step; // 当前处理到第几个物品
    int cw; // 当前背包总重量
    int rw; // 剩余物品总重量
    vector<int> op; // 当前解
};

// 使用队列实现分支限界法
void branchAndBoundQueue() {
    queue<Node> q; // 创建一个队列来存储待处理的节点
    Node t = {0, 0, 0, vector<int>(n + 1, 0)}; // 初始化根节点
    // 初始化剩余物品总重量
    for (int i = 1; i <= n; ++i) 
        t.rw += w[i];
    q.push(t); // 将根节点加入队列

    while (!q.empty()) { // 当队列不为空时继续处理
        Node node = q.front(); // 取出队头节点
        q.pop();

        if (node.step > n) { // 如果当前节点是叶节点
            if (node.cw > maxw) { // 更新最大重量和最优解
                maxw = node.cw;
                for (int i = 1; i <= n; ++i) 
                    x[i] = node.op[i];
            }
        } else {
            // 生成左子节点（选取当前物品）
            if (node.cw + w[node.step + 1] <= c) { // 检查是否可以选取当前物品
                Node leftNode = node; // 复制当前节点
                leftNode.step++; // 移动到下一个物品
                leftNode.cw += w[leftNode.step]; // 更新背包总重量
                leftNode.rw -= w[leftNode.step]; // 更新剩余物品总重量
                leftNode.op[leftNode.step] = 1; // 标记选取当前物品
                q.push(leftNode); // 将左子节点加入队列
            }
            // 生成右子节点（不选取当前物品）
            if (node.cw + node.rw - w[node.step + 1] > maxw) { // 检查是否需要生成右子节点
                Node rightNode = node; // 复制当前节点
                rightNode.step++; // 移动到下一个物品
                rightNode.rw -= w[rightNode.step]; // 更新剩余物品总重量
                rightNode.op[rightNode.step] = 0; // 标记不选取当前物品
                q.push(rightNode); // 将右子节点加入队列
            }
        }
    }
}
```

### 简单装载(优先队列)

``` c
struct Node {
    int step; // 当前处理到第几个物品
    int cw; // 当前背包总重量
    int rw; // 剩余物品总重量
    vector<int> op; // 当前解
};

// 重载小于运算符，用于优先队列
bool operator<(const Node &a, const Node &b) {
    return a.cw + a.rw < b.cw + b.rw; // 上界越大，优先级越高
}
// 使用优先队列实现分支限界法
void branchAndBoundPriorityQueue() {
    priority_queue<Node> pq; // 创建一个优先队列来存储待处理的节点
    Node root = {0, 0, 0, vector<int>(n + 1, 0)}; // 初始化根节点
    // 初始化剩余物品总重量
    for (int i = 1; i <= n; ++i) 
        root.rw += w[i];
    pq.push(root); // 将根节点加入优先队列

    while (!pq.empty()) { // 当优先队列不为空时继续处理
        Node node = pq.top(); // 取出优先级最高的节点
        pq.pop();

        if (node.step > n) { // 如果当前节点是叶节点
            if (node.cw > maxw) { // 更新最大重量和最优解
                maxw = node.cw;
                for (int i = 1; i <= n; ++i)
                    x[i] = node.op[i];
            }
        } else {
            // 生成左子节点（选取当前物品）
            if (node.cw + w[node.step + 1] <= c) { // 检查是否可以选取当前物品
                Node leftNode = node; // 复制当前节点
                leftNode.step++; // 移动到下一个物品
                leftNode.cw += w[leftNode.step]; // 更新背包总重量
                leftNode.rw -= w[leftNode.step]; // 更新剩余物品总重量
                leftNode.op[leftNode.step] = 1; // 标记选取当前物品
                pq.push(leftNode); // 将左子节点加入优先队列
            }
            // 生成右子节点（不选取当前物品）
            if (node.cw + node.rw - w[node.step + 1] > maxw) { // 检查是否需要生成右子节点
                Node rightNode = node; // 复制当前节点
                rightNode.step++; // 移动到下一个物品
                rightNode.rw -= w[rightNode.step]; // 更新剩余物品总重量
                rightNode.op[rightNode.step] = 0; // 标记不选取当前物品
                pq.push(rightNode); // 将右子节点加入优先队列
            }
        }
    }
}
```



### 01背包(分支 队列)

``` c
int w[] = {0, 5, 2, 6, 4, 3}; // 物品重量 下标从1开始
int v[] = {0, 8, 3, 12, 7, 5}; // 物品价值 下标从1开始
int n = 5; // 物品数量
int c = 10; // 背包容量
int maxv = 0; // 最大价值
int x[6]; // 记录最优解

// 定义节点结构体
struct Node {
    int step; // 当前处理到第几个物品
    int cw; // 当前背包总重量
    int cv; // 当前背包总价值
    int rv; // 剩余物品总价值
    vector<int> op; // 当前解
};

// 使用队列实现分支限界法
void branchAndBoundQueue() {
    queue<Node> q;
    Node root = {0, 0, 0, 0, vector<int>(n + 1, 0)};

    // 初始化剩余物品总价值
    for (int i = 1; i <= n; ++i) 
        root.rv += v[i];

    q.push(root);
    while (!q.empty()) {
        Node node = q.front();
        q.pop();
        if (node.step > n) { // 叶节点
            if (node.cv > maxv) {
                maxv = node.cv;
                for (int i = 1; i <= n; ++i) {
                    x[i] = node.op[i];
                }
            }
        } else {
            // 生成左子节点（选取当前物品）
            if (node.cw + w[node.step + 1] <= c) {
                Node leftNode = node;
                leftNode.step++;
                leftNode.cw += w[leftNode.step];
                leftNode.cv += v[leftNode.step];
                leftNode.rv -= v[leftNode.step];
                leftNode.op[leftNode.step] = 1;
                q.push(leftNode);
            }
            // 生成右子节点（不选取当前物品）
            if (node.cv + node.rv - v[node.step + 1] > maxv) {
                Node rightNode = node;
                rightNode.step++;
                rightNode.rv -= v[rightNode.step];
                rightNode.op[rightNode.step] = 0;
                q.push(rightNode);
            }
        }
    }
}


```

### 01背包(优先队列)

``` c
int w[] = {0, 5, 2, 6, 4, 3}; // 物品重量 下标从1开始
int v[] = {0, 8, 3, 12, 7, 5}; // 物品价值 下标从1开始
int n = 5; // 物品数量
int c = 10; // 背包容量
int maxv = 0; // 最大价值
int x[6]; // 记录最优解

// 定义节点结构体
struct Node {
    int step; // 当前处理到第几个物品
    int cw; // 当前背包总重量
    int cv; // 当前背包总价值
    int rv; // 剩余物品总价值
    vector<int> op; // 当前解
};

// 重载小于运算符，用于优先队列
bool operator<(const Node &a, const Node &b) {
    return a.cv + a.rv < b.cv + b.rv; // 上界越大，优先级越高
}

// 使用优先队列实现分支限界法
void branchAndBoundPriorityQueue() {
    priority_queue<Node> pq;
    Node root = {0, 0, 0, 0, vector<int>(n + 1, 0)};

    // 初始化剩余物品总价值
    for (int i = 1; i <= n; ++i) {
        root.rv += v[i];
    }

    pq.push(root);

    while (!pq.empty()) {
        Node node = pq.top();
        pq.pop();

        if (node.step > n) { // 叶节点
            if (node.cv > maxv) {
                maxv = node.cv;
                for (int i = 1; i <= n; ++i) {
                    x[i] = node.op[i];
                }
            }
        } else {
            // 生成左子节点（选取当前物品）
            if (node.cw + w[node.step + 1] <= c) {
                Node leftNode = node;
                leftNode.step++;
                leftNode.cw += w[leftNode.step];
                leftNode.cv += v[leftNode.step];
                leftNode.rv -= v[leftNode.step];
                leftNode.op[leftNode.step] = 1;
                pq.push(leftNode);
            }

            // 生成右子节点（不选取当前物品）
            if (node.cv + node.rv - v[node.step + 1] > maxv) {
                Node rightNode = node;
                rightNode.step++;
                rightNode.rv -= v[rightNode.step];
                rightNode.op[rightNode.step] = 0;
                pq.push(rightNode);
            }
        }
    }
}

```



### 流水作业调度(队列)

``` c
int n = 4;
int m1[] = {0, 5, 12, 4, 8};  // 下标从1开始
int m2[] = {0, 6, 2, 14, 7};  // 下标从1开始
int bestx[11];  // 最优解组
int x[11];  // 临时解组
int f1 = 0;  // 当前在m1上的完成时间
int f2[11];  // 每个节点的完成时间
int bestf = INT_MAX;  // 最优解的完成时间
// 定义节点结构体
struct Node {
    int step; // 当前处理到第几个任务
    int f1; // 当前在m1上的完成时间
    vector<int> op; // 当前解
    int f2; // 当前节点的完成时间
};

// 使用队列实现分支限界法
void branchAndBoundQueue() {
    queue<Node> q;
    Node root = {1, 0, vector<int>(n + 1), 0};
    for (int i = 1; i <= n; ++i) {
        x[i] = i;
    }
    q.push(root);

    while (!q.empty()) {
        Node node = q.front();
        q.pop();
        if (node.step > n) { // 叶节点
            if (node.f2 < bestf) {
                bestf = node.f2;
                for (int i = 1; i <= n; ++i) {
                    bestx[i] = node.op[i];
                }
            }
        } else {
            for (int j = node.step; j <= n; ++j) {
                swap(x[node.step], x[j]);  // 交换作业顺序
                int new_f1 = node.f1 + m1[x[node.step]];  // 更新当前在m1上的完成时间
                int new_f2 = max(new_f1, node.f2 + m2[x[node.step]]);  // 计算当前节点的完成时间
                // 限界函数：如果当前节点的完成时间已经大于或等于最优解，直接剪枝
                if (new_f2 < bestf) {
                    Node newNode = {node.step + 1, new_f1, node.op, new_f2};
                    newNode.op = node.op;
                    newNode.op[node.step] = x[node.step];
                    q.push(newNode);
                }
                swap(x[node.step], x[j]);  // 恢复原来的顺序
            }
        }
    }
}
```



### 流水作业调度(优先队列)

``` c
int n = 4;
int m1[] = {0, 5, 12, 4, 8};  // 下标从1开始
int m2[] = {0, 6, 2, 14, 7};  // 下标从1开始
int bestx[11];  // 最优解组
int x[11];  // 临时解组
int f1 = 0;  // 当前在m1上的完成时间
int f2[11];  // 每个节点的完成时间
int bestf = INT_MAX;  // 最优解的完成时间

// 定义节点结构体
struct Node {
    int step; // 当前处理到第几个任务
    int f1; // 当前在m1上的完成时间
    vector<int> op; // 当前解
    int f2; // 当前节点的完成时间
};

// 重载小于运算符，用于优先队列
bool operator<(const Node &a, const Node &b) {
    return a.f2 > b.f2; // 优先级高的节点有较小的f2值
}

// 使用优先队列实现分支限界法
void branchAndBoundPriorityQueue() {
    priority_queue<Node> pq;
    Node root = {1, 0, vector<int>(n + 1), 0};
    for (int i = 1; i <= n; ++i) 
        x[i] = i;

    pq.push(root);
    while (!pq.empty()) {
        Node node = pq.top();
        pq.pop();

        if (node.step > n) { // 叶节点
            if (node.f2 < bestf) {
                bestf = node.f2;
                for (int i = 1; i <= n; ++i) 
                    bestx[i] = node.op[i];
            }
        } else {
            for (int j = node.step; j <= n; ++j) {
                swap(x[node.step], x[j]);  // 交换作业顺序
                int new_f1 = node.f1 + m1[x[node.step]];  // 更新当前在m1上的完成时间
                int new_f2 = max(new_f1, node.f2 + m2[x[node.step]]);  // 计算当前节点的完成时间
                // 限界函数：如果当前节点的完成时间已经大于或等于最优解，直接剪枝
                if (new_f2 < bestf) {
                    Node newNode = {node.step + 1, new_f1, node.op, new_f2};
                    newNode.op = node.op;
                    newNode.op[node.step] = x[node.step];
                    pq.push(newNode);
                }

                swap(x[node.step], x[j]);  // 恢复原来的顺序
            }
        }
    }
}

```



### Dijkstral(分支限界)

> 1. **初始化**：
>    - 创建一个优先队列 `pq` 来存储待处理的节点，按照权重从小到大排序。
>    - 初始化起点信息，并将其推入队列。
> 2. **主循环**：
>    - 从队列中取出当前权重最小的节点。
>    - 如果该节点已经被访问过，则跳过。
>    - 标记当前节点为已访问。
>    - 对于当前节点的邻居，如果通过当前节点到达邻居的路径更短，则更新邻居的距离，并将新的节点加入队列。
> 3. **剪枝**：
>    - 如果某个节点已经被访问过，说明已经有了更优的路径到达该节点，因此不再处理该节点。
> 4. **记录路径**：
>    - 通过记录前一个顶点的方式，可以追溯从起点到目标顶点的最短路径。

``` c
typedef struct {
    int edges[25][25]; // 图的邻接矩阵
    int vexNum;        // 顶点数量
    int arcNum;        // 边的数量
} MGraph;

int visited[25] = {0}; // 记录顶点是否已经被访问
int path[25];          // 记录从起点到各顶点的前一个顶点
int dist[25];          // 记录从起点到各顶点的距离

// 定义节点结构体
struct Node {
    int vertex; // 当前处理到哪个顶点
    int weight; // 当前路径的权重
    vector<int> path; // 当前路径
};

// 自定义比较运算符，用于优先队列中节点的比较
bool operator<(const Node &a, const Node &b) {
    return a.weight > b.weight; // 返回权重重的节点
}

// 使用分支限界法实现Dijkstra算法
void dijkstraBranchAndBound(MGraph *g, int v) {
    priority_queue<Node> pq; // 优先队列，按照权重从小到大排序

    // 初始化起点信息
    Node v = {v, 0, vector<int>({v})};
    pq.push(v);

    while (!pq.empty()) {
        Node currNode = pq.top(); // 获取当前权重最小的节点
        pq.pop();

        if (visited[currNode.vertex] == 1) continue; // 已经访问过，跳过
        visited[currNode.vertex] = 1; // 标记当前节点为已访问

        // 更新当前顶点到其他顶点的距离
        for (int i = 0; i < g->vexNum; ++i) {
            if (g->edges[currNode.vertex][i] != INT_MAX && visited[i] == 0) {
                int newWeight = currNode.weight + g->edges[currNode.vertex][i]; // 新的权重
                if (newWeight < dist[i] || dist[i] == INT_MAX) {
                    dist[i] = newWeight; // 更新距离
                    path[i] = currNode.vertex; // 记录前一个顶点
                    Node newNode = {i, newWeight, currNode.path}; // 创建新节点
                    newNode.path.push_back(i); // 添加当前顶点到路径
                    pq.push(newNode); // 将新节点加入队列
                }
            }
        }
    }
}

int main() {
    MGraph graph = { /* 初始化图的边和顶点数量 */ };
    int v = 0; // 假设起始顶点为0

    // 初始化距离数组为无穷大
    for (int i = 0; i < graph.vexNum; ++i) {
        dist[i] = INT_MAX;
    }

    // 起始顶点到自身的距离为0
    dist[v] = 0;

    dijkstraBranchAndBound(&graph, v); // 调用算法

    // 打印结果
    for (int i = 0; i < graph.vexNum; ++i) {
        std::cout << "Distance from " << v << " to " << i << " is " << dist[i] << std::endl;
    }

    return 0;
}
```



## 线性表

### 插入结点 将元素插入到表的第i个位置上

> 

``` c
int insertElem(LinkList &list, int i, int e) {//将元素e 插入到第i个位置上
    if (i < 1)
        return 0;
    int cnt = 0;
    LNode *p = list;
    while (p != NULL and cnt < i - 1) {
        p = p->next;
        cnt++;//找到相应位置插入
    }

    if (p == NULL) //循环结束 判断插入位置是否合法
        return 0;
    //成功找到 进行插入操作
    LNode *s = new LNode;
    s->data = e;
    s->next = p->next;
    p->next = s;
    return 1;
}
```

### 删除第一个值为key的元素

> 算法思想:1.若链表非空，遍历链表找寻结点
>
> ​        2.若找到结点不为空则进行删除，反之则退出

``` c
void deleteFirstByValue(LinkList &list, int x) {//将元素e 插入到第i个位置上
    if (list == NULL) {
        cout << "list is NULL" << endl;
        return;
    }
    LNode *p = list->next;
    LNode *pre = list;
    while (p != NULL and p->data != x) {//查找第一个值为x的结点
        pre = p;
        p = p->next;
    }
    if (p == NULL) {
        cout << "this is no element that you want to find" << endl;
        return;
    }
    //找到元素
    pre->next = p->next;
    free(p);//释放结点
}
```

### Frequent

> *设有头指针的双向链表，其每个结点中除有**pre(**前驱指针**)**、**data(**数据**)**和**next(**后继指针**)**域外，
> **还有一个访问频度域在链表被启用前，其值均初始化为零。
> **每当在链表中进行一次**Locate(L.x)**运算时，令元素值为**x**的结点中**frea**域的值增**1**，并**freg**。
> **使此链表中结点保持按访问频度非增**(**递减**)**的顺序排列，同时最近访问的结点排在频度相同的结点前面，
> **以便使频繁访问的结点总是靠近表头。
> **试编写符合上述要求的**Locate(L,x)**运算的算法，该运算为函数过程，返回找到结点的地址，类型为指*型



> 思想
>
> - **查找结点**：从头结点的下一个节点开始查找值为 `x` 的结点。
>
> - **更新访问频度**：如果找到该结点，将其访问频度加1。
>
> - **判断是否需要移动**：如果该结点已经是最高频度或其前驱节点的频度大于等于当前结点的频度，则不需要移动。
>
> - **从链表中移除结点**：将找到的结点从当前链表中移除。
>
> - 找到插入位置
>
>   ：遍历链表，找到合适的插入位置。新的插入位置应该满足以下条件：
>
>   - 新位置的频度大于当前结点的频度。
>   - 如果频度相同，新位置应该是第一个频度相同的结点之后的位置。
>
> - **插入结点**：将找到的结点插入到合适的位置。

``` c
typedef struct DNode {
    int data;
    struct DNode *pre, *next;
    int freq;
} DNode, *DLinkList;
DNode *Locate(DLinkList L, int x) {// Locate 函数：查找值为 x 的结点并更新访问频度
    DNode *p = L->next;
    DNode *pre = L;

    // 查找结点
    while (p != NULL && p->data != x)
        p = p->next;

    if (p == NULL)
        return NULL; // 没有找到值为 x 的结点

    // 更新访问频度
    p->freq++;
    // 如果 p 是头结点或者已经是最高频度，不需要移动
    if (p->pre == L || (p->freq <= p->pre->freq))
        return p;

    // 从当前链表中移除结点
    p->pre->next = p->next;
    if (p->next != NULL)
        p->next->pre = p->pre;

    // 找到插入位置
    pre = L;
    while (pre->next != NULL && (pre->next->freq >p->freq ))
        pre = pre->next;

    p->next = pre->next; // 插入结点
    p->pre = pre;
    if (pre->next != NULL)
        pre->next->pre = p;
    pre->next = p;
    return p;
}

```



## 单链表

### 建表(头插)

> - **创建头结点**：初始化一个头结点 `list`，并将 `next` 指针设置为 `NULL`。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的头部。
> - **更新指针**：确保新结点的 `next` 指针指向当前头结点的 `next`，然后更新头结点的 `next` 指针指向新结点。

``` c
// 使用头插法创建链表
void createByHead(LinkList &list, int arr[], int n) {
    list = new LNode; // 创建头结点
    list->next = NULL; // 头结点的 next 指向 NULL
    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        LNode *s = new LNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        s->next = list->next; // 新结点的 next 指向当前头结点的 next
        list->next = s; // 头结点的 next 指向新结点
    }
}
```

### 建表(尾插)

> - **创建头结点**：初始化一个头结点 `list`，并将 `next` 指针设置为 `NULL`。
>- **初始化尾指针**：初始时 `rear` 指向头结点。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的尾部。
> - **更新尾指针**：每次插入新结点后，更新 `rear` 指针，使其指向新结点。
> - **设置最后一个结点的 `next` 指针**：在循环结束后，确保最后一个结点的 `next` 指针指向 `NULL`。

``` c
void createByTail(LinkList &list, int arr[], int n) {
    list = new LNode; // 创建头结点
    list->next = NULL; // 头结点的 next 指向 NULL
    LNode *rear = list; // 初始时 rear 指向头结点

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        LNode *s = new LNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        rear->next = s; // 将新结点连接到当前尾结点的后面
        rear = s; // 更新尾结点为新结点
    }
    rear->next = NULL; // 最后一个结点的 next 指向 NULL
}
```

## 双链表

### 建表(头插)

> - **创建头结点**：初始化一个头结点 `head`，并将 `next` 和 `prior` 指针设置为 `NULL`。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的头部。
> - 更新指针：
>   - 新结点的 `next` 指针指向当前头结点的 `next`。
>   - 如果头结点的 `next` 不为空，则更新 `head->next` 的 `prior` 指针，使其指向新结点 `s`。
>   - 新结点的 `prior` 指针指向头结点 `head`。
>   - 更新头结点 `head` 的 `next` 指针，使其指向新结点 `s`。

``` c
// 使用头插法创建双向链表
void createDListByHead(DLinkList &head, int arr[], int n) {
    head = new DNode; // 创建头结点
    head->next = NULL; // 头结点的 next 指向 NULL
    head->prior = NULL; // 头结点的 prior 指向 NULL

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        DNode *s = new DNode;
        s->data = arr[i]; // 设置新结点的数据
        s->next = head->next; // 新结点的 next 指向当前头结点的 next
        if (head->next != NULL) { // 如果头结点后面有数据
            head->next->prior = s; // 修改后继结点的前驱指针
        }
        s->prior = head; // 新结点的前驱指针指向头结点
        head->next = s; // 头结点的 next 指向新结点
    }
}
```

### 建表(尾插)

> - **创建头结点**：初始化一个头结点 `head`，并将 `next` 和 `prior` 指针设置为 `NULL`。
> - **初始化尾指针**：初始时 `rear` 指向头结点。
> - **循环插入**：对于数组中的每个元素，创建一个新的结点，并将其插入到链表的尾部。
> - 更新指针：
>   - 新结点的 `next` 指针设置为 `NULL`（因为它是新的尾结点）。
>   - 新结点的 `prior` 指针指向当前尾结点 `rear`。
>   - 当前尾结点 `rear` 的 `next` 指针指向新结点 `s`。
>   - 更新 `rear` 指针，使其指向新结点 `s`。

``` c
// 使用尾插法创建双向链表
void createDListByTail(DLinkList &head, int arr[], int n) {
    head = new DNode; // 创建头结点
    head->next = NULL; // 头结点的 next 指向 NULL
    head->prior = NULL; // 头结点的 prior 指向 NULL
    DNode *rear = head; // 初始时 rear 指向头结点

    for (int i = 0; i < n; ++i) { // 循环 n 次，将数组每个元素插入链表
        DNode *s = new DNode; // 创建新结点
        s->data = arr[i]; // 设置新结点的数据
        s->next = NULL; // 新结点的 next 指向 NULL
        s->prior = rear; // 新结点的前驱指针指向当前尾结点
        rear->next = s; // 当前尾结点的 next 指向新结点
        rear = s; // 更新尾结点为新结点
    }
}
```



### 插入结点

> 按位置插入 ，
>
>  找寻对应插入位置 若结点为空或者下标越界则代表插入位置错误
>
> 否则进行插入操作 并修改相应指针

``` c
bool InsertByPos(DLinkList &head, int n, int e) {
    if (head == NULL)
        return false;
    DNode *p = head->next;
    int i = 0;
    while (p != NULL and i < n - 1) {
        p = p->next;
        i++;//找寻插入位置
    }
    if (p == NULL)
        return false;

    DNode *s = new DNode;//插入 新建j结点
    s->data = e;
    s->next = p->next;
    if (p->next != NULL)//存在后继结点 则修改前驱指针
        p->next->prior = s;
    s->next = p;
    p->next = s;
    return true;
}
```

### 删除

> - **初始化检查**：确保链表不为空且有实际数据结点。
> - **查找删除位置**：使用 `while` 循环遍历链表，直到找到第 `n` 个位置。
> - **处理边界情况**：如果下标越界，返回 `false`。
> - 删除结点：
>   - 更新 `p` 的前驱结点的 `next` 指针。
>   - 更新 `p` 的 `next` 的 `prior` 指针（如果 `p` 的 `next` 不为空）。
>   - 释放 `p` 结点的内存。

``` c
bool deleteByPos(DLinkList &head, int n) {
    if (head == NULL)
        return false;
    DNode *p = head->next;
    int i = 1;
    // 循环找寻删除结点，如果下标越界或结点为空 返回
    while (p != NULL && i < n) {
        p = p->next;
        i++;
    }
    if (p == NULL) {
        return false; // 下标越界
    }
    // 进行删除操作
    p->prior->next = p->next;
    if (p->next != NULL) {
        p->next->prior = p->prior;
    }
    // 释放结点
    free(p);

    return true;
}
```

#### 双链表排序

> ### 代码思想
>
> 1. **初始化**：
>    - 定义指针 `p`、`pre` 和 `q`，其中 `p` 用于遍历链表，`pre` 用于找到插入位置，`q` 用于保存下一个待处理的节点。
> 2. **断开链表**：
>    - 将头结点的 `next` 指针设置为 `NULL`，这样可以将原来的链表断开，方便逐个处理每个节点。
> 3. **遍历并重新插入节点**：
>    - 使用 `p` 遍历链表中的每个节点。
>    - 对于每个节点 `p`，使用 `pre` 从头结点开始比较，找到第一个大于或等于 `p->data` 的节点的位置。
>    - 将 `p` 插入到 `pre` 和 `pre->next` 之间。
>    - 更新 `p` 的前驱和后继指针。
>    - 继续处理下一个节点 `q`。

``` c
typedef struct DNode {
    int data;
    struct DNode *prior, *next;
} *DLinkList;

void DLinkListSort(DLinkList &head) {//单链表递增排序
    if (head == nullptr || head->next == nullptr)
        return;
    DNode *p, *pre, *q;
    p=head->next->next;
    head->next->next=NULL;//重新插入  断开链表，只保留头结点
    while (p != NULL) {
        q = p->next;
        pre = head;//从开头开始比较  
        while (pre->next != NULL and pre->next->data < p->data)//找寻插入位置 即p pre,  pre.next.data>=p, p插入到 pre的后面
            pre = pre->next;
         // 插入到找到的位置
        p->next = pre->next;
        if (pre->next != NULL)//不等于调整
            pre->next->prior = p;
        pre->next = p;
        p->prior = pre;//pre和p是包调整的
        p = q;//接着扫描
    }
}

```



## 循环单链表

### 统计值为x的个数

> ⑴判断是否是空链表：head->next==head ;
>
> （2）判断是否是表尾结点： p->next==head ;

``` c
//循环单链表 统计表内值为x的个数
int countByValue(LinkList head, int x) {
    while (head->next == head or head==NULL)
        return -1;
    LNode *p = head->next;
    int count = 0;
    while (p != head) {
        if (p->data == x)
            count++;
        p = p->next;
    }
    return count;
}
```

## 循环双链表

> 1.链表中没有空指针域 
>
> 2.p所指结点为尾结点的条件：p->next==L 
>
> 3.一步操作即L->prior可以找到尾结点

### 删除第一个值为x



``` c
//删除循环双链表中 第一个值为x的结点
bool deleted(DLinkList head, int x) {
    if (head == NULL || head->next == head) {
        return -1; // 链表为空或只有一个头结点
    }
    DLNode *p = head->next;
    while (p != NULL and p->next != head and p->data!=x)
        p = p->next;
    if (p->data == x)//找到
    {
        p->next->prior = p->prior;
        p->prior->next = p->next;
        free(p);
        return true;
    }
    return false;
}
```

### 是否对称

> 初始化检查链表不为空
>
> 使用while遍历从两边向中间进行比较，若遇见左右值不相等直接返回
>
> 分别处理长度为奇数和偶数的情况

``` c 

//判断循环双链表 内部元素值 是否对称
bool check(DLinkList head) {
    if (head == NULL or head->next == head)
        return false;
    DLNode *left = head, *right = head->prior;//left之前头节点 right指向 尾结点
    while (left != right and left->next != right) { // 循环条件：left 和 right 不相遇且 left 的下一个结点不是 right
        if (left->data != right->data) {
            return false; // 如果左右结点的数据不相等，则返回 false
        }
        left = left->next; // 移动 left 指针到下一个结点
        right = right->prior; // 移动 right 指针到前一个结点
    }

    if (left == right) // 如果链表长度为偶数，最后 left 和 right 会相邻
        return true; // 单个中间结点，直接返回 true
    else
        return left->data == right->data; // 检查相邻的两个结点是否相等

}
```



## 线性表





### 合并有序数组

> 两个指针分别从两个数组 表头开始遍历，
>
> 每次从两个数组中各取一个元素比较，将较小的元素放置排序数组中
>
> 当其中一个遍历完成后，将剩余的元素加入排序数

``` c
void merge(int nums1[], int nums2[], int n, int m) {
    int p1 = 0, p2 = 0;
    int temp[25];

    int cur=0;//临时赋值数组的指针
    while (p1 < n and p2 < m) {
        if (nums1[p1] < nums2[p2])
            temp[cur++] = nums1[p1++];
        else
            temp[cur++] = nums2[p2++];
    }
    while (p1 < n)
        temp[cur++] = nums1[p1++];
    while (p2 < m)
        temp[cur++] = nums2[p2++];
    for (int i = 0; i < n + m; ++i) {
        nums1[i] = temp[i];
    }
}
```





### 删除值为k的值(数组)

> 思想：
>
>  从头开始遍历，并进行比较
>
>  若当前元素值等于x，则进行删除并将剩余元素进行移动
>
>  以此类推直至遍历结束 (注意边界条件)

``` c
// 删除数组中的重复元素
void removeDuplicates(int arr[], int n, int x) {
    int count = 0; // 用于记录需要移除的元素数量

    for (int i = 0; i < n - count; ++i) {
        if (arr[i] == x) {
            // 将当前元素之后的所有元素向前移动一位
            for (int j = i; j < n - count - 1; ++j) {
                arr[j] = arr[j + 1];
            }
            count++; // 增加计数器
            i--; // 由于删除了一个元素，需要重新检查当前位置
        }
    }
}
```



### 数组轮转

> 思路:
>
>   1.首先若k>n则对k取余
>
>   2.对右边 k个元素 进行反转，即(n-k ,n-1)
>
>   3.对左边 剩余元素 进行翻转，即（0 ，n-k-1)
>
> 4. 最后对整个数组进行翻转，即得到题目所要求的翻转数组

``` c

```



### 删除链表重复元素

> 算法思想:
>
>  1.使用库文件自带set<> 集合来记录是个否遇到重复元素
>
>  2.若数组非空对其进行遍历，遇到结点值进行判断
>
> ​    若set中包含此元素，则进行删除操作
>
> ​    反之则将其加入set中
>
>  3.以此类推，直至循环结束

``` c
// 删除单链表中重复出现的结点
void deletedLinkNodeByRepeat(LinkList head) {
    if (head == NULL || head->next == NULL) 
        return; // 链表为空或只有一个结点

    set<int> s; // 使用集合来记录已经遇到过的值
    LNode *pre = head;
    LNode *p = head->next;

    while (p != NULL) {
        if (s.find(p->data) == s.end()) { // 首次出现，非重复
            s.insert(p->data); // 将当前结点的数据加入集合
            pre = p;
            p = p->next;
        } else { // 重复出现的元素，进行删除
            pre->next = p->next; // 更新前驱结点的 next 指针
            free(p); // 释放当前结点的内存
            p = pre->next; // 更新 p 指针
        }
    }
}
```

### 是否有环

> 1. **初始化**：
>    - 初始化两个指针 `slow` 和 `fast`，都指向链表的头节点。
>    - `slow` 指针每次移动一步，`fast` 指针每次移动两步。
> 2. **环检测**：
>    - 在链表上移动这两个指针。
>    - 如果链表中存在环，那么快指针最终会追上慢指针，即 `slow == fast`。
>    - 如果 `fast` 或 `fast->next` 变成 `NULL`，则说明链表没有环。
> 3. **找到环的入口**：
>    - 一旦发现环，将 `fast` 指针重新指向链表头部，而 `slow` 保持在相遇点。
>    - 然后同时移动 `slow` 和 `fast`，每次各移动一步。
>    - 当 `slow` 和 `fast` 再次相遇时，它们所在的节点就是环的入口。

``` c
x// 检测单链表是否存在环，并找到环入口
LNode *check(LinkList head) {
    if (head == NULL || head->next == NULL)
        return NULL; // 如果链表为空或只有一个节点，则不可能有环

    LNode *slow = head; // 慢指针
    LNode *fast = head; // 快指针

    // 使用快慢指针遍历链表
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;          // 慢指针每次走一步
        fast = fast->next->next;    // 快指针每次走两步
        if (slow == fast) {         // 如果相遇，则存在环
            cout << "There is a circle." << endl;
            break;
        }
    }

    if (fast == NULL || fast->next == NULL)   // 如果没有环
        return NULL;
    // 找到环的入口
    fast = head; // 将快指针移回到链表头
    while (slow != fast) { // 当两个指针相等时，即为环的入口
        slow = slow->next;
        fast = fast->next;
    }

    return slow; // 返回环的入口
}
```

#### 法二

> 思想:
>
>   1.在链表结构体中加入变量vis，判断是否该节点被访问
>
>   2.每次进行判当前结点vis是否为1，
>
> ​      Ⅰ.若不为1则代表未访问,将其置1
>
> ​      Ⅱ.若为1则代表有环 ，且该节点为环的入口

``` c 
//检测单链表是否存在环，若有并找到环入口
LNode *check(LinkList head) {
    if (head == NULL or head->next == NULL)
        return NULL;
    LNode *p = head->next;
    while (p != NULL) {
        if (p->vis == 1)//有环且找到 环的入口
            return p;
        else //无环 将其vis置1
            p->vis = 1;
        p = p->next;
    }
    return NULL;
}
```



## 栈(stack)

>栈
>
>- 只能再一丢按进行插入或者删除的，操作受限的线性表
>
>- 允许操作的一端称为栈顶，另一端称为栈底
>
>- 没有元素时即为空栈
>
>  特点：
>
>  先进后出

### 顺序栈

> 定义：利用一组地址连续的单元一次存放栈底到栈顶的元素

``` c
//顺序栈
#define  MAXSIZE 4
struct SeqStack {
    int data[MAXSIZE];
    int top;//栈顶指针 此处下标从-1开始
};

bool empty(SeqStack s) {
    return s.top == -1;
}

bool full(SeqStack s) {
    return s.top == MAXSIZE - 1;
}

bool push(SeqStack &s, int x) {
    if (full(s))//栈满
        return false;
    s.data[++s.top] = x;// 先增加栈顶指针，然后将值存入
    return true;
}

bool pop(SeqStack &s, int &x) {//通过形参返回
    if (empty(s))
        return false;
    x = s.data[s.top--];//先取栈顶元素，然后减少栈顶指针
    return true;
}

void initStack(SeqStack &s) {
    s.top = -1; // 初始时栈顶指针为 -1，表示栈为空
}


```

### 链栈

``` c
//链栈
#define  MAXSIZE 4
typedef struct LNode {
    int data;
    struct LNode *next;
} *LinkStack;

bool empty(LinkStack &s) {
    return s->next == NULL;
}

// 入栈操作
bool push(LinkStack &s, int x) {
    LNode *p = new LNode;
    p->data = x;
    p->next = s->next; // 新节点的 next 指向原来的头结点的 next
    s->next = p; // 更新头结点的 next 为新节点
    return true;
}

// 出栈操作
bool pop(LinkStack &s, int &x) {
    if (empty(s))
        return false;
    LNode *p = s->next; // 临时指针指向要删除的节点
    x = p->data; // 保存要删除节点的数据
    s->next = p->next; // 更新头结点的 next 指针
    free(p); // 释放删除的节点
    return true;
}

```

### 共享栈

``` c
//共享栈
#define  MAXSIZE 4
struct SeqStack {
    int data[MAXSIZE];
    int top1, top2;//栈顶指针 此处下标从-1开始 top2从maxsize开始往前
};
// 检查栈1是否为空
bool empty1(SeqStack s) {
    return s.top1 == -1;
//    return s.top2 == MAXSIZE;
    
}

// 检查共享栈是否为空
bool empty(SeqStack s) {
    return empty1(s) && empty2(s);
}

// 检查共享栈是否已满
bool full(SeqStack s) {
    return s.top1 + 1 == s.top2;
}

// 栈1入栈操作
bool push1(SeqStack *s, int x) {
    if (full(*s)) {// 栈满
        return false;
        s->data[++s->top1] = x; // 先增加栈顶指针，然后将值存入
        return true;
    }

// 栈2入栈操作
    bool push2(SeqStack *s, int x) {
        if (full(*s))  // 栈满
            return false;
        s->data[--s->top2] = x; // 先减少栈顶指针，然后将值存入
        return true;
    }

// 栈1出栈操作
    bool pop1(SeqStack *s, int *x) { // 通过形参返回
        if (empty1(*s))
            return false;
        *x = s->data[s->top1--]; // 先取栈顶元素，然后减少栈顶指针
        return true;
    }

```

### 括号匹配(链栈)

>思想:
>
>- 对待匹配数组进行遍历，依次取出元素判断
>- 若c=='(' 则进行入栈
>- 若c==')' 则进行判断
>  - 如果栈顶元素不等于'(' 则返回false 结束循环
>  - 反之 则继续判断直至循环结束
>- 循环结束判断，栈是否为空，若包含元素则匹配失败
>
>  

``` c
//括号匹配
bool match(char arr[], int n) {
    char c;
    LinkStack st;
    initStack(st);
    for (int i = 0; i < n; ++i) {
        if (arr[i] == '(') {
            push(st, '(');
        } else if (arr[i] == ')') {
            if (pop(st, c) == '(') {
                continue;
            } else {
                clearStack(st);
                return false; // 括号不匹配
            }
        }
    }
    bool result = empty(st);
    clearStack(st);
    return result;
}
```

### 中缀转后缀

> ### 基本思想
>
> 1. **扫描中缀表达式**：从左到右依次扫描每个字符。
> 2. **数字直接输出**：如果遇到操作数（数字），直接将其输出到后缀表达式中。
> 3. **操作符入栈**：如果遇到操作符（如 `+`, `-`, `*`, `/`），根据其优先级和栈顶元素的优先级决定是否将栈顶的操作符出栈并输出，然后再将当前操作符入栈。
> 4. **左括号入栈**：如果遇到左括号 `(`，直接将其入栈。
> 5. **右括号处理**：如果遇到右括号 `)`，则将栈中的操作符依次出栈并输出，直到遇到左括号 `(` 为止。左括号 `(` 不输出。
> 6. **清空栈**：当整个中缀表达式扫描完毕后，将栈中剩余的操作符依次出栈并输出。
>
> ### 详细步骤
>
> 1. **初始化一个空栈**，用于存储操作符。
>
> 2. **初始化一个空字符串**，用于存储后缀表达式。
>
> 3. 从左到右扫描中缀表达式
>
>    ：
>
>    - **如果是操作数**（数字或变量），直接将其添加到后缀表达式中。
>    - **如果是左括号 `(`**，将其压入栈中。
>    - **如果是右括号 `)`**，将栈中的操作符依次弹出并添加到后缀表达式中，直到遇到左括号 `(` 为止。左括号 `(` 弹出但不添加到后缀表达式中。
>    - 如果是运算符
>      - 如果栈为空，或者栈顶是左括号 `(`，或者当前运算符的优先级大于栈顶运算符的优先级，则将当前运算符压入栈中。
>      - 否则，将栈顶运算符弹出并添加到后缀表达式中，然后再次比较当前运算符与新的栈顶运算符的优先级，重复上述过程，直到满足条件再将当前运算符压入栈中。
>
> 4. **当扫描完中缀表达式后**，将栈中剩余的所有运算符依次弹出并添加到后缀表达式中。

``` c 
int getPriority(char ch) {
    if (ch == '+' || ch == '-') {
        return 1;
    } else if (ch == '*' || ch == '/') {
        return 2;
    }
}

void InfixToSuffix(string infix, stack<char> &s2) {
    stack<char> s1;
    int i = 0;
    while (i < infix.length()) {
        if (isdigit(infix[i])) {
            s2.push(infix[i++]);  // 将数字压入栈
        } else if (infix[i] == '(') {  // 左括号
            s1.push(infix[i++]);
        } else if (infix[i] == '+' || infix[i] == '-' || infix[i] == '*' || infix[i] == '/') {  // 运算符
            while (!s1.empty() && s1.top() != '(' and getPriority(infix[i]) <= getPriority(s1.top())) {
                s2.push(s1.top());
                s1.pop();
            }
            s1.push(infix[i++]);
        } else if (infix[i] == ')') {  // 右括号
            while (s1.top() != '(') {
                s2.push(s1.top());
                s1.pop();
            }
            s1.pop();  // 弹出左括号
            i++;
        } else {
            i++;  // 忽略其他字符（如空格）
        }
    }

    while (!s1.empty()) {
        s2.push(s1.top());
        s1.pop();
    }
}

int main() {
    string str = "8+(3-1)*5*3";
    stack<char> s2;
    InfixToSuffix(str, s2);

    // 输出后缀表达式
    stack<char> tempStack;
    while (!s2.empty()) {
        tempStack.push(s2.top());
        s2.pop();
    }

    while (!tempStack.empty()) {
        cout << tempStack.top() << " ";
        tempStack.pop();
    }

    return 0;
}
```



## 队列(Queue)

>定义 ： 
>
>• 是一种操作受限的线性表。 
>
>• 只允许在表的一端进行插入，称为队尾。 
>
>• 在变的另一端进行删除，称为队头。 
>
>特点： 先进先出

### 顺序栈

>顺序队列(sequential queue) ： 
>
>• 采用顺序存储结构的队列称为顺序队列。 
>
>• 指的是用一组地址连续的存储单元依次存储自队尾至队头的数据元素

``` c
typedef struct QNode {
    int data[MAXSIZE];//下标-1开始
    int front, rear;
} *SeqQueue;

bool push(SeqQueue &q, int x) {
    if (q->rear == MAXSIZE - 1)
        return false;
    q->data[++q->rear] = x;
    return true;
}

bool pop(SeqQueue &q, int &x) {
    if (q->front == q->rear)
        return false;
    x = q->data[++q->front];
    return true;
}
// 检查队列是否为空
bool isEmpty(SeqQueue q) {
    return q->front == q->rear;
}

// 检查队列是否已满
bool isFull(SeqQueue q) {
    return (q->rear + 1) % MAXSIZE == q->front;
}

```

### 循环队列

>判断队满 队空
>
>- 增加length表示元素个数
>- 两给一个空间 队空: front==rear,队满: (rear+1)%MAXSIZE == front
>- 增设flag，flag=1,front==rear 表示满，flag=0 表示空

``` c


typedef struct QNode {
    int data[MAXSIZE];//下标-1开始
    int front, rear;
} *cirQueue; //循环队列


bool push(cirQueue &q, int &x) {
    if (q->front == (q->rear + 1) % MAXSIZE)
        return false;

    // 尾指针先自增，然后在新的位置插入数据
    q->rear = (q->rear + 1) % MAXSIZE;
    q->data[q->rear] = x;
    return true;
}

bool pop(cirQueue &q, int &x) {
    if (q->front == q->rear)
        return false;
    // 如果队列变空，重置 front 和 rear
    if (q->front == (q->rear + 1) % MAXSIZE) {
        q->front = -1;
        q->rear = -1;
    }
    return true;
}
```

### 链队

``` c
struct QNode {
    int data;
    struct QNode *next;
};
typedef struct {
    QNode *front, *rear;
} *LinkQueue;


bool push(LinkQueue &q, int x) {
    QNode *s = new QNode;
    s->data = x;
    s->next = NULL;
    if (q->rear == NULL)
        q->front = q->rear = s;
    else
        q->rear->next = s;
    return true;
}

bool pop(LinkQueue &q, int &x) {
    if (q->front == q->rear)
        return false;
    x = q->front->next->data;
    q->front = q->front->next;
    return true;

}
```

### 循环报数

``` c

int arr[] = {1, 2, 3, 4, 5, 6, 7, 8};
int n = 8;

void fun() {
    queue<int> q1, q2;
    for (int i = 0; i < n; ++i)
        q1.push(arr[i]);
    while (!q1.empty() or !q2.empty()) {
        bool flag = false;// false =1 ,true=2
        while (!q1.empty()) {
            if (flag == false)
                cout << q1.front() << " ";
            else
                q2.push(q1.front());
            q1.pop();
            flag = !flag;
        }
        flag = false;
        while (!q2.empty()) {
            if (flag == false)
                cout << q2.front() << " ";
            else
                q1.push(q2.front());
            q2.pop();
            flag = !flag;
        }
    }
}
```

### 循环单链表删除最小值

>设有一个带头结点的循环单链表，其节点值均为正整数，设计一个算法，反复找出单链表中节点值最小的结点并输出，然后将 该结点从中删除，直到单链表空为止，再删除表头结点

``` c

void LoopListDeleteMinimum(LinkList &head) {
    if (head == nullptr || head->next == head)
        return;  // 如果链表为空或只有一个节点，直接返回
    //不断删除最小结点
    while (head->next != head) {
        LNode *minp = head->next;
        LNode *minpre = head;
        LNode *pre = head;
        LNode *p = head->next->next;
        while (p != head) {//循环一遍找最小值
            if (p->data < minp->data) {
                minpre = pre;
                minp = p;
            }
            pre = p;
            p = p->next;
        }
        minpre->next = minp->next;
        free(minp);
    }
    free(head);

}
```



## 栈

>a

``` c

```

## 栈

>a

## 10-9

### 二叉树定义 求sum

> 写出二叉树的定义
>
> 答: 二叉树是一种特殊的树，每个结点至多有2个孩子结点，
>
>    除根结点外每个结点都有一个唯一的父节点。
>
>    孩子有左右之分，不可颠倒。
>
>    子节点也具有相同特性。

>   递归的基本思想
>
> - 是从根节点开始，逐步向下遍历每个节点，并检查是否存在一条路径满足条件。
>
> - 每次递归调用时，我们将当前节点的值从 `sum` 中减去，并将剩余的 `sum` 传递给子节点。
> - 如果到达叶子节点且剩余的 `sum` 正好为 0，则说明找到了一条满足条件的路径返回`true`。
> - 如果在某个节点处，剩余的 `sum` 不为 0 且该节点没有子节点，则返回 `false`。
> - 
> - - **递归调用**：对于非叶子节点，递归地检查左子树和右子树。每次递归调用时，将 `sum` 减去当前节点的值，并将剩余的 `sum` 传递给子节点。
>   - **合并结果**：如果左子树或右子树中存在一条路径满足条件，则返回 `true`；否则返回 `false`。
>
> 



``` c
// 判断是否存在从根节点到叶子节点的路径，使得路径上的节点值之和等于 sum
bool hasPathSum(BiTree T, int sum) {
    // 如果当前节点为空，返回 false
    if (T == NULL)
        return false;
    // 如果当前节点是叶子节点，检查其值是否等于剩余的 sum
    if (T->left == NULL and T->right == NULL) {
        return T->data == sum;
    }
    // 递归检查左子树和右子树
    return hasPathSum(T->left,  sum - T->data) or hasPathSum(T->right,  sum - T->data);
}

```





 ### kruskal

> ### Kruskal算法思想
>
> Kruskal算法是一种贪心算法，其基本思想是：
>
> 1. **初始化**：
>    - 将所有边按权重从小到大排序。
>    - 初始化一个并查集（Union-Find），每个顶点自成一个集合。
> 2. **选择边**：
>    - 从权重最小的边开始，依次检查每条边。
>    - 如果这条边连接的两个顶点不在同一个集合中，则将这条边加入最小生成树，并将这两个顶点所在的集合合并。
>    - 如果这条边连接的两个顶点已经在同一个集合中，则跳过这条边。
> 3. **终止条件**：
>    - 当选中的边数等于顶点数减一时，最小生成树构建完成。

``` c

// 定义边的结构体
typedef struct Edge {
    int vex1, vex2; // 边所依附的两个顶点
    int weight;     // 权值
} Edge;

// 定义图的结构体
typedef struct {
    int vexNum;     // 顶点数
    int EdgeNum;    // 边数
    Edge edges[MAX_SIZE]; // 边表
} MGraph;

// 比较函数，用于 qsort 排序
bool cmp(const Edge &a, const Edge &b) {
    return a.weight < b.weight;
}

// 初始化并查集
void Initial(int roots[], int n) {
    for (int i = 0; i < n; ++i) {
        roots[i] = i; // 默认自己是自己的父节点
    }
}

// 查找父节点，即根节点
int getRoot(int roots[], int x) {
    while (roots[x] != x) {
        x = roots[x];
    }
    return x;
}

// 检查两个顶点是否属于同一个集合
bool isSameRoot(int roots[], int x1, int x2) {
    return getRoot(roots, x1) == getRoot(roots, x2);
}

// 合并两个集合
void merge(int roots[], int x1, int x2) {
    int s1 = getRoot(roots, x1);
    int s2 = getRoot(roots, x2);
    if (s1 != s2) {
        roots[s1] = s2;
    }
}

// Kruskal 算法
int Kruskal(MGraph *g) {
    int sum = 0; // 初始化总权重
    int edgeNum = g->EdgeNum;
    int vexNum = g->vexNum;
    int count = 0;
    int roots[g->vexNum]; // 并查集
    Initial(roots, vexNum); // 初始化并查集

    // 对边进行排序
    sort(g->edges, g->edges + edgeNum, cmp);

    for (int i = 0; i < edgeNum; ++i) {
        if (!isSameRoot(roots, g->edges[i].vex1, g->edges[i].vex2)) {
            // 如果两个顶点不在同一个集合中
            sum += g->edges[i].weight;
            printf("Edge %d-%d with weight %d is included in MST\n", g->edges[i].vex1, g->edges[i].vex2, g->edges[i].weight);
            merge(roots, g->edges[i].vex1, g->edges[i].vex2);
            count++; // 生成树的边数+1
            if (count == vexNum - 1) {
                // 达到生成树完成构造
                break;
            }
        }
    }

    if (count == vexNum - 1) {
        printf("Total weight of the Minimum Spanning Tree: %d\n", sum);
        return sum;
    } else {
        printf("The graph is not connected, cannot form a Minimum Spanning Tree.\n");
        return -1; // 图不连通
    }
}
```





### 插入排序(数组)

> 插入排序（Insertion Sort）是一种简单直观的排序算法，其基本思想是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上通常使用原地排序（即只需要用到O(1)的额外空间），因此空间复杂度较低。
>
> ### 算法思想
>
> 1. **初始状态**：假设第一个元素已经是有序的。
> 2. **遍历数组**：从第二个元素开始，依次将每个元素插入到前面已经排好序的部分中。
> 3. 插入过程
>    - 取出当前元素，与前面已经排好序的元素进行比较。
>    - 如果当前元素小于前一个元素，则将前一个元素向后移动一位。
>    - 重复上述步骤，直到找到当前元素应该插入的位置。
>    - 将当前元素插入到正确的位置。

``` c
void insertSort(int arr[], int n) {
    for (int i = 1; i < n; ++i) {
        if (arr[i] < arr[i - 1]) {//如果小于前一个元素，才向前找插入位置
            int temp = arr[i];
            int j;
            for (j = i - 1; j >= 0 and arr[j] > temp; j--) //检查前面所有元素
                arr[j + 1] = arr[j];//比temp大的后移
            arr[j + 1] = temp;
        }
    }
}
```

### 插排(单链表)

> 单链表插入排序（Insertion Sort for Singly Linked List）的基本思想与数组的插入排序类似，都是通过逐步构建有序序列，将每个新节点插入到已排序部分的正确位置。下面是单链表插入排序的详细算法思想：
>
> ### 算法思想
>
> 1. **初始状态**：
>
>    - 假设第一个节点已经是有序的。从第二个节点开始，依次将每个节点插入到前面已经排好序的部分中。
>
> 2. **遍历待排序节点**：
>
>    - 从第二个节点开始，遍历整个链表。每次取出一个待排序节点，称为 `current` 节点。
>
> 3. **找到插入位置**：
>
>    - 从头结点开始遍历已排序部分，找到 `current` 节点应该插入的位置。
>    - 插入位置是已排序部分中最后一个数据小于 `current` 节点数据的位置。
>
> 4. **插入节点**：
>
>    - 将 `current` 节点插入到找到的插入位置之后。更新指针
>
> 5. **继续处理下一个待排序节点**：
>
>    

``` c
void InsertSort(LinkList head) {
    if (!head || !head->next) return; // 如果链表为空或只有一个节点，直接返回

    LNode *p = head->next;
    p->next = NULL; // 初始有序链表只有第一个节点
    LNode *q = head->next->next; // 当前待排序节点
    head->next = NULL; // 断开已排序部分和待排序部分
    while (q) {
        LNode *nextNode = q->next; // 暂存下一个待排序节点
        LNode *insertPos = head; // 从头开始遍历有序链表，找到插入位置

        // 找到合适的插入位置
        while (insertPos->next && insertPos->next->data < q->data) {
            insertPos = insertPos->next;//往后找
        }
        // 插入节点
        q->next = insertPos->next;
        insertPos->next = q;

        q = nextNode; // 移动到下一个待排序节点
    }
}
```

### 二叉树是否对称

>算法思想：
>
>**定义镜像对称**：
>
>- 两棵树互为镜像对称，当且仅当：
>  - 它们的根节点具有相同的值。
>  - 一棵树的左子树与另一棵树的右子树镜像对称。
>  - 一棵树的右子树与另一棵树的左子树镜像对称。
>
>- **递归检查**：
>  - 使用递归函数 `check` 来比较两棵树是否镜像对称。
>  - 递归的基本情况是处理空节点的情况。
>  - 递归地检查每个节点的左右子树是否镜像对称 

``` c
bool check(BiNode *l, BiNode *r) {
    if (l == NULL and r == NULL) // 两个节点都为空，对称
        return true;
    if (l == NULL or r == NULL) // 一个节点为空，另一个不为空，不对称
        return false;
    return l->data == r->data and check(l->left, r->right) and check(l->right, r->left);
}
```



### 荷兰国旗(数组)

> 1.用0～i表示0元素区间。 
>
> 2.k～n-1表示2元素区间。 
>
> 3.中间部分为1元素区间。 
>
> 4.用j从头开始扫描顺序表L中部的所有元素。 
>
> - （1）j指向元素1：说明它属于中部，保持不动，j++。 
> - （2）j指向元素0：说明它属于前部，i增1（扩大0元素区间），将i、j位置的元素交换，j++。 
> - （3）j指向元素2：说明它属于后部，k减1（扩大2元素区间），将j、k位置的元素交换，此时j位置的元素可能还要交换到前部，所以j不前进

``` c
//荷兰国旗问题
void move() {
    L.length = n;
    int i = -1, j = 0, k = L.length;// i -k 前=0  中=1 在它们之间  k+1 n 后=2
    while (j < k) {//中和右的边界
        if (L.data[j] == 0) {
            i++;//交换00
            swap(L.data[i], L.data[j]);
            j++;
        } else if (L.data[j] == 2) {
            k--;
            swap(L.data[k], L.data[j]);
        } else {//
            j++;
        }
    }
}

```





### 荷兰国旗(链表)

> ### 算法思想
>
> 1. **初始化指针**：
>    - `l1` 和 `r1` 分别指向 1 的头结点和尾结点。
>    - `l2` 和 `r2` 分别指向 2 的头结点和尾结点。
>    - `r` 指向当前已处理部分的尾结点（即 0 部分的尾结点）。
>    - `p` 用于遍历整个链表。
> 2. **遍历链表**：
>    - 使用 `p` 遍历链表，直到 `p` 为空。
>    - 根据 p的数据值进行不同的处理：
>      - 如果 `p->data == 0`，将 `p` 插入到 `r` 之后，并更新 `r`。
>      - 如果 `p->data == 1`，将 `p` 插入到 1 部分的尾部，并更新 `r1`。
>      - 如果 `p->data == 2`，将 `p` 插入到 2 部分的尾部，并更新 `r2`。
> 3. **连接各部分**：
>    - 将 0 部分的尾结点 `r` 连接到 1 部分的头结点 `l1`。
>    - 将 1 部分的尾结点 `r1` 连接到 2 部分的头结点 `l2`。
>    - 最后将 2 部分的尾结点 `r2` 的 `next` 设置为 `NULL`。

``` c
//荷兰国旗问题
void move(LinkList &head) {
    LNode *l1 = NULL, *r1 = NULL; // 1 的头结点和尾结点
    LNode *l2 = NULL, *r2 = NULL; // 2 的头结点和尾结点
    LNode *r = head; // 当前已处理部分的尾结点
    LNode *p = head->next; // 用于遍历链表
    while (p != NULL) {
        if (p->data == 0) {
            r->next = p;
            r = p;
        } else if (p->data == 1) {
            if (l1 == NULL) {
                l1 = p;
                r1 = p;
            }
        } else {//==2
            if (l2 == NULL) {
                l2 = p;
                r2 = p;
            } else {
                r2->next = p;
                r2 = p;
            }
        }
        p = p->next;
    }
    r->next = r1->next = r2->next = NULL;
    r->next = l1;
    r1->next = l2;
}
```





> ### 算法思想
>
> 1. **初始化指针**：
>
>    - `pa` 指向 `ha` 的第一个节点。
>    - `pb` 指向 `hb` 的第一个节点。
>    - `pc` 指向 `hc` 的头结点（假设 `hc` 已经初始化为一个空链表）。
>
> 2. **遍历两个链表**：
>
>    - 使用 `while` 循环同时遍历 `ha` 和 `hb`，直到其中一个链表遍历结束。
>    - 在每一步中，比较 `pa` 和 `pb` 所指向节点的数据值。
>
> 3. **处理不同情况**：
>
>    - 如果 `pa->data < pb->data`，则移动 `pa` 到下一个节点。
>
>    - 如果 `pa->data > pb->data`，则移动 `pb` 到下一个节点。
>
>    - 如果pa->data == pb->data
>
>      ，则找到了一个公共元素：
>
>      - 创建一个新的节点 `s`，其数据值为 `pa->data`。
>      - 将 `s` 插入到 `hc` 的尾部。
>      - 移动 `pa` 和 `pb` 到各自的下一个节点。
>
> 4. **结束条件**：
>
>    - 当 `pa` 或 `pb` 为空时，循环结束，所有公共元素已经找到并插入到 `hc` 中。



### 查找公共元素

> ### 算法思想 二路归并与尾插法
>
> 1. **初始化指针**：
>
>    - `pa` 指向 `ha` 的第一个节点。
>    - `pb` 指向 `hb` 的第一个节点。
>    - `pc` 指向 `hc` 的头结点（假设 `hc` 已经初始化为一个空链表）。
>
> 2. **遍历两个链表**：
>
>    - 使用 `while` 循环同时遍历 `ha` 和 `hb`，直到其中一个链表遍历结束。
>    - 在每一步中，比较 `pa` 和 `pb` 所指向节点的数据值。
>
> 3. **处理不同情况**：
>
>    - 如果 `pa->data < pb->data`，则移动 `pa` 到下一个节点。
>
>    - 如果 `pa->data > pb->data`，则移动 `pb` 到下一个节点。
>
>    - 如果pa->data == pb->data
>
>      ，则找到了一个公共元素：创建结点插入并修改相应指针
>
> 4. **结束条件**：
>
>    - 当 `pa` 或 `pb` 为空时，循环结束，所有公共元素已经找到并插入到 `hc` 中。

``` c
void findCommonElements(LinkList ha, LinkList hb, LinkList &hc) {
    LNode *pa = ha->next;
    LNode *pb = hb->next;
    hc->next = NULL; // 确保 hc 是空链表
    LNode *pc = hc; // pc 指向 hc 的当前尾结点

    while (pa != NULL && pb != NULL) {// 遍历两个链表
        if (pa->data < pb->data) 
            pa = pa->next;
         else if (pa->data > pb->data) 
            pb = pb->next;
         else { // 找到公共元素
            LNode *s = new LNode; // 创建新节点
            s->data = pa->data;
            pc->next = s; // 将新节点插入到 hc 的尾部
            pc = s; // 更新 pc
            pa = pa->next; // 移动 pa
            pb = pb->next; // 移动 pb
        }
    }
    // 确保 hc 的尾结点指向 NULL
    pc->next = NULL;
}

```

### 迷宫问题(DFS)

>- 初始结点标记为已访问，判断结点若到达终点则结束循环，
>- 否则继续递归搜索四个可能的方向。并且确保新坐标在迷宫范围内。且不是障碍物。
>- **回溯**：如果当前路径无法到达终点，撤销访问标记，尝试其他路径
>- 直至走到终点

``` c
void dfs(int maze[10][10], int x, int y, int n) {
    if (x == n - 1 and y == n - 1) {//右下角为出口
        show();
        return;
    }
    for (int i = 0; i < 4; ++i) {
        int x2 = x + dir[0][i];
        int y2 = y + dir[1][i];
        if (x2 >= 0 and x2 < n and y2 >= 0 and y2 < n) {//没越界继续找
            maze[i][j]=2;//代表访问
            dfs(maze, x2, y2, n);
        }
    }
}
```



### 迷宫问题(BFS)

>1. **初始化**：
>   - 创建一个队列，并将起点加入队列。
>   - 标记起点为已访问。
>2. **循环处理**：
>   - 当队列不为空时，从队列中取出一个节点。
>   - 检查该节点是否是终点，如果是，则找到了一条路径。
>   - 如果不是终点，则对该节点的四个相邻节点进行处理：
>     - 计算相邻节点的位置。
>     - 检查相邻节点是否在迷宫范围内且未被访问过。
>     - 将符合条件的相邻节点加入队列，并标记为已访问。
>3. **结束条件**：
>   - 如果队列为空且没有找到终点，则说明没有路径。
>   - 如果找到终点，打印路径结束程序。

``` c
void bfs(int maze[10][10], int n) {
    queue<Node*> q;  // 使用队列存储待处理的节点
    Node* start = new Node{0, 0};  // 起点
    q.push(start);
    maze[0][0] = 2;  // 标记起点已访问（使用2来避免与障碍物1冲突）
    while (!q.empty()) {
        Node* now = q.front();
        q.pop();
        // 如果到达终点
        if (now->x == n - 1 && now->y == n - 1) {
            show();
            return ;  // 找到路径
        }
        
        for (int i = 0; i < 4; ++i) {        // 遍历四个方向
            int x2 = now->x + dir[i][0];
            int y2 = now->y + dir[i][1];
            // 检查新位置是否在迷宫内且可通行
            if (x2 >= 0 && x2 < n && y2 >= 0 && y2 < n && maze[x2][y2] == 0) {
                Node* next = new Node{x2, y2};
                q.push(next);  // 将新位置加入队列
                maze[x2][y2] = 2;  // 标记为已访问
            }
        }
    }
}
```





### 最小栈

> ### 算法思想
>
> 1. **主栈**：用于存储实际的数据。
> 2. **辅助栈**：用于存储每个位置对应的最小值。每次有新元素入栈时，如果该元素小于或等于辅助栈顶的元素，则将该元素也压入辅助栈。这样，辅助栈顶的元素始终是主栈中所有元素的最小值。
>
> ### 具体步骤
>
> 1. **初始化** 两个栈都为空。
> 2. **入栈 (`Push`)**：将新元素压入主栈。 如果辅助栈为空，或者新元素小于或等于辅助栈顶的元素，则将新元素也压入辅助栈。
> 3. **出栈 (`Pop`)**：从主栈弹出元素。 如果弹出的元素与辅助栈顶的元素相同，则从辅助栈也弹出该元素。
> 4. **获取最小值 (`Min`)**：  辅助栈顶的元素即为主栈中的最小值。

``` c
typedef struct MinStack {
    int data[MAXSIZE];  // 用于存储栈中的数据
    int minn[MAXSIZE];  // 用于存储每个位置对应的最小值
    int top1;           // 栈顶指针
} MinStack;

// 初始化栈
void init(MinStack &s) {
    s.top1 = -1; // 初始时栈为空
}
// 判断栈是否为空
bool empty(MinStack s) {
    return s.top1 == -1;
}
// 判断栈是否已满
bool full(MinStack s) {
    return s.top1 == MAXSIZE - 1;
}
// 获取栈顶元素
bool top(MinStack s, int &x) {
    if (empty(s))
        return false;
    x = s.data[s.top1];
    return true;
}

// 入栈操作
bool push(MinStack &s, int x) {
    if (full(s))
        return false;
    s.data[++s.top1] = x;
    // 如果是第一个元素或者新元素小于等于当前最小值，则更新最小值
    if (s.top1==0 || x <= s.minn[s.top1 - 1]) {
        s.minn[s.top1] = x;
    } else {
        s.minn[s.top1] = s.minn[s.top1 - 1];
    }
    return true;
}

// 出栈操作
bool pop(MinStack &s, int &x) {
    if (empty(s))
        return false;
    x = s.data[s.top1--];
    return true;
}

// 获取当前栈中的最小值
bool getMinimum(MinStack s, int &x) {
    if (empty(s))
        return false;
    x = s.minn[s.top1];
    return true;
}
```



### 栈模拟队列



> ### 基本思想
>
> 1. **入队操作**：将新元素压入第一个栈 `stack1`。
> 2. 出队操作：如果第二个栈 `stack2` 为空，则将 `stack1` 中的所有元素依次弹出并压入 `stack2`。
>    - 从 `stack2` 弹出一个元素，这就是队列的前端元素。
> 3. 获取队首元素：如果 `stack2` 不为空，直接返回 `stack2` 的栈顶元素。
>    -   如果 `stack2` 为空，将 `stack1` 中的所有元素依次弹出并压入 `stack2`，然后返回 `stack2` 的栈顶元素。

``` c
// 初始化队列
void initQueue(Queue *q) {
    initStack(&q->stack1);
    initStack(&q->stack2);
}

// 入队操作
int enqueue(Queue *q, int x) {
    return push(&q->stack1, x); // 将元素压入 stack1
}

// 出队操作
int dequeue(Queue *q, int *x) {
    if (isEmpty(&q->stack2)) {
        // 如果 stack2 为空，将 stack1 中的所有元素转移到 stack2
        while (!isEmpty(&q->stack1)) {
            int temp;
            if (!pop(&q->stack1, &temp))
                return 0; // 出栈失败
            if (!push(&q->stack2, temp))
                return 0; // 入栈失败
        }
    }
    // 从 stack2 弹出一个元素
    return pop(&q->stack2, x);
}
```





### InfixToSuffix



>1. **初始化**：
>
>   - 使用一个字符串 `pos` 来存储生成的后缀表达式。使用一个栈 `s` 来临时存储操作符。
>
>2. **遍历中缀表达式**：
>
>   - 从左到右逐个字符地遍历中缀表达式 `infix`。
>
>3. **处理每个字符**：
>
>   - **操作数**（数字或字母）：直接将其添加到 `pos` 中。
>
>   - **左括号 `(`**：将左括号压入栈 `s`。
>
>   - 右括号 `)`：
>
>     - 从栈 `s` 中弹出所有操作符并添加到 `pos` 中，直到遇到左括号 `(`。
>     - 弹出左括号 `(` 并丢弃它。
>
>   - 操作符
>
>     （如）：当前操作符 `ch` 的优先级小于或等于栈顶操作符的优先级，则将栈顶操作符弹出并添加到 `pos` 中，然后继续比较新的栈顶操作符。
>
>     - 将当前操作符 `ch` 压入栈 `s`。
>
>4. **处理剩余的操作符**：
>
>   - 遍历完中缀表达式后，栈 `s` 中可能还剩下一些操作符。将这些操作符依次弹出并添加到 `pos` 中。

```c
int getPriority(char ch) {
    if (ch == '+' or ch == '-') {
        return 1;
    } else if (ch == '*' or ch == '/') 
        return 2;
    return 0;
}
// 中缀表达式转后缀表达式
void InfixToSuffix( string &infix, stack<char> &s2) {
    string pos = ""; // 存储后缀表达式
    stack<char> s;   // 操作符栈

    for (int i = 0; i < infix.length(); ++i) {
        char ch = infix[i];
        if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z')) {
            pos += ch; // 操作数直接加入后缀表达式
        } else if (ch == '(') {
            s.push(ch); // 左括号入栈
        } else if (ch == ')') {
            while (!s.empty() && s.top() != '(') {
                pos += s.top();
                s.pop();
            }
            if (!s.empty())
                s.pop(); // 弹出左括号
        } else { // 操作符
            while (!s.empty() && getPriority(ch) <= getPriority(s.top())) {//(+ or - )< ( * or / )
                pos += s.top();
                s.pop();
            }
            s.push(ch);
        }
    }
    while (!s.empty()) { // 将剩余的操作符从栈中弹出
        pos += s.top();
        s.pop();
    }
    cout << "pos: " << pos << endl;
}
```





### 序列匹配(栈)

> ### 算法思想
>
> 1. **初始化**：
>    - 使用一个辅助栈 `s` 来模拟实际的栈操作。
>    - 使用两个索引 `i` 和 `j` 分别跟踪输入序列和输出序列的当前处理位置。
> 2. **遍历输出序列**：
>    - 对于输出序列中的每个元素 `output[j]`，我们需要检查它是否可以与栈顶元素匹配或者通过入栈操作到达栈顶。
>    - 如果栈顶元素与 `output[j]` 匹配，则从栈中弹出该元素，并移动到输出序列的下一个元素（即 `j++`）。
>    - 如果栈顶元素不匹配，则从输入序列中继续入栈新的元素，直到找到匹配的元素或输入序列耗尽。
>    - 如果在输入序列耗尽前仍然找不到匹配的元素，则说明无法通过栈操作得到输出序列。
> 3. **结束条件**：
>    - 如处理完输出序列中的所有元素，则可通过栈操作得到输出序列。
>    - 如发现无法匹配，则说明不能通过栈操作得到输出序列。



``` c
// 判断是否可以通过栈操作得到输出序列
bool canGetOutputFromStack(int input[], int output[], int n) {
    stack<int> s; // 辅助栈
    int i = 0; // 输入序列的索引
    int j = 0; // 输出序列的索引
    while (j < n) {
        // 尝试将输入序列中的元素入栈，直到找到与输出序列匹配的元素
        while (i < n and (s.empty() or s.top() != output[j]))
            s.push(input[i++]);
        // 如果栈顶元素与输出序列当前元素匹配，则弹出栈顶元素
        if (!s.empty() and s.top() == output[j]) {
            s.pop();
            j++; // 移动到输出序列的下一个元素
        } else
            // 如果找不到匹配的元素，则返回 false
            return false;
    }
    return true;   // 如果成功处理完输出序列中的所有元素，则返回 true
}
```





### 字符串比较大小

>### 算法思想
>
>1. **初始化**：
>   - 计算两个字符串的较小长度 `len`，这样可以确保在比较过程中不会越界。
>2. **逐字符比较**：
>   - 从第一个字符开始，逐个比较两个字符串中的字符。
>   - 如果 `s` 的当前字符小于 `t` 的当前字符，返回 `-1` 表示 `s` 小于 `t`。
>   - 如果 `s` 的当前字符大于 `t` 的当前字符，返回 `1` 表示 `s` 大于 `t`。
>   - 如果相等，继续比较下一个字符。
>3. **处理字符串长度不等的情况**：
>   - 如果在较短字符串的范围内所有字符都相等，那么需要根据字符串的长度来决定返回值。
>   - 如果 `s` = `t` 的长度，返回 `0` 
>   - 如果 `s` >`t` 的长度，返回 `1` 
>   - 如果 `s` < `t` 的长度，返回 `-1` 

``` c
int Strcmp(SqString s, SqString t) {
    int len = min(s.length, t.length);  // 取较小的长度
    for (int i = 0; i < len; ++i) {
        if (s.data[i] < t.data[i])
            return -1;  // s 小于 t
        else if (s.data[i] > t.data[i])
            return 1;  // s 大于 t
    }
    if (s.length == t.length)
        return 0;  // s 和 t 相等
    if (s.length > len)
        return 1;  // s 长度大于 t
    return -1;     // s 长度小于 t
}
```





### 顺序表二路归并

> - 定义两个指针i,j,初始分别指向la，lb的起始元素  
> - 进行遍历i，j不超过线性表的长度
> - 如果la元素<lb的元素 ，将元素插入lc表后
> -  反之 将lb插入lc表后  
> - 直至下标越界 ；
>   - 判断la 和 lb中是否还有未遍历元素 将其插入到lc后。
> - 最后，设置 `lc` 的长度为 `k`，即合并后的顺序表的实际长度



``` c 
void merge(SeqList *la, SeqList *lb, SeqList *&lc) {
    int i = 0, j = 0;
    int k = 0;
    lc = (SeqList *) malloc(sizeof(SeqList));
    while (i < la->length and j < lb->length) {
        if (la->data[i] < lb->data[j])
            lc->data[k++] = la->data[i++];
        else
            lc->data[k++] = lb->data[j++];
    }
    while (i < la->length)
        lc->data[k++] = la->data[i++];
    while (j < lb->length)
        lc->data[k++] = lb->data[j++];
    lc->length = k;
}
```





## 10-12



### 树

>树定义 ：树是一种非线性的数据结构，树是n（n>=0）个结点的有限集,n=0时，称为空树,任意一个非空树中，
>
>• 有且只有一个特定的称为根的节点； 
>
>• 当n>1时，其余结点可分为m个互不相交的有限集T1,T2,....,Tn，其中每一个集合本身又是一棵树，称为根的子树。 
>
>• 树的根结点没有前驱，除根结点外的所有结点有且仅有一个前驱； 
>
>• 树中所有结点可以有零个或多个后继



>树的性质： 
>
>• 1.树中的结点数等于所有结点的度数之和+1 
>
>• 2.度为m的树中第i层上最多有m^(i-1)个结点 
>
>• 3.高度为h的m叉树最多有(m^h -1)/(m-1)个结点



### 二叉树

> 二叉树定义 ：是另一种树形结构，特点是每个节点至多只有两颗子树，即二叉树中不存在度大于2的几点， 并且，二叉树的子树有左右之分，其次序不能任意颠倒。 
>
>    二叉树性质： 
>
> - 1.二叉树的第i层上至多有2^(i-1)个结点，i>=1; 
> - 2.深度为k的二叉树至多有2^k-1个节点，k>=1; 
> - 3.对任意一颗二叉树，如果其终端节点数为n0，度为2的节点数为n2，则有n0=n2+1。 
> - 4.具有n个结点的完全二叉树的深度为⌊ log2n⌋ +1 
> - 5.对一颗具有n个结点的完全二叉树的结点按照层序编号，对任一节点i，有： 
>   - （1）如果i=1，则结点i时二叉树的根，无双亲；如果i>1,则双亲是节点⌊ i/2⌋ ; 
>   - （2）如果2i>n，则节点i无左孩子，否则其左孩子是结点2i； 
>   - （3）如果2i+1>n，则结点i无右孩子,否则其右孩子是节点2i+1.





### else 

> 其他定义 ： 
>
> • 满二叉树：高度为h，且含有2^h -1个结点的二叉树称为满二叉树。 
>
> • 完全二叉树：高度为h有n个结点的二叉树，当且仅当每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。 
>
> • 二叉排序树：左子树上的所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根结点的关键字；左子树和右子树又各是 一棵二叉排序树。 
>
> • 平衡二叉树：树上任意结点的左子树和右子树的深度之差不超过1。



### 树遍历

#### 先中后(递归)

``` c
// 前序遍历
void preOrder(BiNode *root) {
    if (root == NULL)
        return;
    cout << " " << root->data; // 访问根节点
    preOrder(root->left);      // 递归遍历左子树
    preOrder(root->right);     // 递归遍历右子树
}
// 中序遍历
void inOrder(BiNode *root) {
    if (root == NULL)
        return;
    inOrder(root->left);       // 递归遍历左子树
    cout << " " << root->data; // 访问根节点
    inOrder(root->right);      // 递归遍历右子树
}
// 后序遍历
void postOrder(BiNode *root) {
    if (root == NULL)
        return;
    postOrder(root->left);     // 递归遍历左子树
    postOrder(root->right);    // 递归遍历右子树
    cout << " " << root->data; // 访问根节点
}
```



#### 先序(非递归)

> 1. **初始化**：
>    - 创建一个空栈 `st`。设置指针 `p` 指向根节点 `root`。
> 2. **主循环**：
>    - 使用 `while (p != NULL || !st.empty())` 循环，只要当前节点 `p` 不为空或栈不为空，就继续循环。
> 3. **处理左子树**：
>    - 使用内部while (p != NULL)循环，一直向左子树走：
>      - 输出当前节点 `p` 的数据。
>      - 将当前节点 `p` 压入栈中。
>      - 将 `p` 指向其左子节点。
> 4. **处理右子树**：
>    - 当左子树走到头（即p为空）时：
>      - 从栈中弹出一个节点，并将其赋值给 `p`。
>      - 将 `p` 指向其右子节点，并继续循环。
> 5. **结束条件**：
>    - 当 `p` 为空且栈也为空时，表示整个树已经遍历完成，退出循环。



``` c 
void preOrder(BiNode *root) {
    if (root == NULL)
        return;
    stack<BiNode *> st;
    BiNode *p = root;
    while (p != NULL or !st.empty()) {
        if (p != NULL) {
            cout << " " << p->data;
            st.push(p);
            p = p->left;
        } else {
            p = st.top();
            st.pop();
            p = p->right;
        }
    }
}
```





#### 中序 非递归

``` c
void inOrder(BiNode *root) {
    if (root == NULL)
        return;
    stack<BiNode *> st;
    BiNode *p = root;
    while (p != NULL or !st.empty()) {
        if (p != NULL) {
            st.push(p);
            p = p->left;
        } else {
            p = st.top();
            cout << " " << p->data;
            st.pop();
            p = p->right;
        }
    }
}

void inOrder2(BiNode *root) {
    if (root == NULL)
        return;
    stack<BiNode *> st;
    BiNode *p = root;
    while (p != NULL || !st.empty()) {
        // 一直向左子树走，并将路径上的所有节点压入栈
        while (p != NULL) {
            st.push(p);
            p = p->left;
        }
        // 弹出栈顶节点并访问它
        if (!st.empty()) {
            p = st.top();
            st.pop();
            cout << " " << p->data;
            // 转向该节点的右子树
            p = p->right;
        }
    }
}

```



#### 后序 非递归

> ### 详细解释
>
> 1. **初始化**：
>    - 初始化 `preVisited` 为 `NULL`，用于记录上一个被访问的节点。
> 2. **主循环**：
>    - 使用 `while (p != NULL || !st.empty())` 循环，只要当前节点 `p` 不为空或栈不为空，就继续循环。
> 3. **处理左子树**：
>    - 使用内部while (p != NULL)循环，一直向左子树走：
>      - 将当前节点 `p` 压入栈中。
>      - 将 `p` 指向其左子节点。
> 4. **处理右子树和根节点**：
>    - 获取栈顶节点 `p`。
>    - 检查当前节点p是否满足以下条件之一：
>      - `p` 没有右子树（即 `p->right == NULL`）。
>      - `p` 的右子树已经被访问过（即 `p->right == preVisited`）。
>    - 如果满足上述条件之一，则访问当前节点 `p`，并更新 `preVisited` 为当前节点 `p`。
>    - 将 `p` 设为 `NULL`，以便下一次循环从栈中取新的节点。
>    - 如果不满足上述条件，则转向右子树（即 `p = p->right`）。
> 5. **结束条件**：
>    - 当 `p` 为空且栈也为空时，表示整个树已经遍历完成，退出循环。

``` c

// 非递归后序遍历
void postOrder(BiTree root) {
    if (root == NULL)
        return;
    stack<BiNode*> st;
    BiNode *p = root;
    BiNode *preVisited = NULL; // 用于记录上一个被访问的节点
    while (p != NULL || !st.empty()) {
        // 一直向左子树走，并将路径上的所有节点压入栈
        while (p != NULL) {
            st.push(p);
            p = p->left;
        }
        // 获取栈顶节点
        p = st.top();
        // 如果当前节点没有右子树，或者右子树已经被访问过
        if (p->right == NULL || p->right == preVisited) {
            cout << " " << p->data; // 访问当前节点
            st.pop();
            preVisited = p; // 更新上一个被访问的节点
            p = NULL; // 将 p 设为 NULL，以便下一次循环从栈中取新的节点
        } else {
            // 否则，转向右子树
            p = p->right;
        }
    }
}
```



> 1. **主循环**：
>
>    - 使用 `while (p != NULL || !st.empty())` 循环，只要当前节点 `p` 不为空或栈不为空，就继续循环。
>
> 2. **处理左子树**：
>
>    - 使用内部while (p != NULL)
>
>       循环，一直向左子树走：
>
>      - 将当前节点 `p` 压入栈中，并设置 `p->isFirst` 为 `true`，表示这是第一次访问该节点。
>      - 将 `p` 指向其左子节点。
>
> 3. **处理右子树和根节点**：
>
>    - 获取栈顶节点 `p` 并弹出。
>
>    - 如果p->isFirst 为true
>
>      ，表示这是第一次访问该节点：
>
>      - 将 `p->isFirst` 设置为 `false`，表示已经访问过。
>      - 再次将 `p` 压入栈中。
>      - 将 `p` 指向其右子节点。
>
>    - 如果
>
>      p->isFirst为false
>
>      ，表示这是第二次访问该节点：
>
>      - 输出当前节点 `p` 的数据。
>      - 将 `p` 设为 `NULL`，以便下一次循环从栈中取新的节点。
>
> 4. **结束条件**：
>
>    - 当 `p` 为空且栈也为空时，表示整个树已经遍历完成，退出循环。

``` c
// 非递归后序遍历
void postOrder2(BiTree root) {
    if (root == NULL)
        return;
    stack<BiNode*> st;
    BiNode *p = root;

    while (p != NULL || !st.empty()) {
        // 一直向左子树走，并将路径上的所有节点压入栈
        while (p != NULL) {
            p->isFirst = true; // 标记为第一次访问
            st.push(p);
            p = p->left;
        }
        if (!st.empty()) {
            p = st.top();
            st.pop();
            if (p->isFirst == true) {
                // 第一次访问，标记为已访问并处理右子树
                p->isFirst = false;
                st.push(p); // 再次压入栈
                p = p->right; // 转向右子树
            } else {
                // 第二次访问，输出节点数据
                cout << " " << p->data;
                p = NULL; // 将 p 设为 NULL，以便下一次循环从栈中取新的节点
            }
        }
    }
}
```



### 中序线索化

> ### 代码思想
>
> 1. **中序线索化**：
>    - 中序遍历二叉树时，将每个节点的空指针（左或右）指向其在中序遍历中的前驱或后继节点。
>    - 这样可以方便地进行中序遍历，而不需要使用递归或栈。
> 2. **创建中序线索二叉树**：
>    - 通过递归的方式对二叉树进行中序遍历，并在遍历过程中设置每个节点的线索。
> 3. **查找中序遍历的第一个节点**：
>    - 从根节点开始，一直向左子树移动，直到找到没有左子树的节点。
> 4. **查找中序遍历的下一个节点**：
>    - 如果当前节点有右子树，找到右子树中最左边的节点。
>    - 如果当前节点没有右子树，直接返回右指针指向的节点。
> 5. **中序遍历线索化二叉树**：
>    - 从第一个节点开始，依次访问每个节点，并输出节点的数据。

``` c
#include <iostream>
using namespace std;

// 定义二叉树节点结构
typedef struct BiNode {
    int data;
    struct BiNode *left, *right;
    int ltag, rtag; // 0 表示指向子节点，1 表示线索
} BiNode, *BiTree;

// 中序线索化
void inThread(BiTree &p, BiTree &pre) {
    if (p != NULL) {
        inThread(p->left, pre); // 先线索化左子树
        // 如果当前节点的左子树为空，将其左指针指向前驱节点
        if (p->left == NULL) {
            p->left = pre;
            p->ltag = 1; // 左指针为线索
        }
        // 如果前驱节点的右子树为空，将其右指针指向当前节点
        if (pre != NULL && pre->right == NULL) {
            pre->right = p;
            pre->rtag = 1; // 右指针为线索
        }
        pre = p; // 更新前驱节点为当前节点
        inThread(p->right, pre); // 线索化右子树
    }
}

// 创建中序线索二叉树
void CreateInThread(BiTree &tree) {
    BiNode *pre = NULL; // 初始前驱节点为 NULL
    if (tree != NULL) {
        inThread(tree, pre);
        if (pre != NULL) {
            pre->right = NULL; // 最后一个节点的右指针设为 NULL
            pre->rtag = 1; // 右指针为线索
        }
    }
}

// 查找中序遍历的第一个节点
BiNode *firstNode(BiNode *p) {
    while (p != NULL && p->ltag == 0) { // 一直找到最左边的节点
        p = p->left;
    }
    return p;
}

// 查找中序遍历的下一个节点
BiNode *nextNode(BiNode *p) {
    if (p->rtag == 0) { // 如果有右子树，找到右子树中最左边的节点
        return firstNode(p->right);
    } else {
        return p->right; // 如果没有右子树，直接返回右指针
    }
}

// 中序遍历线索化二叉树
void inOrder(BiTree root) {
    BiNode *p = firstNode(root); // 找到第一个节点
    while (p != NULL) {
        cout << p->data << " "; // 输出当前节点的数据
        p = nextNode(p); // 找到下一个节点
    }
    cout << endl;
}

```





#### 层序

> 1. **初始化**：
>    - 检查根节点 `root` 是否为空，如果为空则直接返回。
>    - 创建一个队列 `q` 并将根节点 `root` 压入队列。
> 2. **主循环**：
>    - 使用 `while (!q.empty())` 循环，只要队列不为空，就继续循环。
> 3. **处理当前节点**：
>    - 从队列中取出一个节点 `p` 并访问它，输出其数据。
>    - 如果 `p` 的左子节点不为空，则将其压入队列。
>    - 如果 `p` 的右子节点不为空，则将其压入队列。
> 4. **结束条件**：
>    - 当队列为空时，表示整个树已经遍历完成，退出循环。

``` c

// 层次遍历
void level(BiTree root) {
    if (root == NULL)
        return;
    queue<BiNode*> q;
    q.push(root);
    while (!q.empty()) {
        BiNode *p = q.front();
        q.pop();
        cout << " " << p->data;
        // 将左子节点压入队列（如果存在）
        if (p->left != NULL) 
            q.push(p->left);
        // 将右节点压入队列（如果存在）
        if (p->right != NULL) 
            q.push(p->right);
    }
}	
```





#### 求深度

>1. **基本情况**： 采用递归思想
>  - 如果 `root` 为空（即 `root == NULL`），则返回 0，表示空树的深度为 0。
>2. **递归情况**：
>  - 递归计算左子树的深度 `leftDepth = deep(root->left)`。
>  - 递归计算右子树的深度 `rightDepth = deep(root->right)`。
>  - 使用 `std::max` 函数比较左右子树的深度，取较大值，并加 1（表示当前节点本身）。
>  - f(b) = 0 ，b=NULL
>  -  f(b) = MAX{f(b->lchild)，f(b->rchild)}+1 其他情况

``` c
int deep(BiNode *root){
    if (root==NULL)
        return 0;
    return max(deep(root->left), deep(root->right))+1;
}
```





#### 括号输出二叉树



``` c
void output(BiNode *root) {
    if (root != NULL) {
        cout << root->data;
        if (root->left != NULL or root->right != NULL) {
            cout << "(";
            output(root->left);
            if (root->left != NULL)
                cout << ",";
            else
            output(root->right);
//            if (root->right != NULL)
            cout << ")";
        }
    }
}
```





#### 销毁二叉树

> 1. **基本情况**： 先序 根左右
>    - 如果当前节点 `root` 为空（即 `root == NULL`），则直接返回。这表示已经到达了叶子节点的子节点，无需进一步处理。
> 2. **递归步骤**：
>    - **处理左子树**：递归调用 `destroyBiTree(root->left)` 来销毁左子树。
>    - **处理右子树**：递归调用 `destroyBiTree(root->right)` 来销毁右子树。
>    - **处理当前节点**：在左右子树都被销毁后，删除当前节点 `root` 并将其指针置为 `NULL`。

``` c
void destroyBiTree(BiNode *&root) {
    //思想后序 先删 左边 再删右边 再删根 递归
    if (root == NULL)
        return;
    destroyBiTree(root->left);
    destroyBiTree(root->right);
    free(root);
    root=NULL;
}
```





#### 二叉树根据值查找

> 1.  如果根节点为空返回NULL  先序
> 2. 否则判断值是否相等
>    -  若值相等，返回结点地址
>    -  若不相等递归的对左右子树进行查找
> 3. 若左右子树都为空返回NULL 

```c
BiNode* findBiNode(BiNode *root, int x) {// 在二叉树中查找值为 x 的节点 
    if (root == NULL)
        return NULL;
    // 检查当前节点的值是否等于 x
    if (root->data == x) 
        return root; // 找到节点，返回其指针
    // 递归查找左子树
    BiNode* leftResult = findBiNode(root->left, x);
    if (leftResult != NULL) 
        return leftResult; // 如果在左子树中找到，返回结果
    // 递归查找右子树
    BiNode* rightResult = findBiNode(root->right, x);
    if (rightResult != NULL) 
        return rightResult; // 如果在右子树中找到，返回结果
   
    return NULL; // 如果在左右子树中都没有找到，返回 NULL
}
    char pre[] = "ABDGCEF";
    char in[] = "DGBAECF";
```





#### 创建二叉树(前+中)

> 1. **确定根节点**：
>    - 前序遍历的第一个元素是根节点。
> 2. **在中序遍历中找到根节点的位置**：
>    - 在中序遍历数组中找到根节点的位置 `k`，这样可以将中序遍历数组分为左子树和右子树两部分。
> 3. **递归构建左子树和右子树**：
>    - 左子树的前序遍历数组是从 `pre[1]` 到 `pre[k]`，中序遍历数组是从 `in[0]` 到 `in[k-1]`。
>    - 右子树的前序遍历数组是从 `pre[k+1]` 到 `pre[n-1]`，中序遍历数组是从 `in[k+1]` 到 `in[n-1]`。
> 4. **递归终止条件**：
>    - 如果数组长度为 0 或负数，则返回 `NULL`。

``` c
BiTree createBiTreeByPreAndIn(char pre[], char in[], int n) {
    if (n <= 0)
        return NULL; // 如果数组长度为 0 或负数，则返回 NULL
    // 创建当前节点
    BiTree root = new BiNode;
    root->data = pre[0]; // 前序遍历的第一个元素是根节点
    root->left = root->right = NULL;
    // 在中序遍历中找到根节点的位置
    int k;
    for (k = 0; k < n; k++) {
        if (in[k] == pre[0])
            break; // 找到根节点在中序遍历中的位置
    }
    // 递归创建左子树
    // 左子树的前序遍历数组是从 pre[1] 到 pre[k]
    // 左子树的中序遍历数组是从 in[0] 到 in[k-1]
    root->left = createBiTreeByPreAndIn(pre + 1, in, k);
    // 递归创建右子树
    // 右子树的前序遍历数组是从 pre[k+1] 到 pre[n-1]
    // 右子树的中序遍历数组是从 in[k+1] 到 in[n-1]
    root->right = createBiTreeByPreAndIn(pre + k + 1, in + k + 1, n - k - 1);
    return root; // 返回当前根节点
}	
```





#### 创建二叉树(中+后)

> 1. **确定根节点**：   中序寻左右 后序寻找根
>    - 后序遍历的最后一个元素是根节点。
> 2. **在中序遍历中找到根节点的位置**：
>    - 在中序遍历数组中找到根节点的位置 `k`，这样可以将中序遍历数组分为左子树和右子树两部分。
> 3. **递归构建左子树和右子树**：
>    - 左子树的中序遍历数组是从 `in[0]` 到 `in[k-1]`，后序遍历数组是从 `post[0]` 到 `post[k-1]`。
>    - 右子树的中序遍历数组是从 `in[k+1]` 到 `in[n-1]`，后序遍历数组是从 `post[k]` 到 `post[n-2]`。
> 4. **递归终止条件**：
>    - 如果数组长度为 0 或负数，则返回 `NULL`。

``` c
BiTree createBiTreeByInAndPost(char in[], char post[], int n) {
    if (n <= 0)
        return NULL; // 如果数组长度为 0 或负数，则返回 NULL
    // 创建当前节点
    BiTree root = new BiNode;
    root->data = post[n - 1]; // 后序遍历的最后一个元素是根节点
    root->left = root->right = NULL;

    // 在中序遍历中找到根节点的位置
    int k;
    for (k = 0; k < n; k++) {
        if (in[k] == post[n - 1])
            break; // 找到根节点在中序遍历中的位置
    }
    // 递归创建左子树
    // 左子树的中序遍历数组是从 in[0] 到 in[k-1]
    // 左子树的后序遍历数组是从 post[0] 到 post[k-1]
    root->left = createBiTreeByInAndPost(in, post, k);

    // 递归创建右子树
    // 右子树的中序遍历数组是从 in[k+1] 到 in[n-1]
    // 右子树的后序遍历数组是从 post[k] 到 post[n-2]
    root->right = createBiTreeByInAndPost(in + k + 1, post + k, n - k - 1);
    return root; // 返回当前根节点
}

```





#### 是否为满二叉树

``` c
// 判断是否为满二叉树
bool isFullBiTree(BiTree root) {
    if (root == NULL)
        return true; // 空树被认为是满二叉树
    queue<BiNode *> q;
    q.push(root); // 将根节点加入队列
    while (!q.empty()) {
        BiNode *p = q.front();
        q.pop();
        if (p == NULL) { // 遇到第一个空节点
            // 检查队列中剩余的所有节点是否都为空
            while (!q.empty()) {
                if (q.front() != NULL)
                    return false; // 如果遇到非空节点，说明不是满二叉树
                q.pop();
            }
            return true; // 所有剩余节点都为空，是满二叉树
        }
        // 将当前节点的左右子节点加入队列
        q.push(p->left);
        q.push(p->right);
    }
    return true; // 遍历完所有节点，没有遇到空节点，是满二叉树
}

```





#### 顺序表转二叉树

> 1. **将数组转换为二叉树**：
>    - `SeqToLinkList` 函数接受数组 `arr`、数组长度 `n`、当前索引 `i` 和根节点引用 `root` 作为参数。
>    - 如果当前索引 `i` 超过数组长度 `n`，返回。
>    - 创建新节点 `root`，并设置其数据为 `arr[i - 1]`（注意：数组下标从0开始）。
>    - 递归创建左子树，如果 `2 * i` 不超过数组长度 `n`。
>    - 递归创建右子树，如果 `2 * i + 1` 不超过数组长度 `n`。

```c
void SeqToLinkList(char arr[], int n, int i, BiTree &root) {
    //数组下标从1 开始
    if (i > n)
        return;
    root = new BiNode;
    root->data = arr[i];
    SeqToLinkList(arr, n, 2 * i, root->left);
    SeqToLinkList(arr, n, 2 * i + 1, root->right);
};
```





#### 二叉排序树

``` c
bool isBST(BiTree root, int *prev) {
    if (root == NULL)
        return true;
    // 首先检查左子树
    bool left = isBST(root->left, prev);
    // 然后检查当前节点
    if (*prev >= root->data)
        return false;
    // 更新前一个节点的值
    *prev = root->data;
    // 最后检查右子树
    bool right = isBST(root->right, prev);
    // 如果左右子树都是BST，则整个树也是BST
    return left && right;
}
```





#### 分层输出

> ### 算法思想
>
> 1. **层次遍历**：
>    - 当队列不为空时，进入循环。
>    - 计算当前层的节点数`count`，即队列中的元素个数。
>    - 打印当前层数`deep`。
> 2. **处理当前层的所有节点**：
>    - 对于当前层的每个节点（共count个）：
>      - 从队列中取出一个节点。打印该节点的数据。
>      - 将该节点的左,右节点（如果存在）加入队列。
> 3. **更新层数**：
>    - 在处理完当前层的所有节点后，增加层数`deep`。更新队列大小，准备处理下一层。
> 4. **重复步骤2-4**：
>    - 重复上述过程，直到队列为空，即所有层都已处理完毕。

``` c
void levelOrderAndOutput(BiNode* root) { // 分层遍历
    if (root == NULL)
        return;
    queue<BiNode*> q;
    q.push(root);
    int deep = 1;
    while (!q.empty()) {
        int count = q.size(); // 当前层的节点数量
        cout << "this is " << deep << " level: ";
        for (int i = 0; i < count; ++i) {
            BiNode* p = q.front();
            q.pop();
            cout << p->data << " "; // 打印节点数据
            // 将子节点加入队列
            if (p->left != NULL)
                q.push(p->left);
            if (p->right != NULL)
                q.push(p->right);
        }
        cout << endl; // 换行到下一层
        deep++; // 层次计数增加
    }
}
```



#### 结点个数

> ### 算法思想
>
> 1. **基本情况**：
>    - 如果当前节点`root`为空（即`root == NULL`），则返回0。这表示没有节点可以计数，因此节点总数为0。
> 2. **递归步骤**：
>    - 对于每个非空节点，我们递归地计算其左子树和右子树的节点总数。
> 3. **节点计数**：
>    - 除了左右子树的节点外，当前节点本身也需要计入总数。因此，我们将左右子树的节点总数加上1（代表当前节点）。
> 4. **返回结果**：

``` c#
int sumNode(BiNode *root) {
    if (root == NULL)
        return 0;
    // 递归计算左子树的节点总数
    int leftCount = sumNode(root->left);
    // 递归计算右子树的节点总数
    int rightCount = sumNode(root->right);
    // 当前节点的总数是左子树、右子树的节点数加上当前节点本身
    return leftCount + rightCount + 1;
}
```





#### 叶节点个数

> 1. **基本情况**：
>    - 如果当前节点`root`为空（即`root == NULL`），则直接返回，因为空节点不是叶子节点。
> 2. **叶子节点检测**：
>    - 如果当前节点`root`既没有左子节点也没有右子节点（即`root->left == NULL and root->right == NULL`），那么它是一个叶子节点。在这种情况下，将计数器`sum`加1。
> 3. **递归步骤**：
>    - 递归地调用`countLeaf`函数处理当前节点的左子树和右子树。
> 4. **累积结果**：
>    - 由于`sum`是引用传递，因此每次递归调用都会更新同一个`sum`变量，最终得到整棵树中所有叶子节点的总数。

``` c
void countLeaf(BiNode *root, int &sum) {
    if (root == NULL)
        return; // 空节点，直接返回
    // 检查当前节点是否为叶子节点
    if (root->left == NULL && root->right == NULL) {
        sum++; // 当前节点是叶子节点，计数加1
    }
    // 递归处理左子树
    countLeaf(root->left, sum);
    // 递归处理右子树
    countLeaf(root->right, sum);
}
```





#### 查找结点所在层次

> ### 算法思想
>
> 1. **基本情况**：
>    - 如果当前节点`root`为空（即`root == NULL`），则返回0，表示没有找到目标节点。
>    - 如果当前节点的数据域等于`x`（即`root->data == x`），则返回当前层次`h + 1`，表示找到了目标节点。
> 2. **递归步骤**：
>    - 递归地在子树中查找目标节点。如果在子树中找到了目标节点，则返回其所在层次。
> 3. **层次计算**：
>    - 每次递归调用时，传递的层次参数`h`加1，以反映当前节点所在的层次。
> 4. **返回结果**：
>    - 如果在左子树或右子树中找到了目标节点，则返回其所在层次。否则返回0。

``` c
int findLevel(BiNode *root, int x, int h) {
    if (root == NULL)
        return 0; // 空节点，返回0
    if (root->data == x)
        return h + 1; // 找到目标节点，返回当前层次
    // 递归在左子树中查找
    int leftLevel = findLevel(root->left, x, h + 1);
    if (leftLevel != 0)
        return leftLevel; // 在左子树中找到了目标节点
    // 递归在右子树中查找
    int rightLevel = findLevel(root->right, x, h + 1);
    if (rightLevel != 0)
        return rightLevel; // 在右子树中找到了目标节点
    // 左右子树中都没有找到目标节点
    return 0;
}
```



#### 是否相似

> 1. **基本情况**：
>    - 如果两个节点都为空（即`b1 == NULL and b2 == NULL`），则认为这两棵树是相似的，返回`true`。
>    - 如果一个节点为空而另一个不为空（即`b1 == NULL or b2 == NULL`），则认为这两棵树不相似，返回`false`。
> 2. **递归步骤**：
>    - 比较`b1`的左子树和`b2`的左子树是否相似。
>    - 比较`b1`的右子树和`b2`的右子树是否相似。
> 3. **返回结果**：
>    - 如果左右子树都相似，则返回`true`，表示整棵树是相似的。否则，返回`false`。

``` c
bool beSimilar(BiNode *b1, BiNode *b2) {
    // 两个节点都为空，返回true
    if (b1 == NULL && b2 == NULL)
        return true;
    // 一个节点为空而另一个不为空，返回false
    if (b1 == NULL || b2 == NULL)
        return false;
    // 递归比较左子树和右子树
    return beSimilar(b1->left, b2->left) && beSimilar(b1->right, b2->right);
}
```





#### 祖先结点

> ### 算法思想
>
> 1. **基本情况**：
>    - 如果当前节点`root`为空（即`root == NULL`），则直接返回。
>    - 如果当前节点的数据域等于`x`（即`root->data == x`），则找到了目标节点，开始输出祖先节点。
> 2. **记录路径**：
>    - 在递归过程中，使用数组`key`记录路径上的节点数据。
>    - 使用数组`arr`记录每个节点在数组`key`中的索引位置，方便回溯。不过，在您的代码中，`arr`并没有被使用，因此可以省略。
> 3. **递归步骤**：
>    - 递归地在左子树中查找目标节点。
>    - 递归地在右子树中查找目标节点。
> 4. **输出祖先**：
>    - 当找到目标节点时，从当前节点回溯到根节点，依次输出祖先节点。

``` c
int key[20];        // 用于存储路径上的节点数据
void outputAncestors(BiNode *root, int x, int i) {
    if (root == NULL)
        return;
    key[i] = root->data;// 记录当前节点的数据
    if (root->data == x) {  // 如果找到了目标节点
        cout << "Ancestors of " << x << " are: ";
        while (i > 1) { // 回溯到根节点
            cout << key[i / 2] << " - "; // 输出祖先节点
            i /= 2;
        }
        return;
    }
    outputAncestors(root->left, x, i * 2 + 1);// 递归在左子树中查找
    outputAncestors(root->right, x, i * 2 + 2);    // 递归在右子树中查找
}
```







### 10-16



#### 关键路径

> 1. **事件Vj 的最早发生时间Ve[j]**：这是指从源点到顶点Vj的最大路径长度。换句话说，它是顶点Vj能发生的最早时间。计算方法是从源点出发，沿着路径到达顶点Vj所需要的最长时间。
> 2. **事件Vj 的最迟发生时间VI[j]**：这是指在不推延整个工期的前提下，事件Vj最晚必须发生的时间。计算方法是从终点向回追溯，逆着路径到达顶点Vj所需要的最短时间。
> 3. **活动ak的最早开始时间e[k]**：这是指活动ak的尾事件的最早发生时间。也就是说，活动ak可以在其尾事件的最早发生时间之后开始执行。
> 4. **活动ak的最晚开始时间l[k]**：这是指活动ak的弧头顶点事件允许的最晚发生时间减去该活动持续的时间。简单地说，就是活动ak的尾事件的最迟发生时间减去活动ak的持续时间。
> 5. **活动ak的时间余量diff[k]=l[k]-e[k]**：这是指活动ak的最晚开始时间和最早开始时间之差。如果时间余量为0，说明活动ak是关键活动，因为任何延迟都会影响项目的整体进度。
>
> ==需要改变所有关键路径 共有的活动才能减少时间== 



- 1 

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241015190508737.png" alt="image-20241015190508737" style="zoom:50%;" />



- 2 

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241016090119313-1729040481929-9.png" alt="image-20241016090119313" style="zoom:50%;" />

- 3

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241016090106133-1729040469066-7.png" alt="image-20241016090106133" style="zoom:50%;" />

- 4 

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241016090051155-1729040452976-5.png" alt="image-20241016090051155" style="zoom:50%;" />





- 5 

<img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241016090028191-1729040430354-3.png" alt="image-20241016090028191" style="zoom:50%;" />











### 10-17

> - 二叉排序树查找 ，第一次就找到也算一次， 空结点算上一层，比如 root.left.right==0 算2不算3，总数除以数组个数
>
> - 散列表
>   - α =元素个数/表长
>   - 如果是再探，往后移动 ，那么失败就是找到空为止，除以数组长度，不是hash的长度
>   - 如果是 链地址，除hash的长度
>









### 10-20

#### 一、链表重排：

  有一个带头结点单链表 L={a1,a2...an}，设计一个空间复杂度 O(1)，时间上尽可能高效的算法，重新排列 L 中的结点，得到一个新的单链表 L'={a1，an，a2，a(n-1)，a3，a(n-2)



> 1.给出算法设计思想并实现；
>
> 1. **计算链表长度**：
>    - 使用 `n` 计数器遍历链表，计算链表的长度。
> 2. **找到中间节点**：
>    - 通过再次遍历链表，找到中间节点 `mid`。
> 3. **反转后半部分链表**：
>    - 从中间节点开始，反转后半部分链表。
> 4. **合并前半部分和反转后的后半部分**：
>    - 交替连接前半部分和反转后的后半部分，形成新的链表。
> 5. **处理剩余节点**：
>    - 如果前半部分或后半部分还有剩余节点，将它们连接到新链表的末尾。



``` c

// 重新排列链表
LinkList rearrangeList(LinkList list) {
    // 计算链表长度
    int n = 0;
    LNode *p = list->next;
    while (p != NULL) {
        n++;
        p = p->next;
    }
    // 找到中间节点
    p = list->next;
    for (int i = 1; i <= n / 2; ++i)
        p = p->next;
    LNode *mid = p;

    // 反转后半部分链表
    LNode *prev = NULL, *curr = mid->next, *next = NULL;
    while (curr != NULL) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    mid->next = NULL; // 断开前半部分和后半部分
    LNode *right = prev; // 反转后的后半部分头节点

    // 合并前半部分和反转后的后半部分
    LNode *left = list->next;
    LinkList newList = list;
    newList->next = NULL;
    LNode *tail = newList;

    while (left != NULL && right != NULL) {
        tail->next = left;
        left = left->next;
        tail = tail->next;
        tail->next = right;
        right = right->next;
        tail = tail->next;
    }
    // 如果左半部分或右半部分还有剩余节点
    if (left != NULL) 
        tail->next = left;
     else if (right != NULL) 
        tail->next = right;
    
    return newList;
}

```



> 二、请回答以下问题：
>
>  
>
> 1. ==队列在顺序存储时的“假溢出”现象指什么？==
>
> - 假溢出就是在在顺序存储时，rear指针到达末尾，但是队列前面却有空的存储结点
> - 比如 1 2 3 4 5 6 
> - ​        B C F H
> - 到达队尾但是1 ，2 结点并没有存放元素
>
>  
>
> 2. ==简述一种可行的假溢出的解决方法。==
>
> - 改用循环队列，当rear到达队尾后，重新从0开始依次向后存储,
> - 为了让其到达队尾后能从头开始，入队时 rear=(rear+1)%MaxSize;
>
>  
>
> 
>
> 3. 若用数组 q[1..m]表示队列，队列头指针 front、尾指针 rear 的初值均为 1,基于第二问中的方法，如何求队列的当前长度？如何判定队空？如何判定队满？
>
>      - 队空 rear==front;
>      - 队满 (rear+1)%MaxSize==front;







#### 三、括号价值求和：

> 有一个字符串，由左括号'('和右括号')'组成，保证输入的括号匹配性是合法的。每一对括号都有价值，深度为 1 的括号，价值为 1，深度为 2 的括号价值为 2，求该序列的所有对括号的价值和。
>
> 例如： "((()))"，这三对 括号的深度分别为 1、2、3，则价值和为 6。"()(())"，这三对括号的深度分别为 1、1、2，则价值和为 4。
>
> eg:
>
> 输入："((()))(())" 输出：9
>
> 输入："()()()()" 输出：4



>算法思想
>
>1. 如果遇到'('入栈，deep++；
>2. 遇到')'出栈，统计总和,deep--;
>3. 直至循环结束则求的总价值

``` c
void countValue(string str, int len) {
    stack<char> s; // 用于存储左括号
    int deep = 0;  // 当前括号的深度
    int sum = 0;   // 所有括号的价值和
    for (int i = 0; i < len; ++i) {
        if (str[i] == '(') {
            s.push(str[i]); // 遇到左括号，入栈
            deep++;         // 深度加1
        } else {
            s.pop();       // 遇到右括号，出栈
            sum += deep;   // 累加当前深度到总价值
            deep--;        // 深度减1
        }
    }
    cout << "total value: " << sum << endl;
}
```





#### 四、转换为等价的中缀表达式



> 四、请设计一个算法，将给定的表达式树（二叉树）转换为等价的中缀表达式(通过括号反映操作符的计算次序）并输出。例如，当下列两棵表达式树作为算法的输入时，输出的等价中缀表达式分别为(a+b)*(c*(-d))和(a*b)+(-(c-d))。
>
> 二叉树结点定义如下:
>
> typedef struct node{
>
> char data[10];     //存储操作数或操作符 
>
> struct node * left, *right;
>
> }BTree;
>
> 

 

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/clip_image002.jpg) |



> - **基本思路**：
>   - 使用谦虚遍历表达式树，在此基础上在适当的位置添加括号以保持正确的计算次序。
>   - 若节点值为操作数直接输出
>   - 节点值为操作符号，则遍历完左子树后加'(',遍历完右子树后加')'
>   - 根节点不需要加括号。



``` c
// 递归转换函数
void convert(BTree root, int level) {
    if (root == NULL)
        return;
    if (root->left == NULL and root->right == NULL)//叶子结点不需要加括号
        cout << root->data;
    else {
        if (level > 0)//根节点这一层 不需要加括号
            cout << "(";
        convert(root->left, level + 1);
        cout << root->data;
        convert(root->right, level+1);
        if (level > 0)
            cout << ")";
    }
}
```





#### 五、小根堆

> 五、 小根堆：
>
> 1. 已知一组数据 heap[1,2.…n-1]符合小根堆，现在加入一个数据 x 放在 heap[n]的位置，请设计算法调整后，整个数组 heap[1,2...n]仍然符合小根堆.
>    -  从结点1开始，插入结点值比当前结点值小，则交换
>    -  否则选择其左右子树中较小的一棵 ，继续向下比较
>    - 直到 结点整个数组继续符合带根对的行知
>
>  2. 根据第一问的算法，设计小根堆的建堆算法。





#### 六、建树非递归

> 1. **初始化**：
>    - 创建根节点并将其加入队列。
> 2. **层次遍历**：
>    - 使用一个队列来进行层次遍历（广度优先遍历）。
>    - 从根节点开始，处理每个节点的左右子节点。
>    - 如果当前节点的左子节点在数组中的位置不为空且值不是 -1，则创建左子节点，并将其加入队列。
>    - 同样地，当前节点的右子节点在数组中位置不为空且值不是 -1，则创建右子节点，并将其加入队列。
> 3. **构建二叉树**：
>    - 通过上述过程，逐步构建出整个二叉链表树。



``` c
BiTree createBiTree(int arr[], int k) {// 创建二叉链表树
    int n = pow(2, k) - 1; // 数组中元素的个数
    // 创建根节点
    BiTree tree = new BiNode(arr[1]);
    queue<BiNode*> q;
    q.push(tree);
    // 从数组中构建二叉树
    for (int i = 1; i <= n / 2; ++i) { // 只需要处理到倒数第二层
        BiNode* p = q.front();
        q.pop();
        if (i * 2 <= n && arr[i * 2] != -1) {// 处理左孩子
            BiNode* leftChild = new BiNode(arr[i * 2]);
            p->left = leftChild;
            q.push(leftChild);
        } 
        if (i * 2 + 1 <= n && arr[i * 2 + 1] != -1) {// 处理右孩子
            BiNode* rightChild = new BiNode(arr[i * 2 + 1]);
            p->right = rightChild;
            q.push(rightChild);
        }
    }
    return tree;
}
```



## Former



### 原地逆置

> 思想： 将头结点摘下，然后从第一结点开始，依次插入到头结点的后面（头插法 建立单链表），直到最后一个结点为止，这样就实现了链表的逆置

``` c
LNode *reverse(LinkList &list) {
    LNode *p, *r;
    // p 指向链表的第一个实际数据节点
    p = list->next;
    // 当 p 不为空时，继续循环
    while (p != NULL) {
        // r 保存 p 的下一个节点
        r = p->next;
        // 将 p 的 next 指针指向前一个节点（即当前头节点的 next）
        p->next = list->next;
        // 将 p 插入到头节点之后
        list->next = p;
        // 移动 p 到下一个节点
        p = r;
    }
    // 返回反转后的链表头节点
    return list;
}
```



### 图

#### 邻接表to邻接矩阵

> ### 思想
>
> - **初始化**：将邻接矩阵的所有元素初始化为0，表示初始状态下没有任何边。
> - **填充邻接矩阵**：遍历邻接表中的每个顶点及其链表，若不为空，将存在的边信息填充到邻接矩阵中。

``` c
void AGraphToMGraph(AGraph *g, MGraph *m) {
    // 初始化邻接矩阵
    for (int i = 0; i < g->vexNum; ++i) {
        for (int j = 0; j < g->vexNum; ++j) 
            m->edges[i][j] = 0; // 初始化所有元素为0，表示无边
    }
    // 将邻接表中的边信息填充到邻接矩阵中
    for (int i = 0; i < g->vexNum; ++i) {
        ArcNode *p = g->adjlist[i].firstarc;
        while (p != NULL) {
            m->edges[i][p->adjvex] = 1; // 表示存在一条从i到p->adjvex的边
            p = p->next;
        }
    }
}
```



#### 邻接表vi-vj的路径

> 1. **深度优先搜索 (DFS)**：
>    - 如果当前顶点 `vi` 等于目标顶点 `vj`，则返回 `true`，表示找到了路径。
>    - 标记当前顶点 `vi` 为已访问。
>    - 遍历当前顶点的所有邻接顶点，对于每个未访问的邻接顶点，递归调用 `dfs`。
>    - 如果在递归调用中找到了路径，则返回 `true`。
>    - 如果遍历完所有邻接顶点后仍未找到路径，则返回 `false`。

``` c
// 使用深度优先搜索 (DFS) 来判断是否存在从 vi 到 vj 的路径
bool dfs(AGraph *g, int vi, int vj, int visited[]) {
    visited[vi] = true; // 标记当前顶点为已访问
    // 遍历当前顶点的所有邻接顶点
    for (ArcNode *p = g->adjlist[vi].firstarc; p != NULL; p = p->next) {
        int next = p->adjvex;
        if (!visited[next]) { // 如果邻接顶点未被访问
            if (dfs(g, next, vj, visited)) {
                return true; // 递归调用找到路径
            }
        }
    }
    return false; // 未找到路径
}

```



## 2015_833



### 1



> 1. **回溯法**：
>    - 使用递归函数 `backtrack` 来生成所有可能的排列。
>    - 在每次递归中，将每个未使用数字放入当前位置 `pos[step]`。
>    - 如果当前排列已经填满（即 `step == 7`），则检查该排列是否满足条件。如果满足条件，则记录该解并输出。
> 2. **检查条件**：
>    - 使用 `is_valid` 函数来检查当前排列是否满足每条边上的三个数字之和相等的条件。
>      - A + D + B==A + E + C ==B + F + C
> 3. **回溯**：
>    - 当前排列不满足条件，或还没填满，尝试其他可能。在递归返回后，恢复当前状态（即回溯），以便尝试其他可能性。

``` c
int count = 0; // 记录满足条件的解的数量
int nums[6] = {1, 2, 3, 4, 5, 6}; // 1到6的数字
int visited[6] = {0}; // 标记数字是否被使用
int pos[7]; // 当前排列，下标从1开始

// 检查当前排列是否满足条件
bool isValid(int pos[]) {
    int sum1 = pos[1] + pos[4] + pos[2];
    int sum2 = pos[1] + pos[5] + pos[3];
    int sum3 = pos[2] + pos[6] + pos[3];
    return sum1 == sum2 && sum2 == sum3;
}
// 回溯函数
void backtrack(int step) {
    if (step == 7) {
        if (isValid(pos)) {
            count++;
            printf("Solution %d: ", count);
            for (int i = 1; i <= 6; i++) 
                printf("%d ", pos[i]);
            printf("\n");
        }
        return;
    }
    for (int i = 1; i <= 6; i++) {
        if (!visited[i - 1]) {
            pos[step] = i;
            visited[i - 1] = 1;
            backtrack(step + 1);
            visited[i - 1] = 0;
        }
    }
}
```







## 2016_833

###  1(vr6174)

``` c
// 比较函数，用于qsort
int cmp(const void *a, const void *b) {
    return *(int *) a - *(int *) b;
}
int arr[4];//存储各个位数的值
void divide(int n) {
    arr[0] = n % 1000;// 千位
    arr[1] = (n % 100) / 10;
    arr[2] = (n / 100) % 10;
    arr[3] = n % 10;
}

void max_min(int &maxn, int &minn) {
    maxn = arr[0] * 1 + arr[1] * 10 + arr[2] * 100 + arr[3] * 1000;
    minn = arr[0] * 1000 + arr[1] * 100 + arr[2] * 10 + arr[3] * 1;
}

int vr6174(int n) {
    divide(n);
    int maxn, minn;
    while (n != 6174) {
        max_min(maxn, minn);
        n = maxn - minn;
        printf("%d - %d = %d\n", maxn, minn, n);

    }
    printf("%d - %d = %d\n", maxn, minn, n);

}
int main() {
    int n = 5346;
    vr6174(n);
    return 0;
}
```



### 1



> 1. **回溯法**：
>    - 使用递归函数 `backtrack` 来生成所有可能的排列。
>    - 在每次递归中，将每个未使用数字放入当前位置 `pos[step]`。
>    - 如果当前排列已经填满（即 `step == 7`），则检查该排列是否满足条件。如果满足条件，则记录该解并输出。
> 2. **检查条件**：
>    - 使用 `is_valid` 函数来检查当前排列是否满足每条边上的三个数字之和相等的条件。
>      - A + D + B==A + E + C ==B + F + C
> 3. **回溯**：
>    - 当前排列不满足条件，或还没填满，尝试其他可能。在递归返回后，恢复当前状态（即回溯），以便尝试其他可能性。

``` c
int count = 0; // 记录满足条件的解的数量
int nums[6] = {1, 2, 3, 4, 5, 6}; // 1到6的数字
int visited[6] = {0}; // 标记数字是否被使用
int pos[7]; // 当前排列，下标从1开始

// 检查当前排列是否满足条件
bool isValid(int pos[]) {
    int sum1 = pos[1] + pos[4] + pos[2];
    int sum2 = pos[1] + pos[5] + pos[3];
    int sum3 = pos[2] + pos[6] + pos[3];
    return sum1 == sum2 && sum2 == sum3;
}
// 回溯函数
void backtrack(int step) {
    if (step == 7) {
        if (isValid(pos)) {
            count++;
            printf("Solution %d: ", count);
            for (int i = 1; i <= 6; i++) 
                printf("%d ", pos[i]);
            printf("\n");
        }
        return;
    }
    for (int i = 1; i <= 6; i++) {
        if (!visited[i - 1]) {
            pos[step] = i;
            visited[i - 1] = 1;
            backtrack(step + 1);
            visited[i - 1] = 0;
        }
    }
}
```







### 2(删除重复元素)



> ### 算法思想简述
>
> 1. **初始化**：
>    - `seen` 数组用于记录已经遇到的节点值，假设数据范围在0到999之间。
>    - `current` 指针用于遍历链表。
>    - `prev` 指针用于记录当前节点的前一个节点。
> 2. **遍历链表**：
>    - 使用 `while (current != NULL)` 循环遍历链表，直到当前节点为空。
>    - 检查当前节点的值是否已经存在于seen数组中：
>      - 如果存在，说明当前节点是重复节点，需要删除：更新相应指针
>      - 如果不存在，说明当前节点是第一次遇到：
>        - 在 `seen` 数组中标记当前节点的值为已见过。
>        - 更新 `prev` 指针，使其指向当前节点。
>        - 移动 `current` 指针，使其指向下一个节点。
> 3. **返回处理后的链表头**：
>
> 有序
>
> - 使用 `while (current != NULL && current->next != NULL)` 循环遍历链表，直到当前节点或其下一个节点为空。
> - 检查当前节点的值是否与下一个节点的值相同：
>   - 如果相同，说明当前节点的下一个节点是重复节点，需要删除，修改相应指针
>   - 如果不同，说明当前节点的值与下一个节点的值不同，移动 `current` 指针到下一个节点。



``` c

// 删除无序链表中的重复节点
Node* removeDuplicatesUnordered(Node *head) {
    if (head == NULL) return head; // 如果链表为空，直接返回

    int seen[1000] = {0}; // 假设数据范围在0到999之间，初始化为0
    Node *p = head; // 当前节点指针
    Node *prev = NULL; // 前一个节点指针

    while (p != NULL) { // 遍历链表
        if (seen[p->data]) { // 如果当前节点的值已经见过
            // 当前节点是重复节点，删除它
            prev->next = p->next; // 跳过当前节点
            free(p); // 释放当前节点的内存
            p = prev->next; // 更新当前节点指针
        } else {
            // 标记当前节点的数据为已见过
            seen[p->data] = 1;
            prev = p; // 更新前一个节点指针
            p = p->next; // 移动到下一个节点
        }
    }
    return head; // 返回处理后的链表头
}



// 删除有序链表中的重复节点
Node* removeDuplicatesOrdered(Node *head) {
    if (head == NULL) return head; // 如果链表为空，直接返回
    Node *p = head; // 当前节点指针

    while (p != NULL && p->next != NULL) { // 遍历链表，直到当前节点或其下一个节点为空
        if (p->data == p->next->data) { // 如果当前节点的值与下一个节点的值相同
            // 当前节点是重复节点，删除下一个节点
            Node *temp = p->next; // 临时保存要删除的节点
            p->next = temp->next; // 跳过下一个节点
            free(temp); // 释放要删除的节点的内存
        } else 
            // 当前节点的值与下一个节点的值不同，移动到下一个节点
            p = p->next;
    }
    return head; // 返回处理后的链表头
}

```



### 3(哈夫曼树)(思想)

> 哈夫曼树（Huffman Tree）是一种最优二叉树，也称为最小路径树。它广泛应用于数据压缩领域，特别是文本压缩。哈夫曼树的构建过程如下：
>
> 1. **初始化**：
>    - 将每个字符及其频度作为一个节点，放入优先队列（最小堆）中。
> 2. **构建哈夫曼树**：
>    - 从优先队列中取出两个频度最小的节点，创建一个新的内部节点，其频度为这两个节点的频度之和。
>    - 将新的内部节点插入优先队列。
>    - 重复上述步骤，直到优先队列中只剩下一个节点，该节点即为哈夫曼树的根节点。
> 3. **生成哈夫曼编码**：
>    - 从根节点开始，遍历哈夫曼树，左子树赋值为0，右子树赋值为1。
>    - 每个叶子节点的路径即为其对应的哈夫曼编码。
>
> ### 给定数列的哈夫曼树构建
>
> 给定数列为：(15, 8, 10, 21, 6, 19, 3)，分别代表字符A, B, C, D, E, F, G的频度。
>
> 1. **初始化**：
>    - 创建7个节点，分别代表A(15), B(8), C(10), D(21), E(6), F(19), G(3)。
> 2. **构建哈夫曼树**：
>    - 从优先队列中取出两个频度最小的节点G(3)和E(6)，创建一个新的内部节点，频度为9。
>    - 将新的内部节点插入优先队列。
>    - 重复上述步骤，直到优先队列中只剩下一个节点。





### 5(定长数组)

``` c
void fun(int a[], int b[], int lena, int lenb) {
    int minIndex;
    for (int i = 0; i < lena; ++i) {
        minIndex = 0;
        for (int j = 0; j < lenb; ++j) {
            if (b[j] < b[minIndex])
                minIndex = j;
        }
        swap(a[i], b[minIndex]);
    }
    //对b进行排序
    for (int i = 0; i < lenb; ++i) {
        minIndex = i;
        for (int j = i; j < lenb; ++j) {
            if (b[j] < b[minIndex])
               minIndex = j;
        }
        swap(b[i], b[minIndex]);
    }
}
int main() {
    int a[] = {4, 12, 28};
    int b[] = {1, 7, 9, 29, 45};
    fun(a, b, 3, 5);
    for (int i = 0; i < 3; ++i)
        cout << a[i] << " ";
    cout << endl;
    for (int i = 0; i < 5; ++i)
        cout << b[i] << " ";
    cout << endl;
    return 0;
}
```



### 6(二分查找)

``` c
// 二分查找函数
int binarySearch(int arr[], int low, int high, int x) {
    while (low <= high) {
        int mid = low + (high - low) / 2; // 防止溢出
        if (arr[mid] == x) 
            return mid;
        else if (arr[mid] > x) 
            high = mid - 1;
        else 
            low = mid + 1;
    }
    return -1; // 未找到
}
```



### 7(矩阵连乘)

``` c
void MatrixMultiple() {
    // 初始化
    for (int i = 1; i <= n; ++i) 
        dp[i][i] = 0; // 一个矩阵连乘为0

    // 动态规划填表
    for (int len = 2; len <= n; ++len) { // 子问题的长度
        for (int i = 1; i <= n - len + 1; ++i) {
            int j = i + len - 1;
            dp[i][j] = Max; // 初始化为最大值
            for (int k = i; k < j; ++k) 
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + p[i - 1] * p[k] * p[j]);
          
        }
    }
}

```

### 8(加油站|贪心)

> 通过贪心算法来解决。在这个问题中，我们的目标是最小化加油次数，同时确保汽车能够到达目的地。
>
> ### 算法思想
>
> 1. **遍历加油站**：
>    - 从第 1 个加油站开始，依次检查每个加油站。
>    - 如果当前油量不足以到达下一个加油站，则在当前加油站加油，并增加加油次数。
>    - 更新当前油量为 `n` 公里。
>    - 继续检查下一个加油站。
> 2. **终止条件**：
>    - 如果能够到达最后一个加油站（目的地），输出加油次数。
>    - 如果在某个加油站无法继续前进，则输出 “No Solution!”。

``` c
#define MaxSize 10
int c = 7; // 加满跑多远
int n = 7; // 加油站数量
int arr[MaxSize] = {1, 2, 3, 4, 5, 1, 6, 6}; // 每个加油站之间的距离

void gasStation() {
    int count = 0;
    int cv = c; // 初始油量
    for (int i = 0; i < n; ++i) {
        if (cv < arr[i]) {//若不能到下一个加油站 则加满
            count++;
            cv = c;
        }
            cv -= arr[i];
    }
}
```



## 2017

###  1(移动奇偶元素)

> 这个过程是通过双指针技术实现的，一个指针 `left` 从数组的开头开始，另一个指针 `right` 从数组的末尾开始。算法的具体步骤如下：
>
> 1. **初始化指针**：`left` 指向数组的第一个元素（索引为 0），`right` 指向数组的最后一个元素（索引为 `n-1`）。
> 2. **遍历数组**：使用 `while` 循环，当 `left` 指针小于 `right` 指针时继续执行。
> 3. **检查当前指针位置的元素**：
>    - i指向奇数，j指向偶数，i--，j++
>    - i指向偶数，j指向奇数，交换下标元素，i--,j++;
>    - i指向偶数，j指向偶数, j--;
>    - i指向奇数，j指向奇数, i++;
> 4. **结束条件**：当 `left` 指针不再小于 `right` 指针时，遍历结束，此时数组中的所有奇数都应该位于偶数之前。

``` c
void oddAndEven() {
    int left = 0;
    int right = n - 1;
    while (left < right) {
        if (arr[left] % 2 == 1 and arr[right] % 2 == 0) {//符合
            left++;
            right--;
        } else if (arr[left] % 2 == 0 and arr[right] % 2 == 1) {
            swap(arr[left], arr[right]);
            left++;
            right--;
        } else if (arr[left] % 2 == 1 and arr[right] % 2 == 1)
            left++;
        else
            right--;
    }
}
```



### 2(括号匹配)



> ### 算法思想
>
> 1. **遍历链表**：
>    - 从链表的头节点的下一个节点开始遍历。
>    - 每当遇到一个左括号 `(` 时，将其压入栈中。
>    - 每当遇到一个右括号)时，检查栈是否为空：
>      - 如果栈为空，说明没有匹配的左括号，返回 `false`。
>      - 如果栈不为空，弹出栈顶的左括号，继续检查。
>    - 遍历结束后，检查栈是否为空：
>      - 如果栈为空，说明所有括号都匹配，返回 `true`。
>      - 如果栈不为空，说明有未匹配的左括号，返回 `false`。

``` c
bool checkBracket(linkList head) {
    if (head == NULL)
        return true;
    stack<char> s;
    LNode *p = head->next;
    while (p != NULL) {
        if (p->ch == '(')
            s.push(p->ch);
        else if (p->ch == ')') {
            if (s.empty())
                return false; // 栈为空，没有匹配的左括号
            else
                s.pop();//括号匹配 栈顶元素出栈
        }
        p = p->next;
    }
    return s.empty(); // 栈为空，说明所有括号都匹配
}
```





### 3(唯一字符)

> 1. **统计字符出现次数**：
>    - 使用一个数组 `arr` 来记录每个字符出现的次数。
>    - 遍历字符串，更新 `arr` 中对应字符的计数。
> 2. **查找第一个唯一字符**：
>    - 再次遍历字符串，找到第一个在 `arr` 中计数为 1 的字符。

``` c
void firstUniqueChar(string str, int n) {
    int arr[26] = {0}; // 用于记录每个字符出现的次数
    // 统计每个字符出现的次数
    for (int i = 0; i < n; ++i) {
        arr[str[i] - 'a']++;
    }
    // 查找第一个唯一字符
    for (int i = 0; i < n; ++i) {
        if (arr[str[i] - 'a'] == 1) {
            cout << "The first unique character is: " << str[i] << endl;
            return;
        }
    }
    // 如果没有唯一字符
    cout << "No unique character found." << endl;
}

```





### 4(Fibonacci)

> <img src="./%E5%A4%8D%E4%B9%A0%E6%96%87%E6%A1%A3.assets/image-20241101183439995-1730457282368-1.png" alt="image-20241101183439995" style="zoom:50%;" />



``` c
int Fibonacci1(int n) {
    int f[n + 3];
    f[0] = 0;
    f[1] = 1;
    for (int i = 2; i < n; ++i)
        f[i] = f[i - 1] + f[i - 2];
    return f[n];
}
```



### 6(大整数乘法|加法)



> 1. **逐位相乘**：
>    - 用两个嵌套的循环遍历数组 `a` 和 `b`，计算每一位的乘积并加上当前的进位 `x`。
>    - 将结果存入结果数组 `c` 中，并更新进位 `x`。
> 2. **计算结果的长度**：
>    - 计算结果数组 `c` 的实际长度 `lenc`，并去掉前置 0。
> 3. **输出结果**：
>    - 从结果数组 `c` 的最后一位开始输出，直到第一位。



``` c
char str1[110], str2[110]; // 用于存储输入的两个字符串
int a[110], b[110], c[300], x, lena, lenb, lenc; // 用于存储转换后的数字数组、进位、结果数组和长度

int main() {
    // 读取输入的两个字符串
    cin >> str1;
    cin >> str2;

    // 计算字符串的长度
    lena = strlen(str1);
    lenb = strlen(str2);
    // 将字符串转换为数组，逆序存储
    for (int i = 0; i < lena; ++i)
        a[lena - i - 1] = str1[i] - '0'; 
    for (int i = 0; i < lenb; ++i)
        b[lenb - i - 1] = str2[i] - '0'; 

    // 初始化结果数组为0
    memset(c, 0, sizeof(c)); 

    // 逐位相乘
    for (int i = 0; i < lenb; ++i) { // 遍历数组 b 的每一位
        x = 0; // 当前进位初始化为 0
        for (int j = 0; j < lena; ++j) { // 遍历数组 a 的每一位
            c[i + j] += a[j] * b[i] + x; // 计算当前位的乘积并加上进位
            x = c[i + j] / 10; // 计算新的进位
            c[i + j] %= 10; // 当前位的结果保留个位数
        }
        c[i + lena] = x; // 将最后的进位存入结果数组 c 中
    }

    // 初始结果长度为 lena + lenb
    lenc = lena + lenb; 
    while (lenc > 1 && c[lenc - 1] == 0) // 去掉结果数组 c 中的前置 0
        lenc--;
    
    for (int i = lenc - 1; i >= 0; --i) // 从结果数组 c 的最后一位开始输出
        cout << c[i];

    return 0;
}
```





> ### 算法思想
>
> 1. **计算字符串长度转为数组**：
>
>    - 计算 `s1` 和 `s2` 的长度 `lena` 和 `lenb`。
>
>    - 将字符串 `s1` 和 `s2` 转换为数组 `a` 和 `b`，并逆序存储。逆序存储的原因是为了方便逐位相加，从最低位开始计算。
>
> 2. **逐位相加**：
>
>    - 逐位计算 `a` 和 `b` 的和，并处理进位。将结果存储在数组 `c` 中。
>
> 3. **计算结果的长度并输出**：
>
>    - 计算结果数组 `c` 的实际长度 `lenc`，并去掉前置 0。
>
>    - 从结果数组 `c` 的最后一位开始输出，直到第一位。



``` c
#include <iostream>
#include <cstring>
using namespace std;

char s1[205], s2[205]; // 用于存储输入的两个字符串
int a[205], b[205], c[205], lena, lenb, lenc; // 用于存储转换后的数字数组、结果数组和长度

int main() {
    // 读取输入的两个字符串
    cin >> s1 >> s2;

    // 计算字符串的长度
    lena = strlen(s1);
    lenb = strlen(s2);

    // 将字符串转换为数组，逆序存储
    for (int i = 0; i < lena; ++i)
        a[i] = s1[lena - i - 1] - '0'; // 将 s1 的每一位转换为数字并逆序存储到数组 a 中
    for (int i = 0; i < lenb; ++i)
        b[i] = s2[lenb - i - 1] - '0'; // 将 s2 的每一位转换为数字并逆序存储到数组 b 中

    // 结果数组的长度至少为较长字符串的长度加1，以容纳可能的进位
    lenc = max(lena, lenb) + 1; 

    // 逐位相加
    for (int i = 0; i < lenc; ++i) {
        c[i] = a[i] + b[i] + c[i]; // 计算当前位的和
        c[i + 1] = c[i] / 10; // 计算新的进位
        c[i] %= 10; // 当前位的结果保留个位数
    }

    while (lenc > 0 && c[lenc - 1] == 0) // 去掉结果数组 c 中的前置 0
        lenc--;
    for (int i = lenc - 1; i >= 0; --i) // 从结果数组 c 的最后一位开始输出
        cout << c[i];
    return 0;
}
```



### 快速幂

> ### 算法思想
>
> 1. **快速幂（平方求幂）**：
>    - 快速幂是一种高效的计算 `a^n` 的方法，时间复杂度为 O(log⁡n)。
>    - 基本思想是利用指数的性质，将指数 `n` 分解为若干个 2 的幂次的和。
> 2. **算法步骤**：
>    - 当指数n不为 0 时，执行以下步骤：
>      - 如果 `n` 是奇数，将当前的 `a` 乘到结果 `res` 中。
>      - 将底数 `a` 的值平方。
>      - 将指数 `n` 右移一位，相当于 `n = n / 2`。
>    - 返回最终结果 `res`。

``` c
// 快速幂函数
int quickPow(int a, int n) {
    int res = 1; // 初始化结果为1

    // 当指数 n 不为 0 时，继续循环
    while (n) {
        // 如果 n 是奇数，则将当前的 a 乘到结果中
        if (n & 1) // 检查 n 的最低位是否为 1
            res = res * a;
        // 将 a 的值平方
        a = a * a;
        n =n/2;
    }

    return res;
}

```





## 2018

### 1 Reverse

> 1. **计算实际旋转次数**：
>    - 由于数组长度为 `n`，如果 `k` 大于 `n`，则实际旋转次数应该是取余`k % n`。
> 2. **三次反转**：
>    - **第一次反转**：反转数组的前 `k` 个元素。例如，对于数组 `[1, 2, 3, 4, 5]` 和 `k = 3`，反转后变为 `[3, 2, 1, 4, 5]`。
>    - **第二次反转**：反转数组的后 `n - k` 个元素。继续上面的例子，反转后变为 `[3, 2, 1, 5, 4]`。
>    - **第三次反转**：反转整个数组。继续上面的例子，反转后变为 `[4, 5, 1, 2, 3]`。
>
> - 总的时间复杂度是 O(k) + O(n - k) + O(n) = O(n)。

``` c
void Reverse(int arr[], int l, int r) {
    while (l < r)
        swap(arr[l++], arr[r--]);
}

int move(int arr[], int n, int k) {
    k = k % n;  // 计算实际旋转次数
    Reverse(arr, 0, k - 1);  // 反转前 k 个元素
    Reverse(arr, k, n - 1);  // 反转后 n - k 个元素
    Reverse(arr, 0, n - 1);  // 反转整个数组
}
```



### 2 move

> ### 算法思想
>
> 1. **初始化指针**：
>
>    - 使用两个指针 `left` 和 `right`，分别指向数组的起始位置和结束位置。
>
> 2. **移动指针**：
>
>    - 从左向右移动 `left` 指针，直到遇到一个偶数。
>    - 从右向左移动 `right` 指针，直到遇到一个奇数。
>
> 3. **交换元素**：
>
>    - 当 `left` 指针遇到偶数且 `right` 指针遇到奇数时，交换这两个位置的元素。
>
> 4. **终止条件**：
>
>    - 当 `left` 指针和 `right` 指针相遇或交错时，停止循环。
>
>      每个指针最多遍历数组一次，因此时间复杂度是 O(n)，其中 n 是数组的长度

``` c
// 将数组中的奇数移动到前面，偶数移动到后面
void move(int arr[], int n) {
    int left = 0;
    int right = n - 1;
    while (left < right) {
        // 移动 left 指针，直到遇到偶数
        while (left < right && arr[left] % 2 == 1)
            left++;
        // 移动 right 指针，直到遇到奇数
        while (left < right && arr[right] % 2 == 0)
            right--;
        if (left < right)    // 交换 left 和 right 指针所指向的元素
            swap(arr[left], arr[right]);
    }
}
```



### 3最大宽度

> ### 算法思想
>
> 1. **层次遍历（广度优先搜索，BFS）**：
>    - 使用一个队列 `q` 来存储每一层的节点。
>    - 初始化队列，将根节点加入队列。
>    - 每次处理一层节点时，记录当前层的节点数 `size`，并更新最大宽度 `maxWidth`。
>    - 将当前层的所有节点的左右子节点依次加入队列，以便在下一轮处理。
> 2. **更新最大宽度**：
>    - 在每一层处理完毕后，使用 `max` 函数更新最大宽度 `maxWidth`。
>
> 1. **时间复杂度**：
>    - 每个节点都会被访问一次，因此时间复杂度是 O(n)，其中 n 是二叉树的节点数。
> 2. **空间复杂度**：
>    - 队列的最大长度为二叉树的最大宽度，因此空间复杂度是 O(w)，其中 w 是二叉树的最大宽度。在最坏情况下，空间复杂度为 O(n)。

``` c
// 定义二叉树节点结构
typedef struct BNode {
    int data;
    struct BNode *left, *right;
} BNode, *BTree;

// 计算二叉树的最大宽度
int getWidth(BTree root) {
    if (root == NULL)
        return 0;  // 如果根节点为空，宽度为0

    queue<BNode *> q;  // 使用队列进行层次遍历
    q.push(root);  // 将根节点加入队列
    int maxWidth = 0;  // 记录最大宽度
    while (!q.empty()) {  // 当队列不为空时继续遍历
        int count = q.size();  // 当前层的节点数
        maxWidth = max(maxWidth, count);  // 更新最大宽度

        // 处理当前层的所有节点
        for (int i = 0; i < count; ++i) {
            BNode *p = q.front();  // 获取队列前端的节点
            q.pop();  // 弹出队列前端的节点
            // 将当前节点的左右子节点加入队列
            if (p->left != NULL)
                q.push(p->left);
            if (p->right != NULL)
                q.push(p->right);
        }
    }
    return maxWidth;  // 返回最大宽度
}
```



### 4 LCA

> ### 算法思想
>
> 1. **递归查找**：
>    - 如果当前节点为空，返回 `NULL`。
>    - 如果当前节点是 `p` 或 `q` 中的一个，返回当前节点。
>    - 递归查找左子树中的 LCA。
>    - 递归查找右子树中的 LCA。
> 2. **确定 LCA**：
>    - 如果左子树和右子树都找到了 `p` 和 `q`，说明当前节点是 LCA。
>    - 如果只有一侧找到了 `p` 或 `q`，返回那一侧的结果（包括NULL。
>
> ### 时空复杂度
>
> 1. **时间复杂度**：
>    - 每个节点都会被访问一次，因此时间复杂度是 O(n)，其中 n 是二叉树的节点数。
> 2. **空间复杂度**：
>    - 由于使用了递归，空间复杂度主要取决于递归调用栈的深度。在最坏情况下（树的高度为 n），空间复杂度是 O(n)。在平衡二叉树的情况下，空间复杂度是 O(log n)。

``` c 

// 查找二叉树中两个节点的最近公共祖先
BNode *LCA(BTree root, int p, int q) {
    if (root == NULL or root->data == p or root->data == q)
        return root;
    // 递归查找左子树中的 LCA
    BNode *left = LCA(root->left, p, q);
    // 递归查找右子树中的 LCA
    BNode *right = LCA(root->right, p, q);

    // 如果左子树和右子树都找到了 p 和 q，说明当前节点是 LCA
    if (left && right)
        return root;
    // 如果只有一侧找到了 p 或 q，返回那一侧的结果
    if (left)
        return left;
    return right;
}

```



### 5(1的个数)

> ### 代码思想
>
> 1. **逐位分析**：
>    - 从最低位（个位）开始，逐位向上分析每一位上 1 出现的次数。
>    - 通过分析高位、当前位和低位的值，确定当前位上 1 出现的次数。

``` c
int countOneInN(int n) {
    int count = 0; // 记录 1 出现的次数
    int factor = 1; // 当前位的权重（个位为 1，十位为 10，百位为 100 等）

    // 逐位分析，直到处理完所有位
    while (n / factor > 0) {
        int high = n / (factor * 10); // 高位部分
        int curr = (n / factor) % 10; // 当前位
        int low = n % factor; // 低位部分
        // 计算当前位上 1 出现的次数
        if (curr > 1) 
            // 当前位大于 1 时，1 会在 (high + 1) 个完整周期内出现，每个周期有 factor 个 1
            count += (high + 1) * factor;
        else if (curr == 1) 
            // 当前位等于 1 时，1 会在 high 个完整周期内出现，加上低位部分的 (low + 1) 个 1
            count += high * factor + low + 1;
         else 
            // 当前位等于 0 时，1 只会在 high 个完整周期内出现
            count += high * factor;
        // 移动到更高位
        factor *= 10;
    }
    return count;
}
```



### 6(最大连续邮资)

> 该算法的主要思想是利用深度优先搜索（DFS）来探索所有可能的邮票组合，以确定能够连续组成的最大邮资值。具体来说，算法通过递归地尝试每一种邮票的每一个可能的数量，逐步构建出不同的邮票组合，并检查这些组合能否组成连续的邮资值。
>
> ### 算法思想概要
>
> 1. **初始化**：
>    - 定义必要的变量，包括邮票种类数`n`、每种邮票的最大数量`m`、邮票面值数组`postage[]`、记录最大连续邮资的`maxValue`、当前尝试的连续邮资值`sum`、当前组合的邮资值`currValue`以及一个标记变量`flag`。
> 2. **递归搜索（DFS）**：
>    - 使用递归函数`dfs(int step)`来尝试所有可能的邮票组合。
>    - `step`参数表示当前正在考虑的邮票种类。
>    - 在每次递归调用中，如果已经达到了递归的最深层（即`step == m`），则检查当前组合的邮资值是否等于目标值`sum`。如果相等，更新`maxValue`，并设置`flag`为1。
>    - 如果未达到最深层，则遍历所有邮票种类，尝试将每一种邮票加入当前组合，并递归调用`dfs`继续尝试下一张邮票。之后，回溯，即从当前组合中移除该邮票，尝试其他可能性。
> 3. **主循环**：
>    - 在主函数中使用一个无限循环来不断增加`sum`的值，即尝试组合出更大的连续邮资值。
>    - 每次循环开始时，重置`flag`为0，表示尚未找到当前的连续邮资值。
>    - 调用`dfs(0)`从第0种邮票开始尝试组合当前的`sum`值。
>    - 如果在一次完整的`dfs`调用后，`flag`仍为0，说明当前的`sum`值无法通过任何邮票组合得到，此时可以结束循环，因为更大的连续邮资值也无法组合出来。
>    - 最终，`maxValue`即为能够组合出来的最大连续邮资值。



``` c
int n = 5; // 邮票种类数
int m = 4; // 每种邮票的最大数量
int postage[] = {0, 1, 3, 11, 15, 32}; // 邮票面值
int maxValue = 0; // 记录最大连续邮资
int sum = 0; // 当前尝试的连续邮资值
int currValue; // 当前组合的邮资值
int flag = 0; // 标记是否找到了当前连续邮资值

// 递归函数，尝试所有可能的邮票组合
void dfs(int step) {
    if (flag) 
        return; // 如果已经找到当前连续邮资值，直接返回
    if (step == m) {
        if (sum == currValue) {
            maxValue = currValue; // 更新最大连续邮资
            flag = 1; // 标记找到当前连续邮资值
        }
        return;
    }
    for (int i = 0; i <=n; ++i) {
        currValue += postage[i]; // 尝试添加当前邮票
        if (step <= m) 
            dfs(step + 1); // 递归尝试下一张邮票
        currValue -= postage[i]; // 回溯，移除当前邮票
    }
}

int main() {
    while (1) {
        flag = 0; // 重置标志
        sum++; // 尝试下一个连续邮资值
        dfs(0); // 从第 0 种邮票开始，当前邮资为 0
        if (flag == 0) 
            break; // 如果当前连续邮资值无法组合出来，退出循环
    }
  
}
```

